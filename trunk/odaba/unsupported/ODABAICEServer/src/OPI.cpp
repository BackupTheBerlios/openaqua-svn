// **********************************************************************
//
// Copyright (c) 2003-2006 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.1.0
// Generated from file `OPI.ice'

#include <OPI.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 301
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __OPI__CheckOptions__Initialize_name = "Initialize";

static const ::std::string __OPI__DBObjectHandle__BeginTransaction_name = "BeginTransaction";

static const ::std::string __OPI__DBObjectHandle__ChangeTimeStamp_name = "ChangeTimeStamp";

static const ::std::string __OPI__DBObjectHandle__CommitTransaction_name = "CommitTransaction";

static const ::std::string __OPI__DBObjectHandle__CreateTempPropertyHandle_name = "CreateTempPropertyHandle";

static const ::std::string __OPI__DBObjectHandle__DeleteExtent_name = "DeleteExtent";

static const ::std::string __OPI__DBObjectHandle__DeleteExtentRef_name = "DeleteExtentRef";

static const ::std::string __OPI__DBObjectHandle__DisableEventHandling_name = "DisableEventHandling";

static const ::std::string __OPI__DBObjectHandle__EnableEventHandling_name = "EnableEventHandling";

static const ::std::string __OPI__DBObjectHandle__EventHandling_name = "EventHandling";

static const ::std::string __OPI__DBObjectHandle__ExecuteDBObjectAction_name = "ExecuteDBObjectAction";

static const ::std::string __OPI__DBObjectHandle__ExecuteExpression_name = "ExecuteExpression";

static const ::std::string __OPI__DBObjectHandle__ExtentExist_name = "ExtentExist";

static const ::std::string __OPI__DBObjectHandle__GetAccess_name = "GetAccess";

static const ::std::string __OPI__DBObjectHandle__GetActionResult_name = "GetActionResult";

static const ::std::string __OPI__DBObjectHandle__GetDBHandle_name = "GetDBHandle";

static const ::std::string __OPI__DBObjectHandle__GetDataSource_name = "GetDataSource";

static const ::std::string __OPI__DBObjectHandle__GetDictionary_name = "GetDictionary";

static const ::std::string __OPI__DBObjectHandle__GetExtent_name = "GetExtent";

static const ::std::string __OPI__DBObjectHandle__GetHighObject_name = "GetHighObject";

static const ::std::string __OPI__DBObjectHandle__GetObject_name = "GetObject";

static const ::std::string __OPI__DBObjectHandle__GetServerVariable_name = "GetServerVariable";

static const ::std::string __OPI__DBObjectHandle__GetSystemVersion_name = "GetSystemVersion";

static const ::std::string __OPI__DBObjectHandle__GetTimeStamp_name = "GetTimeStamp";

static const ::std::string __OPI__DBObjectHandle__GetTransactionLevel_name = "GetTransactionLevel";

static const ::std::string __OPI__DBObjectHandle__GetVersion_name = "GetVersion";

static const ::std::string __OPI__DBObjectHandle__IsClient_name = "IsClient";

static const ::std::string __OPI__DBObjectHandle__IsEmpty_name = "IsEmpty";

static const ::std::string __OPI__DBObjectHandle__IsOpened_name = "IsOpened";

static const ::std::string __OPI__DBObjectHandle__IsServer_name = "IsServer";

static const ::std::string __OPI__DBObjectHandle__IsValid_name = "IsValid";

static const ::std::string __OPI__DBObjectHandle__NewVersion_name = "NewVersion";

static const ::std::string __OPI__DBObjectHandle__OpenObject_name = "OpenObject";

static const ::std::string __OPI__DBObjectHandle__RollBack_name = "RollBack";

static const ::std::string __OPI__DBObjectHandle__SetActionResult_name = "SetActionResult";

static const ::std::string __OPI__DBObjectHandle__SetOverload_name = "SetOverload";

static const ::std::string __OPI__DBObjectHandle__SetServerVariable_name = "SetServerVariable";

static const ::std::string __OPI__DBObjectHandle__SetUserDefinedIdentity_name = "SetUserDefinedIdentity";

static const ::std::string __OPI__DBObjectHandle__SetVersion_name = "SetVersion";

static const ::std::string __OPI__DBObjectHandle__SetVersioni1_name = "SetVersioni1";

static const ::std::string __OPI__DBObjectHandle__SetVersioni2_name = "SetVersioni2";

static const ::std::string __OPI__DBObjectHandle__VersionCount_name = "VersionCount";

static const ::std::string __OPI__DataSourceHandle__BeginTransaction_name = "BeginTransaction";

static const ::std::string __OPI__DataSourceHandle__Close_name = "Close";

static const ::std::string __OPI__DataSourceHandle__CloseDBObject_name = "CloseDBObject";

static const ::std::string __OPI__DataSourceHandle__CloseDatabase_name = "CloseDatabase";

static const ::std::string __OPI__DataSourceHandle__CloseDictionary_name = "CloseDictionary";

static const ::std::string __OPI__DataSourceHandle__CloseProperty_name = "CloseProperty";

static const ::std::string __OPI__DataSourceHandle__CloseResourceDB_name = "CloseResourceDB";

static const ::std::string __OPI__DataSourceHandle__CommitTransaction_name = "CommitTransaction";

static const ::std::string __OPI__DataSourceHandle__Connect_name = "Connect";

static const ::std::string __OPI__DataSourceHandle__Disconnect_name = "Disconnect";

static const ::std::string __OPI__DataSourceHandle__Open_name = "Open";

static const ::std::string __OPI__DataSourceHandle__Openi02_name = "Openi02";

static const ::std::string __OPI__DataSourceHandle__Openi1_name = "Openi1";

static const ::std::string __OPI__DataSourceHandle__OpenDBObject_name = "OpenDBObject";

static const ::std::string __OPI__DataSourceHandle__OpenDatabase_name = "OpenDatabase";

static const ::std::string __OPI__DataSourceHandle__OpenDictionary_name = "OpenDictionary";

static const ::std::string __OPI__DataSourceHandle__OpenProperty_name = "OpenProperty";

static const ::std::string __OPI__DataSourceHandle__OpenResourceDB_name = "OpenResourceDB";

static const ::std::string __OPI__DataSourceHandle__RollBack_name = "RollBack";

static const ::std::string __OPI__DataSourceHandle__SetDBObject_name = "SetDBObject";

static const ::std::string __OPI__DataSourceHandle__SetDataSource_name = "SetDataSource";

static const ::std::string __OPI__DataSourceHandle__SetDatabase_name = "SetDatabase";

static const ::std::string __OPI__DataSourceHandle__SetDictionary_name = "SetDictionary";

static const ::std::string __OPI__DataSourceHandle__SetResourceDB_name = "SetResourceDB";

static const ::std::string __OPI__DataSourceHandle__SetVariables_name = "SetVariables";

static const ::std::string __OPI__DataSourceHandle__Setup_name = "Setup";

static const ::std::string __OPI__DataSourceHandle__SetupVariables_name = "SetupVariables";

static const ::std::string __OPI__DatabaseHandle__ActivateShadowBase_name = "ActivateShadowBase";

static const ::std::string __OPI__DatabaseHandle__BackupDB_name = "BackupDB";

static const ::std::string __OPI__DatabaseHandle__CheckDB_name = "CheckDB";

static const ::std::string __OPI__DatabaseHandle__CheckLicence_name = "CheckLicence";

static const ::std::string __OPI__DatabaseHandle__CloseWorkspace_name = "CloseWorkspace";

static const ::std::string __OPI__DatabaseHandle__ConsolidateWorkspace_name = "ConsolidateWorkspace";

static const ::std::string __OPI__DatabaseHandle__DeactivateShadowBase_name = "DeactivateShadowBase";

static const ::std::string __OPI__DatabaseHandle__DeleteWorkspace_name = "DeleteWorkspace";

static const ::std::string __OPI__DatabaseHandle__DisableWorkspace_name = "DisableWorkspace";

static const ::std::string __OPI__DatabaseHandle__DiscardWorkspace_name = "DiscardWorkspace";

static const ::std::string __OPI__DatabaseHandle__EnableWorkspace_name = "EnableWorkspace";

static const ::std::string __OPI__DatabaseHandle__ExecuteDatabaseAction_name = "ExecuteDatabaseAction";

static const ::std::string __OPI__DatabaseHandle__ExistWorkspace_name = "ExistWorkspace";

static const ::std::string __OPI__DatabaseHandle__GetDatabaseID_name = "GetDatabaseID";

static const ::std::string __OPI__DatabaseHandle__GetPath_name = "GetPath";

static const ::std::string __OPI__DatabaseHandle__GetSchemaVersion_name = "GetSchemaVersion";

static const ::std::string __OPI__DatabaseHandle__GetVersionString_name = "GetVersionString";

static const ::std::string __OPI__DatabaseHandle__GetWorkspace_name = "GetWorkspace";

static const ::std::string __OPI__DatabaseHandle__IgnoreWriteProtect_name = "IgnoreWriteProtect";

static const ::std::string __OPI__DatabaseHandle__InitDataArea_name = "InitDataArea";

static const ::std::string __OPI__DatabaseHandle__InitMainBase_name = "InitMainBase";

static const ::std::string __OPI__DatabaseHandle__InitSubBase_name = "InitSubBase";

static const ::std::string __OPI__DatabaseHandle__IsLicenced_name = "IsLicenced";

static const ::std::string __OPI__DatabaseHandle__IsShared_name = "IsShared";

static const ::std::string __OPI__DatabaseHandle__LocateWorkspace_name = "LocateWorkspace";

static const ::std::string __OPI__DatabaseHandle__OpenDatabase_name = "OpenDatabase";

static const ::std::string __OPI__DatabaseHandle__OpenWorkspace_name = "OpenWorkspace";

static const ::std::string __OPI__DatabaseHandle__RecreateExtent_name = "RecreateExtent";

static const ::std::string __OPI__DatabaseHandle__RestoreDB_name = "RestoreDB";

static const ::std::string __OPI__DatabaseHandle__SetupTypeID_name = "SetupTypeID";

static const ::std::string __OPI__DictionaryHandle__BaseType_name = "BaseType";

static const ::std::string __OPI__DictionaryHandle__CheckExpression_name = "CheckExpression";

static const ::std::string __OPI__DictionaryHandle__CheckExpressionInClass_name = "CheckExpressionInClass";

static const ::std::string __OPI__DictionaryHandle__CheckExtentDef_name = "CheckExtentDef";

static const ::std::string __OPI__DictionaryHandle__CheckValueSet_name = "CheckValueSet";

static const ::std::string __OPI__DictionaryHandle__CopyCodeset_name = "CopyCodeset";

static const ::std::string __OPI__DictionaryHandle__CopyExtentDef_name = "CopyExtentDef";

static const ::std::string __OPI__DictionaryHandle__CopyStructure_name = "CopyStructure";

static const ::std::string __OPI__DictionaryHandle__CopyType_name = "CopyType";

static const ::std::string __OPI__DictionaryHandle__CreateEnum_name = "CreateEnum";

static const ::std::string __OPI__DictionaryHandle__CreateTempExtent_name = "CreateTempExtent";

static const ::std::string __OPI__DictionaryHandle__DeleteEnum_name = "DeleteEnum";

static const ::std::string __OPI__DictionaryHandle__EnumToString_name = "EnumToString";

static const ::std::string __OPI__DictionaryHandle__GetLastSchemaVersion_name = "GetLastSchemaVersion";

static const ::std::string __OPI__DictionaryHandle__GetTempName_name = "GetTempName";

static const ::std::string __OPI__DictionaryHandle__IsBasicType_name = "IsBasicType";

static const ::std::string __OPI__DictionaryHandle__OpenDictionary_name = "OpenDictionary";

static const ::std::string __OPI__DictionaryHandle__StringToEnum_name = "StringToEnum";

static const ::std::string __OPI__DictionaryHandle__UpdateVersion_name = "UpdateVersion";

static const ::std::string __OPI__ODABAClient__ActivateGUIMessages_name = "ActivateGUIMessages";

static const ::std::string __OPI__ODABAClient__BackupDB_name = "BackupDB";

static const ::std::string __OPI__ODABAClient__CheckDB_name = "CheckDB";

static const ::std::string __OPI__ODABAClient__Close_name = "Close";

static const ::std::string __OPI__ODABAClient__Connect_name = "Connect";

static const ::std::string __OPI__ODABAClient__DictDisplay_name = "DictDisplay";

static const ::std::string __OPI__ODABAClient__Disconnect_name = "Disconnect";

static const ::std::string __OPI__ODABAClient__Exist_name = "Exist";

static const ::std::string __OPI__ODABAClient__GetDataSource_name = "GetDataSource";

static const ::std::string __OPI__ODABAClient__GetHost_name = "GetHost";

static const ::std::string __OPI__ODABAClient__GetPort_name = "GetPort";

static const ::std::string __OPI__ODABAClient__GetServerVariable_name = "GetServerVariable";

static const ::std::string __OPI__ODABAClient__Initialize_name = "Initialize";

static const ::std::string __OPI__ODABAClient__IsConnected_name = "IsConnected";

static const ::std::string __OPI__ODABAClient__KillClient_name = "KillClient";

static const ::std::string __OPI__ODABAClient__Open_name = "Open";

static const ::std::string __OPI__ODABAClient__OpenDataSource_name = "OpenDataSource";

static const ::std::string __OPI__ODABAClient__PackDatabase_name = "PackDatabase";

static const ::std::string __OPI__ODABAClient__RestoreDB_name = "RestoreDB";

static const ::std::string __OPI__ODABAClient__SendClientMessage_name = "SendClientMessage";

static const ::std::string __OPI__ODABAClient__SetServerVariable_name = "SetServerVariable";

static const ::std::string __OPI__ODABAClient__ShutDown_name = "ShutDown";

static const ::std::string __OPI__ODABAClient__StartPause_name = "StartPause";

static const ::std::string __OPI__ODABAClient__StatDisplay_name = "StatDisplay";

static const ::std::string __OPI__ODABAClient__StopPause_name = "StopPause";

static const ::std::string __OPI__ODABAClient__SysInfoDisplay_name = "SysInfoDisplay";

static const ::std::string __OPI__OperationHandle__CheckExpression_name = "CheckExpression";

static const ::std::string __OPI__OperationHandle__CheckExpressionInClass_name = "CheckExpressionInClass";

static const ::std::string __OPI__OperationHandle__Execute_name = "Execute";

static const ::std::string __OPI__OperationHandle__GetResult_name = "GetResult";

static const ::std::string __OPI__OperationHandle__GetSize_name = "GetSize";

static const ::std::string __OPI__OperationHandle__IsValid_name = "IsValid";

static const ::std::string __OPI__OperationHandle__Open_name = "Open";

static const ::std::string __OPI__OperationHandle__ProvideExpression_name = "ProvideExpression";

static const ::std::string __OPI__PropertyHandle__Add_name = "Add";

static const ::std::string __OPI__PropertyHandle__AddByKey_name = "AddByKey";

static const ::std::string __OPI__PropertyHandle__AddInstance_name = "AddInstance";

static const ::std::string __OPI__PropertyHandle__AddOnPosition_name = "AddOnPosition";

static const ::std::string __OPI__PropertyHandle__AddGlobal_name = "AddGlobal";

static const ::std::string __OPI__PropertyHandle__AddGlobalByKey_name = "AddGlobalByKey";

static const ::std::string __OPI__PropertyHandle__AddGlobalOnPosition_name = "AddGlobalOnPosition";

static const ::std::string __OPI__PropertyHandle__AddReference_name = "AddReference";

static const ::std::string __OPI__PropertyHandle__AllocDescription_name = "AllocDescription";

static const ::std::string __OPI__PropertyHandle__AllocateArea_name = "AllocateArea";

static const ::std::string __OPI__PropertyHandle__AppendString_name = "AppendString";

static const ::std::string __OPI__PropertyHandle__AutoLocate_name = "AutoLocate";

static const ::std::string __OPI__PropertyHandle__Cancel_name = "Cancel";

static const ::std::string __OPI__PropertyHandle__CancelBuffer_name = "CancelBuffer";

static const ::std::string __OPI__PropertyHandle__ChangeBuffer_name = "ChangeBuffer";

static const ::std::string __OPI__PropertyHandle__ChangeCache_name = "ChangeCache";

static const ::std::string __OPI__PropertyHandle__ChangeMode_name = "ChangeMode";

static const ::std::string __OPI__PropertyHandle__Check_name = "Check";

static const ::std::string __OPI__PropertyHandle__CheckPosition_name = "CheckPosition";

static const ::std::string __OPI__PropertyHandle__CheckUpdate_name = "CheckUpdate";

static const ::std::string __OPI__PropertyHandle__CheckWProtect_name = "CheckWProtect";

static const ::std::string __OPI__PropertyHandle__Close_name = "Close";

static const ::std::string __OPI__PropertyHandle__Compare_name = "Compare";

static const ::std::string __OPI__PropertyHandle__CompareDate_name = "CompareDate";

static const ::std::string __OPI__PropertyHandle__CompareFloat_name = "CompareFloat";

static const ::std::string __OPI__PropertyHandle__CompareInteger_name = "CompareInteger";

static const ::std::string __OPI__PropertyHandle__CompareString_name = "CompareString";

static const ::std::string __OPI__PropertyHandle__CompareTime_name = "CompareTime";

static const ::std::string __OPI__PropertyHandle__CompareKey_name = "CompareKey";

static const ::std::string __OPI__PropertyHandle__CompareSortKey_name = "CompareSortKey";

static const ::std::string __OPI__PropertyHandle__CompareType_name = "CompareType";

static const ::std::string __OPI__PropertyHandle__Copy_name = "Copy";

static const ::std::string __OPI__PropertyHandle__CopyData_name = "CopyData";

static const ::std::string __OPI__PropertyHandle__CopyHandle_name = "CopyHandle";

static const ::std::string __OPI__PropertyHandle__CopyInstanceArea_name = "CopyInstanceArea";

static const ::std::string __OPI__PropertyHandle__CopySet_name = "CopySet";

static const ::std::string __OPI__PropertyHandle__CreateTempExtent_name = "CreateTempExtent";

static const ::std::string __OPI__PropertyHandle__Delete_name = "Delete";

static const ::std::string __OPI__PropertyHandle__DeleteByKey_name = "DeleteByKey";

static const ::std::string __OPI__PropertyHandle__DeleteOnPosition_name = "DeleteOnPosition";

static const ::std::string __OPI__PropertyHandle__DeleteIndexEntry_name = "DeleteIndexEntry";

static const ::std::string __OPI__PropertyHandle__DeleteSet_name = "DeleteSet";

static const ::std::string __OPI__PropertyHandle__DisableKeyCheck_name = "DisableKeyCheck";

static const ::std::string __OPI__PropertyHandle__Duplicate_name = "Duplicate";

static const ::std::string __OPI__PropertyHandle__DuplicateKey_name = "DuplicateKey";

static const ::std::string __OPI__PropertyHandle__EnableKeyCheck_name = "EnableKeyCheck";

static const ::std::string __OPI__PropertyHandle__Execute_name = "Execute";

static const ::std::string __OPI__PropertyHandle__ExecuteExpression_name = "ExecuteExpression";

static const ::std::string __OPI__PropertyHandle__ExecuteInstanceAction_name = "ExecuteInstanceAction";

static const ::std::string __OPI__PropertyHandle__ExecutePropertyAction_name = "ExecutePropertyAction";

static const ::std::string __OPI__PropertyHandle__Exist_name = "Exist";

static const ::std::string __OPI__PropertyHandle__ExtractKey_name = "ExtractKey";

static const ::std::string __OPI__PropertyHandle__ExtractSortKey_name = "ExtractSortKey";

static const ::std::string __OPI__PropertyHandle__FirstKey_name = "FirstKey";

static const ::std::string __OPI__PropertyHandle__Get_name = "Get";

static const ::std::string __OPI__PropertyHandle__GetAtPosition_name = "GetAtPosition";

static const ::std::string __OPI__PropertyHandle__GetByKey_name = "GetByKey";

static const ::std::string __OPI__PropertyHandle__GetActionResult_name = "GetActionResult";

static const ::std::string __OPI__PropertyHandle__GetArea_name = "GetArea";

static const ::std::string __OPI__PropertyHandle__GetAttribute_name = "GetAttribute";

static const ::std::string __OPI__PropertyHandle__GetBaseProperty_name = "GetBaseProperty";

static const ::std::string __OPI__PropertyHandle__GetCollectionID_name = "GetCollectionID";

static const ::std::string __OPI__PropertyHandle__GetCollectionProperty_name = "GetCollectionProperty";

static const ::std::string __OPI__PropertyHandle__GetCount_name = "GetCount";

static const ::std::string __OPI__PropertyHandle__GetCurrentIndex_name = "GetCurrentIndex";

static const ::std::string __OPI__PropertyHandle__GetCurrentSize_name = "GetCurrentSize";

static const ::std::string __OPI__PropertyHandle__GetCurrentType_name = "GetCurrentType";

static const ::std::string __OPI__PropertyHandle__GetDBHandle_name = "GetDBHandle";

static const ::std::string __OPI__PropertyHandle__GetDate_name = "GetDate";

static const ::std::string __OPI__PropertyHandle__GetDateTime_name = "GetDateTime";

static const ::std::string __OPI__PropertyHandle__GetDay_name = "GetDay";

static const ::std::string __OPI__PropertyHandle__GetDictionary_name = "GetDictionary";

static const ::std::string __OPI__PropertyHandle__GetDimension_name = "GetDimension";

static const ::std::string __OPI__PropertyHandle__GetDouble_name = "GetDouble";

static const ::std::string __OPI__PropertyHandle__GetExtInstModCount_name = "GetExtInstModCount";

static const ::std::string __OPI__PropertyHandle__GetExtentName_name = "GetExtentName";

static const ::std::string __OPI__PropertyHandle__GetGUID_name = "GetGUID";

static const ::std::string __OPI__PropertyHandle__GetGenAttrType_name = "GetGenAttrType";

static const ::std::string __OPI__PropertyHandle__GetGenOrderType_name = "GetGenOrderType";

static const ::std::string __OPI__PropertyHandle__GetGlobalID_name = "GetGlobalID";

static const ::std::string __OPI__PropertyHandle__GetHours_name = "GetHours";

static const ::std::string __OPI__PropertyHandle__GetID_name = "GetID";

static const ::std::string __OPI__PropertyHandle__GetIdentity_name = "GetIdentity";

static const ::std::string __OPI__PropertyHandle__GetIndexName_name = "GetIndexName";

static const ::std::string __OPI__PropertyHandle__GetInitInstance_name = "GetInitInstance";

static const ::std::string __OPI__PropertyHandle__GetInstModCount_name = "GetInstModCount";

static const ::std::string __OPI__PropertyHandle__GetInt_name = "GetInt";

static const ::std::string __OPI__PropertyHandle__GetIntValue_name = "GetIntValue";

static const ::std::string __OPI__PropertyHandle__GetKey_name = "GetKey";

static const ::std::string __OPI__PropertyHandle__GetKeyLength_name = "GetKeyLength";

static const ::std::string __OPI__PropertyHandle__GetLOID_name = "GetLOID";

static const ::std::string __OPI__PropertyHandle__GetLOIDByKey_name = "GetLOIDByKey";

static const ::std::string __OPI__PropertyHandle__GetMinutes_name = "GetMinutes";

static const ::std::string __OPI__PropertyHandle__GetMode_name = "GetMode";

static const ::std::string __OPI__PropertyHandle__GetMonth_name = "GetMonth";

static const ::std::string __OPI__PropertyHandle__GetNormalized_name = "GetNormalized";

static const ::std::string __OPI__PropertyHandle__GetObjectHandle_name = "GetObjectHandle";

static const ::std::string __OPI__PropertyHandle__GetOrigin_name = "GetOrigin";

static const ::std::string __OPI__PropertyHandle__GetParentProperty_name = "GetParentProperty";

static const ::std::string __OPI__PropertyHandle__GetPropertyHandle_name = "GetPropertyHandle";

static const ::std::string __OPI__PropertyHandle__GetPropertyPath_name = "GetPropertyPath";

static const ::std::string __OPI__PropertyHandle__GetRefModCount_name = "GetRefModCount";

static const ::std::string __OPI__PropertyHandle__GetReference_name = "GetReference";

static const ::std::string __OPI__PropertyHandle__GetRelative_name = "GetRelative";

static const ::std::string __OPI__PropertyHandle__GetRelativeCount_name = "GetRelativeCount";

static const ::std::string __OPI__PropertyHandle__GetRelativeIndex_name = "GetRelativeIndex";

static const ::std::string __OPI__PropertyHandle__GetSeconds_name = "GetSeconds";

static const ::std::string __OPI__PropertyHandle__GetSelectedKey_name = "GetSelectedKey";

static const ::std::string __OPI__PropertyHandle__GetSize_name = "GetSize";

static const ::std::string __OPI__PropertyHandle__GetSizeOf_name = "GetSizeOf";

static const ::std::string __OPI__PropertyHandle__GetSortKey_name = "GetSortKey";

static const ::std::string __OPI__PropertyHandle__GetSortKeyLength_name = "GetSortKeyLength";

static const ::std::string __OPI__PropertyHandle__GetString_name = "GetString";

static const ::std::string __OPI__PropertyHandle__GetStringLength_name = "GetStringLength";

static const ::std::string __OPI__PropertyHandle__GetStringValue_name = "GetStringValue";

static const ::std::string __OPI__PropertyHandle__GetSubString_name = "GetSubString";

static const ::std::string __OPI__PropertyHandle__GetText_name = "GetText";

static const ::std::string __OPI__PropertyHandle__GetTime_name = "GetTime";

static const ::std::string __OPI__PropertyHandle__GetType_name = "GetType";

static const ::std::string __OPI__PropertyHandle__GetValid_name = "GetValid";

static const ::std::string __OPI__PropertyHandle__GetVersion_name = "GetVersion";

static const ::std::string __OPI__PropertyHandle__GetYear_name = "GetYear";

static const ::std::string __OPI__PropertyHandle__Group_name = "Group";

static const ::std::string __OPI__PropertyHandle__HasData_name = "HasData";

static const ::std::string __OPI__PropertyHandle__HasDescription_name = "HasDescription";

static const ::std::string __OPI__PropertyHandle__HasGenericAttributes_name = "HasGenericAttributes";

static const ::std::string __OPI__PropertyHandle__HasIndex_name = "HasIndex";

static const ::std::string __OPI__PropertyHandle__Inherits_name = "Inherits";

static const ::std::string __OPI__PropertyHandle__InsertString_name = "InsertString";

static const ::std::string __OPI__PropertyHandle__InsertTerminator_name = "InsertTerminator";

static const ::std::string __OPI__PropertyHandle__InstanceInserted_name = "InstanceInserted";

static const ::std::string __OPI__PropertyHandle__InstanceToString_name = "InstanceToString";

static const ::std::string __OPI__PropertyHandle__Intersect_name = "Intersect";

static const ::std::string __OPI__PropertyHandle__Is_name = "Is";

static const ::std::string __OPI__PropertyHandle__IsA_name = "IsA";

static const ::std::string __OPI__PropertyHandle__IsActive_name = "IsActive";

static const ::std::string __OPI__PropertyHandle__IsAttribute_name = "IsAttribute";

static const ::std::string __OPI__PropertyHandle__IsAutoSelection_name = "IsAutoSelection";

static const ::std::string __OPI__PropertyHandle__IsBasedOn_name = "IsBasedOn";

static const ::std::string __OPI__PropertyHandle__IsBasetypeProperty_name = "IsBasetypeProperty";

static const ::std::string __OPI__PropertyHandle__IsBasicType_name = "IsBasicType";

static const ::std::string __OPI__PropertyHandle__IsClient_name = "IsClient";

static const ::std::string __OPI__PropertyHandle__IsCollection_name = "IsCollection";

static const ::std::string __OPI__PropertyHandle__IsCollectionUpdate_name = "IsCollectionUpdate";

static const ::std::string __OPI__PropertyHandle__IsCopyHandle_name = "IsCopyHandle";

static const ::std::string __OPI__PropertyHandle__IsDirty_name = "IsDirty";

static const ::std::string __OPI__PropertyHandle__IsEmpty_name = "IsEmpty";

static const ::std::string __OPI__PropertyHandle__IsEnumeration_name = "IsEnumeration";

static const ::std::string __OPI__PropertyHandle__IsGenericAttribute_name = "IsGenericAttribute";

static const ::std::string __OPI__PropertyHandle__IsInitInstance_name = "IsInitInstance";

static const ::std::string __OPI__PropertyHandle__IsMemo_name = "IsMemo";

static const ::std::string __OPI__PropertyHandle__IsModified_name = "IsModified";

static const ::std::string __OPI__PropertyHandle__IsNewInstance_name = "IsNewInstance";

static const ::std::string __OPI__PropertyHandle__IsNumeric_name = "IsNumeric";

static const ::std::string __OPI__PropertyHandle__IsOldInstance_name = "IsOldInstance";

static const ::std::string __OPI__PropertyHandle__IsOwner_name = "IsOwner";

static const ::std::string __OPI__PropertyHandle__IsPositioned_name = "IsPositioned";

static const ::std::string __OPI__PropertyHandle__IsReadOnly_name = "IsReadOnly";

static const ::std::string __OPI__PropertyHandle__IsSelected_name = "IsSelected";

static const ::std::string __OPI__PropertyHandle__IsSensitive_name = "IsSensitive";

static const ::std::string __OPI__PropertyHandle__IsServer_name = "IsServer";

static const ::std::string __OPI__PropertyHandle__IsShareBaseHandle_name = "IsShareBaseHandle";

static const ::std::string __OPI__PropertyHandle__IsStructure_name = "IsStructure";

static const ::std::string __OPI__PropertyHandle__IsText_name = "IsText";

static const ::std::string __OPI__PropertyHandle__IsTransient_name = "IsTransient";

static const ::std::string __OPI__PropertyHandle__IsTrue_name = "IsTrue";

static const ::std::string __OPI__PropertyHandle__IsTyped_name = "IsTyped";

static const ::std::string __OPI__PropertyHandle__IsUserHandle_name = "IsUserHandle";

static const ::std::string __OPI__PropertyHandle__IsValid_name = "IsValid";

static const ::std::string __OPI__PropertyHandle__IsValidText_name = "IsValidText";

static const ::std::string __OPI__PropertyHandle__IsVariableType_name = "IsVariableType";

static const ::std::string __OPI__PropertyHandle__IsWeakTyped_name = "IsWeakTyped";

static const ::std::string __OPI__PropertyHandle__IsWrite_name = "IsWrite";

static const ::std::string __OPI__PropertyHandle__Locate_name = "Locate";

static const ::std::string __OPI__PropertyHandle__LocatePath_name = "LocatePath";

static const ::std::string __OPI__PropertyHandle__Lock_name = "Lock";

static const ::std::string __OPI__PropertyHandle__LockSet_name = "LockSet";

static const ::std::string __OPI__PropertyHandle__MarkUnused_name = "MarkUnused";

static const ::std::string __OPI__PropertyHandle__MarkUsed_name = "MarkUsed";

static const ::std::string __OPI__PropertyHandle__Minus_name = "Minus";

static const ::std::string __OPI__PropertyHandle__Modify_name = "Modify";

static const ::std::string __OPI__PropertyHandle__Move_name = "Move";

static const ::std::string __OPI__PropertyHandle__MoveDown_name = "MoveDown";

static const ::std::string __OPI__PropertyHandle__MoveUp_name = "MoveUp";

static const ::std::string __OPI__PropertyHandle__NextKey_name = "NextKey";

static const ::std::string __OPI__PropertyHandle__NoWrite_name = "NoWrite";

static const ::std::string __OPI__PropertyHandle__Open_name = "Open";

static const ::std::string __OPI__PropertyHandle__OpenBigInt_name = "OpenBigInt";

static const ::std::string __OPI__PropertyHandle__OpenBoolean_name = "OpenBoolean";

static const ::std::string __OPI__PropertyHandle__OpenChild_name = "OpenChild";

static const ::std::string __OPI__PropertyHandle__OpenChildReference_name = "OpenChildReference";

static const ::std::string __OPI__PropertyHandle__OpenCopy_name = "OpenCopy";

static const ::std::string __OPI__PropertyHandle__OpenDate_name = "OpenDate";

static const ::std::string __OPI__PropertyHandle__OpenExtent_name = "OpenExtent";

static const ::std::string __OPI__PropertyHandle__OpenFloat_name = "OpenFloat";

static const ::std::string __OPI__PropertyHandle__OpenInteger_name = "OpenInteger";

static const ::std::string __OPI__PropertyHandle__OpenReference_name = "OpenReference";

static const ::std::string __OPI__PropertyHandle__OpenSizedString_name = "OpenSizedString";

static const ::std::string __OPI__PropertyHandle__OpenString_name = "OpenString";

static const ::std::string __OPI__PropertyHandle__OpenTime_name = "OpenTime";

static const ::std::string __OPI__PropertyHandle__OpenTimestamp_name = "OpenTimestamp";

static const ::std::string __OPI__PropertyHandle__OpenHierarchy_name = "OpenHierarchy";

static const ::std::string __OPI__PropertyHandle__OwnsData_name = "OwnsData";

static const ::std::string __OPI__PropertyHandle__Position_name = "Position";

static const ::std::string __OPI__PropertyHandle__PositionTop_name = "PositionTop";

static const ::std::string __OPI__PropertyHandle__Power_name = "Power";

static const ::std::string __OPI__PropertyHandle__ProvGenAttribute_name = "ProvGenAttribute";

static const ::std::string __OPI__PropertyHandle__Provide_name = "Provide";

static const ::std::string __OPI__PropertyHandle__ProvideAtPosition_name = "ProvideAtPosition";

static const ::std::string __OPI__PropertyHandle__ProvideByKey_name = "ProvideByKey";

static const ::std::string __OPI__PropertyHandle__ProvideArea_name = "ProvideArea";

static const ::std::string __OPI__PropertyHandle__ProvideGUID_name = "ProvideGUID";

static const ::std::string __OPI__PropertyHandle__ProvideGlobal_name = "ProvideGlobal";

static const ::std::string __OPI__PropertyHandle__ProvideGlobalAtPosition_name = "ProvideGlobalAtPosition";

static const ::std::string __OPI__PropertyHandle__ProvideGlobalByKey_name = "ProvideGlobalByKey";

static const ::std::string __OPI__PropertyHandle__ProvideOperation_name = "ProvideOperation";

static const ::std::string __OPI__PropertyHandle__Refresh_name = "Refresh";

static const ::std::string __OPI__PropertyHandle__ReleaseBuffer_name = "ReleaseBuffer";

static const ::std::string __OPI__PropertyHandle__RemoveFromCollection_name = "RemoveFromCollection";

static const ::std::string __OPI__PropertyHandle__RemoveString_name = "RemoveString";

static const ::std::string __OPI__PropertyHandle__RemoveTerminator_name = "RemoveTerminator";

static const ::std::string __OPI__PropertyHandle__Rename_name = "Rename";

static const ::std::string __OPI__PropertyHandle__RepairIndex_name = "RepairIndex";

static const ::std::string __OPI__PropertyHandle__ReplaceString_name = "ReplaceString";

static const ::std::string __OPI__PropertyHandle__ReplaceSysVariables_name = "ReplaceSysVariables";

static const ::std::string __OPI__PropertyHandle__Reset_name = "Reset";

static const ::std::string __OPI__PropertyHandle__ResetDirty_name = "ResetDirty";

static const ::std::string __OPI__PropertyHandle__ResetTransientProperty_name = "ResetTransientProperty";

static const ::std::string __OPI__PropertyHandle__ResetWProtect_name = "ResetWProtect";

static const ::std::string __OPI__PropertyHandle__Save_name = "Save";

static const ::std::string __OPI__PropertyHandle__SearchText_name = "SearchText";

static const ::std::string __OPI__PropertyHandle__Select_name = "Select";

static const ::std::string __OPI__PropertyHandle__SetActionResult_name = "SetActionResult";

static const ::std::string __OPI__PropertyHandle__SetContextVariables_name = "SetContextVariables";

static const ::std::string __OPI__PropertyHandle__SetDirty_name = "SetDirty";

static const ::std::string __OPI__PropertyHandle__SetDynLength_name = "SetDynLength";

static const ::std::string __OPI__PropertyHandle__SetGenAttribute_name = "SetGenAttribute";

static const ::std::string __OPI__PropertyHandle__SetKey_name = "SetKey";

static const ::std::string __OPI__PropertyHandle__SetModified_name = "SetModified";

static const ::std::string __OPI__PropertyHandle__SetNormalized_name = "SetNormalized";

static const ::std::string __OPI__PropertyHandle__SetOrder_name = "SetOrder";

static const ::std::string __OPI__PropertyHandle__SetSelection_name = "SetSelection";

static const ::std::string __OPI__PropertyHandle__SetSortKey_name = "SetSortKey";

static const ::std::string __OPI__PropertyHandle__SetTransientProperty_name = "SetTransientProperty";

static const ::std::string __OPI__PropertyHandle__SetType_name = "SetType";

static const ::std::string __OPI__PropertyHandle__SetUpdate_name = "SetUpdate";

static const ::std::string __OPI__PropertyHandle__SetValue_name = "SetValue";

static const ::std::string __OPI__PropertyHandle__SetValueBigInt_name = "SetValueBigInt";

static const ::std::string __OPI__PropertyHandle__SetValueBoolean_name = "SetValueBoolean";

static const ::std::string __OPI__PropertyHandle__SetValueDate_name = "SetValueDate";

static const ::std::string __OPI__PropertyHandle__SetValueFloat_name = "SetValueFloat";

static const ::std::string __OPI__PropertyHandle__SetValueInteger_name = "SetValueInteger";

static const ::std::string __OPI__PropertyHandle__SetValueString_name = "SetValueString";

static const ::std::string __OPI__PropertyHandle__SetValueTime_name = "SetValueTime";

static const ::std::string __OPI__PropertyHandle__SetValueTimestamp_name = "SetValueTimestamp";

static const ::std::string __OPI__PropertyHandle__SetVersion_name = "SetVersion";

static const ::std::string __OPI__PropertyHandle__SetWProtect_name = "SetWProtect";

static const ::std::string __OPI__PropertyHandle__ToTop_name = "ToTop";

static const ::std::string __OPI__PropertyHandle__Union_name = "Union";

static const ::std::string __OPI__PropertyHandle__Unlock_name = "Unlock";

static const ::std::string __OPI__PropertyHandle__UnlockSet_name = "UnlockSet";

static const ::std::string __OPI__OPIFactory__Destroy_name = "Destroy";

static const ::std::string __OPI__OPIFactory__GetCheckOptions_name = "GetCheckOptions";

static const ::std::string __OPI__OPIFactory__GetDBObjectHandle_name = "GetDBObjectHandle";

static const ::std::string __OPI__OPIFactory__GetDataSourceHandle_name = "GetDataSourceHandle";

static const ::std::string __OPI__OPIFactory__GetDatabaseHandle_name = "GetDatabaseHandle";

static const ::std::string __OPI__OPIFactory__GetDictionaryHandle_name = "GetDictionaryHandle";

static const ::std::string __OPI__OPIFactory__GetODABAClient_name = "GetODABAClient";

static const ::std::string __OPI__OPIFactory__GetOperationHandle_name = "GetOperationHandle";

static const ::std::string __OPI__OPIFactory__GetPropertyHandle_name = "GetPropertyHandle";

static const ::std::string __OPI__Session__CreateSession_name = "CreateSession";

static const ::std::string __OPI__Session__Destroy_name = "Destroy";

static const ::std::string __OPI__Session__TimeOut_name = "TimeOut";

static const ::std::string __OPI__Session__getName_name = "getName";

static const ::std::string __OPI__SessionFactory__CreateProxy_name = "CreateProxy";

static const ::std::string __OPI__SessionFactory__shutdown_name = "shutdown";

void
IceInternal::incRef(::OPI::CheckOptions* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::CheckOptions* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::CheckOptions* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::CheckOptions* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::DBObjectHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::DBObjectHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::DBObjectHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::DBObjectHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::DataSourceHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::DataSourceHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::DataSourceHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::DataSourceHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::DatabaseHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::DatabaseHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::DatabaseHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::DatabaseHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::DictionaryHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::DictionaryHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::DictionaryHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::DictionaryHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::ODABAClient* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::ODABAClient* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::ODABAClient* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::ODABAClient* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::OperationHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::OperationHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::OperationHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::OperationHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::PropertyHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::PropertyHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::PropertyHandle* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::PropertyHandle* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::OPIFactory* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::OPIFactory* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::OPIFactory* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::OPIFactory* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::Session* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::Session* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::Session* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::Session* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::OPI::SessionFactory* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::OPI::SessionFactory* p)
{
    p->__decRef();
}

void
IceInternal::incRef(::IceProxy::OPI::SessionFactory* p)
{
    p->__incRef();
}

void
IceInternal::decRef(::IceProxy::OPI::SessionFactory* p)
{
    p->__decRef();
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::CheckOptionsPrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::CheckOptionsPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::CheckOptions;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::CheckOptionsPtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DBObjectHandlePrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::DBObjectHandlePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::DBObjectHandle;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DBObjectHandlePtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DataSourceHandlePrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::DataSourceHandlePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::DataSourceHandle;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DataSourceHandlePtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DatabaseHandlePrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::DatabaseHandlePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::DatabaseHandle;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DatabaseHandlePtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DictionaryHandlePrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::DictionaryHandlePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::DictionaryHandle;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::DictionaryHandlePtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::ODABAClientPrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::ODABAClientPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::ODABAClient;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::ODABAClientPtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::OperationHandlePrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::OperationHandlePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::OperationHandle;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::OperationHandlePtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::PropertyHandlePrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::PropertyHandlePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::PropertyHandle;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::PropertyHandlePtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::OPIFactoryPrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::OPIFactoryPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::OPIFactory;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::OPIFactoryPtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::SessionPrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::SessionPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::Session;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::SessionPtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::SessionFactoryPrx& v)
{
    __os->write(::Ice::ObjectPrx(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::SessionFactoryPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
	v = 0;
    }
    else
    {
	v = new ::IceProxy::OPI::SessionFactory;
	v->__copyFrom(proxy);
    }
}

void
OPI::__write(::IceInternal::BasicStream* __os, const ::OPI::SessionFactoryPtr& v)
{
    __os->write(::Ice::ObjectPtr(v));
}

void
OPI::__write(::IceInternal::BasicStream* __os, ::OPI::PIACC v)
{
    __os->write(static_cast< ::Ice::Byte>(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::PIACC& v)
{
    ::Ice::Byte val;
    __is->read(val);
    v = static_cast< ::OPI::PIACC>(val);
}

void
OPI::__write(::IceInternal::BasicStream* __os, ::OPI::PIREPL v)
{
    __os->write(static_cast< ::Ice::Byte>(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::PIREPL& v)
{
    ::Ice::Byte val;
    __is->read(val);
    v = static_cast< ::OPI::PIREPL>(val);
}

void
OPI::__write(::IceInternal::BasicStream* __os, ::OPI::PIADEF v)
{
    __os->write(static_cast< ::Ice::Byte>(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::PIADEF& v)
{
    ::Ice::Byte val;
    __is->read(val);
    v = static_cast< ::OPI::PIADEF>(val);
}

void
OPI::__write(::IceInternal::BasicStream* __os, ::OPI::ResourceTypes v)
{
    __os->write(static_cast< ::Ice::Byte>(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::ResourceTypes& v)
{
    ::Ice::Byte val;
    __is->read(val);
    v = static_cast< ::OPI::ResourceTypes>(val);
}

void
OPI::__write(::IceInternal::BasicStream* __os, ::OPI::ApplicationTypes v)
{
    __os->write(static_cast< ::Ice::Byte>(v));
}

void
OPI::__read(::IceInternal::BasicStream* __is, ::OPI::ApplicationTypes& v)
{
    ::Ice::Byte val;
    __is->read(val);
    v = static_cast< ::OPI::ApplicationTypes>(val);
}

void
OPI::__addObject(const CheckOptionsPtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const CheckOptionsPtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(CheckOptionsPtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(CheckOptionsPtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const DBObjectHandlePtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const DBObjectHandlePtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(DBObjectHandlePtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(DBObjectHandlePtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const DataSourceHandlePtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const DataSourceHandlePtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(DataSourceHandlePtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(DataSourceHandlePtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const DatabaseHandlePtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const DatabaseHandlePtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(DatabaseHandlePtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(DatabaseHandlePtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const DictionaryHandlePtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const DictionaryHandlePtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(DictionaryHandlePtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(DictionaryHandlePtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const ODABAClientPtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const ODABAClientPtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(ODABAClientPtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(ODABAClientPtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const OperationHandlePtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const OperationHandlePtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(OperationHandlePtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(OperationHandlePtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const PropertyHandlePtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const PropertyHandlePtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(PropertyHandlePtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(PropertyHandlePtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const OPIFactoryPtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const OPIFactoryPtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(OPIFactoryPtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(OPIFactoryPtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const SessionPtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const SessionPtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(SessionPtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(SessionPtr& p)
{
    p.__clearHandleUnsafe();
}

void
OPI::__addObject(const SessionFactoryPtr& p, ::IceInternal::GCCountMap& c)
{
    p->__addObject(c);
}

bool
OPI::__usesClasses(const SessionFactoryPtr& p)
{
    return p->__usesClasses();
}

void
OPI::__decRefUnsafe(SessionFactoryPtr& p)
{
    p->__decRefUnsafe();
}

void
OPI::__clearHandleUnsafe(SessionFactoryPtr& p)
{
    p.__clearHandleUnsafe();
}

bool
IceProxy::OPI::CheckOptions::Initialize(const ::std::string& parmstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__CheckOptions__Initialize_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::CheckOptions* __del = dynamic_cast< ::IceDelegate::OPI::CheckOptions*>(__delBase.get());
	    return __del->Initialize(parmstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::CheckOptions::ice_staticId()
{
    return ::OPI::CheckOptions::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::CheckOptions::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::CheckOptions);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::CheckOptions::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::CheckOptions);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::CheckOptions& l, const ::IceProxy::OPI::CheckOptions& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::CheckOptions& l, const ::IceProxy::OPI::CheckOptions& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::CheckOptions& l, const ::IceProxy::OPI::CheckOptions& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::CheckOptions& l, const ::IceProxy::OPI::CheckOptions& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::CheckOptions& l, const ::IceProxy::OPI::CheckOptions& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::CheckOptions& l, const ::IceProxy::OPI::CheckOptions& r)
{
    return !(l < r);
}

::Ice::Int
IceProxy::OPI::DBObjectHandle::BeginTransaction(bool extTA, ::Ice::Int wmaxnum, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__BeginTransaction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->BeginTransaction(extTA, wmaxnum, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::ChangeTimeStamp(::Ice::Int versionnr, ::Ice::Long timestamp, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__ChangeTimeStamp_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->ChangeTimeStamp(versionnr, timestamp, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::CommitTransaction(::Ice::Int talevel, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__CommitTransaction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->CommitTransaction(talevel, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::DBObjectHandle::CreateTempPropertyHandle(const ::OPI::PropertyHandlePrx& prophdlref, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__CreateTempPropertyHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->CreateTempPropertyHandle(prophdlref, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::DeleteExtent(const ::std::string& extnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__DeleteExtent_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->DeleteExtent(extnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::DeleteExtentRef(const ::std::string& extnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__DeleteExtentRef_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->DeleteExtentRef(extnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::DBObjectHandle::DisableEventHandling(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    __del->DisableEventHandling(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::DBObjectHandle::EnableEventHandling(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    __del->EnableEventHandling(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::EventHandling(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__EventHandling_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->EventHandling(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::ExecuteDBObjectAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__ExecuteDBObjectAction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->ExecuteDBObjectAction(actionname, parmstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::DBObjectHandle::ExecuteExpression(const ::OPI::DBObjectHandlePrx& resobhandle, const ::std::string& expression, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__ExecuteExpression_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->ExecuteExpression(resobhandle, expression, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::ExtentExist(const ::std::string& extnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__ExtentExist_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->ExtentExist(extnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PIACC
IceProxy::OPI::DBObjectHandle::GetAccess(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetAccess_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetAccess(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DBObjectHandle::GetActionResult(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetActionResult_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetActionResult(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DatabaseHandlePrx
IceProxy::OPI::DBObjectHandle::GetDBHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetDBHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetDBHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DataSourceHandlePrx
IceProxy::OPI::DBObjectHandle::GetDataSource(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetDataSource_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetDataSource(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DictionaryHandlePrx
IceProxy::OPI::DBObjectHandle::GetDictionary(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetDictionary_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetDictionary(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DBObjectHandle::GetExtent(::Ice::Int indx0, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetExtent_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetExtent(indx0, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DBObjectHandlePrx
IceProxy::OPI::DBObjectHandle::GetHighObject(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetHighObject_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetHighObject(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DBObjectHandle::GetObject(::Ice::Int indx0, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetObject_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetObject(indx0, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DBObjectHandle::GetServerVariable(const ::std::string& varname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetServerVariable_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetServerVariable(varname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DBObjectHandle::GetSystemVersion(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetSystemVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetSystemVersion(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Long
IceProxy::OPI::DBObjectHandle::GetTimeStamp(::Ice::Int versionnr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetTimeStamp_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetTimeStamp(versionnr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DBObjectHandle::GetTransactionLevel(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetTransactionLevel_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetTransactionLevel(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DBObjectHandle::GetVersion(::Ice::Long timestamp, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__GetVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->GetVersion(timestamp, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::IsClient(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__IsClient_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->IsClient(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::IsEmpty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__IsEmpty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->IsEmpty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::IsOpened(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__IsOpened_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->IsOpened(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::IsServer(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__IsServer_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->IsServer(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::IsValid(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__IsValid_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->IsValid(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::NewVersion(::Ice::Long timestamp, ::Ice::Int versionnr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__NewVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->NewVersion(timestamp, versionnr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::OpenObject(const ::OPI::DBObjectHandlePrx& dbobject, const ::std::string& objname, ::OPI::PIACC accopt, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__OpenObject_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->OpenObject(dbobject, objname, accopt, versionnr, localressources, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::RollBack(::Ice::Int talevel, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__RollBack_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->RollBack(talevel, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::DBObjectHandle::SetActionResult(const ::std::string& resultstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    __del->SetActionResult(resultstring, __ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DBObjectHandle::SetOverload(bool overloadopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__SetOverload_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->SetOverload(overloadopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::SetServerVariable(const ::std::string& varname, const ::std::string& varstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__SetServerVariable_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->SetServerVariable(varname, varstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::SetUserDefinedIdentity(bool identityopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__SetUserDefinedIdentity_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->SetUserDefinedIdentity(identityopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::SetVersion(::Ice::Int versionnr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__SetVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->SetVersion(versionnr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::SetVersioni1(::Ice::Long date, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__SetVersioni1_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->SetVersioni1(date, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DBObjectHandle::SetVersioni2(::Ice::Long timestamp, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__SetVersioni2_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->SetVersioni2(timestamp, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DBObjectHandle::VersionCount(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DBObjectHandle__VersionCount_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DBObjectHandle* __del = dynamic_cast< ::IceDelegate::OPI::DBObjectHandle*>(__delBase.get());
	    return __del->VersionCount(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::DBObjectHandle::ice_staticId()
{
    return ::OPI::DBObjectHandle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::DBObjectHandle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::DBObjectHandle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::DBObjectHandle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::DBObjectHandle);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::DBObjectHandle& l, const ::IceProxy::OPI::DBObjectHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::DBObjectHandle& l, const ::IceProxy::OPI::DBObjectHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::DBObjectHandle& l, const ::IceProxy::OPI::DBObjectHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::DBObjectHandle& l, const ::IceProxy::OPI::DBObjectHandle& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::DBObjectHandle& l, const ::IceProxy::OPI::DBObjectHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::DBObjectHandle& l, const ::IceProxy::OPI::DBObjectHandle& r)
{
    return !(l < r);
}

bool
IceProxy::OPI::DataSourceHandle::BeginTransaction(bool extta, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__BeginTransaction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->BeginTransaction(extta, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Close(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Close_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Close(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::CloseDBObject(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__CloseDBObject_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->CloseDBObject(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::CloseDatabase(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__CloseDatabase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->CloseDatabase(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::CloseDictionary(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__CloseDictionary_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->CloseDictionary(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::CloseProperty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__CloseProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->CloseProperty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::CloseResourceDB(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__CloseResourceDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->CloseResourceDB(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::CommitTransaction(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__CommitTransaction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->CommitTransaction(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Connect(const ::OPI::ODABAClientPrx& podabaclient, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Connect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Connect(podabaclient, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Disconnect(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Disconnect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Disconnect(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Open(const ::OPI::ODABAClientPrx& podabaclient, ::OPI::PIACC accmod, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Open_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Open(podabaclient, accmod, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Openi02(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& inifile, const ::std::string& datasourcename, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Openi02_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Openi02(podabaclient, inifile, datasourcename, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Openi1(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& datasourcename, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Openi1_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Openi1(podabaclient, datasourcename, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DBObjectHandlePrx
IceProxy::OPI::DataSourceHandle::OpenDBObject(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__OpenDBObject_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->OpenDBObject(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DatabaseHandlePrx
IceProxy::OPI::DataSourceHandle::OpenDatabase(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__OpenDatabase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->OpenDatabase(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DictionaryHandlePrx
IceProxy::OPI::DataSourceHandle::OpenDictionary(::OPI::PIACC accopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__OpenDictionary_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->OpenDictionary(accopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::DataSourceHandle::OpenProperty(const ::std::string& extname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__OpenProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->OpenProperty(extname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DatabaseHandlePrx
IceProxy::OPI::DataSourceHandle::OpenResourceDB(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__OpenResourceDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->OpenResourceDB(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::RollBack(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__RollBack_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->RollBack(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetDBObject(const ::OPI::DBObjectHandlePrx& ohandle, const ::std::string& wobjname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetDBObject_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetDBObject(ohandle, wobjname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetDataSource(const ::OPI::DataSourceHandlePrx& dbdefptr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetDataSource_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetDataSource(dbdefptr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetDatabase(const ::OPI::DatabaseHandlePrx& dbhandle, const ::std::string& wbasepath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetDatabase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetDatabase(dbhandle, wbasepath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetDictionary(const ::OPI::DictionaryHandlePrx& dictptr, const ::std::string& wdictpath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetDictionary_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetDictionary(dictptr, wdictpath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetResourceDB(const ::OPI::DatabaseHandlePrx& dbhandle, const ::std::string& wbasepath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetResourceDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetResourceDB(dbhandle, wbasepath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetVariables(const ::std::string& datasourcename, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetVariables_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetVariables(datasourcename, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::Setup(const ::std::string& inifile, const ::std::string& datasourcename, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__Setup_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->Setup(inifile, datasourcename, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DataSourceHandle::SetupVariables(const ::std::string& datasourcename, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DataSourceHandle__SetupVariables_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DataSourceHandle* __del = dynamic_cast< ::IceDelegate::OPI::DataSourceHandle*>(__delBase.get());
	    return __del->SetupVariables(datasourcename, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::DataSourceHandle::ice_staticId()
{
    return ::OPI::DataSourceHandle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::DataSourceHandle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::DataSourceHandle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::DataSourceHandle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::DataSourceHandle);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::DataSourceHandle& l, const ::IceProxy::OPI::DataSourceHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::DataSourceHandle& l, const ::IceProxy::OPI::DataSourceHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::DataSourceHandle& l, const ::IceProxy::OPI::DataSourceHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::DataSourceHandle& l, const ::IceProxy::OPI::DataSourceHandle& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::DataSourceHandle& l, const ::IceProxy::OPI::DataSourceHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::DataSourceHandle& l, const ::IceProxy::OPI::DataSourceHandle& r)
{
    return !(l < r);
}

bool
IceProxy::OPI::DatabaseHandle::ActivateShadowBase(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__ActivateShadowBase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->ActivateShadowBase(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::BackupDB(const ::std::string& target, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__BackupDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->BackupDB(target, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::CheckDB(const ::OPI::CheckOptionsPrx& checkopts, const ::std::string& source, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__CheckDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->CheckDB(checkopts, source, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::CheckLicence(const ::std::string& licowner, const ::std::string& licnumber, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__CheckLicence_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->CheckLicence(licowner, licnumber, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::CloseWorkspace(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__CloseWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->CloseWorkspace(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::ConsolidateWorkspace(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__ConsolidateWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->ConsolidateWorkspace(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::DeactivateShadowBase(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__DeactivateShadowBase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->DeactivateShadowBase(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::DeleteWorkspace(const ::std::string& wsnames, const ::std::string& username, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__DeleteWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->DeleteWorkspace(wsnames, username, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::DisableWorkspace(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__DisableWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->DisableWorkspace(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::DiscardWorkspace(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__DiscardWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->DiscardWorkspace(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::EnableWorkspace(const ::std::string& sdwpath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__EnableWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->EnableWorkspace(sdwpath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::ExecuteDatabaseAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__ExecuteDatabaseAction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->ExecuteDatabaseAction(actionname, parmstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::ExistWorkspace(const ::std::string& wsnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__ExistWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->ExistWorkspace(wsnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DatabaseHandle::GetDatabaseID(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__GetDatabaseID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->GetDatabaseID(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DatabaseHandle::GetPath(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__GetPath_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->GetPath(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DatabaseHandle::GetSchemaVersion(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__GetSchemaVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->GetSchemaVersion(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DatabaseHandle::GetVersionString(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__GetVersionString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->GetVersionString(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DatabaseHandle::GetWorkspace(const ::std::string& wsroot, ::Ice::Int wsindex, const ::std::string& username, const ::std::string& wsname, bool refreshopt, const ::std::string& wsinfo, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__GetWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->GetWorkspace(wsroot, wsindex, username, wsname, refreshopt, wsinfo, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::IgnoreWriteProtect(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__IgnoreWriteProtect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->IgnoreWriteProtect(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::InitDataArea(::Ice::Int mbnumber, ::Ice::Int sbnumber, ::Ice::Int danumber, const ::std::string& filename, ::Ice::Int dasize, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__InitDataArea_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->InitDataArea(mbnumber, sbnumber, danumber, filename, dasize, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::InitMainBase(::Ice::Int mbnumber, const ::std::string& filename, ::Ice::Int lowEBN, ::Ice::Int highEBN, ::Ice::Int dasize, bool largedb, bool pindep, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__InitMainBase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->InitMainBase(mbnumber, filename, lowEBN, highEBN, dasize, largedb, pindep, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::InitSubBase(::Ice::Int mbnumber, ::Ice::Int sbnumber, const ::std::string& filename, ::Ice::Int dasize, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__InitSubBase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->InitSubBase(mbnumber, sbnumber, filename, dasize, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::IsLicenced(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__IsLicenced_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->IsLicenced(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::IsShared(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__IsShared_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->IsShared(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::LocateWorkspace(const ::std::string& wsnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__LocateWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->LocateWorkspace(wsnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::OpenDatabase(const ::OPI::DictionaryHandlePrx& dicthandle, const ::std::string& cpath, ::OPI::PIACC accopt, bool wnetopt, bool onlineversion, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, bool sysenv, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__OpenDatabase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->OpenDatabase(dicthandle, cpath, accopt, wnetopt, onlineversion, versionnr, localressources, sysenv, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::OpenWorkspace(const ::std::string& wsnames, const ::std::string& username, bool exclusive, const ::std::string& wspath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__OpenWorkspace_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->OpenWorkspace(wsnames, username, exclusive, wspath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::RecreateExtent(const ::std::string& extnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__RecreateExtent_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->RecreateExtent(extnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::RestoreDB(const ::std::string& source, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__RestoreDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->RestoreDB(source, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DatabaseHandle::SetupTypeID(::Ice::Int sid, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DatabaseHandle__SetupTypeID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DatabaseHandle* __del = dynamic_cast< ::IceDelegate::OPI::DatabaseHandle*>(__delBase.get());
	    return __del->SetupTypeID(sid, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::DatabaseHandle::ice_staticId()
{
    return ::OPI::DatabaseHandle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::DatabaseHandle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::DatabaseHandle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::DatabaseHandle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::DatabaseHandle);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::DatabaseHandle& l, const ::IceProxy::OPI::DatabaseHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::DatabaseHandle& l, const ::IceProxy::OPI::DatabaseHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::DatabaseHandle& l, const ::IceProxy::OPI::DatabaseHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::DatabaseHandle& l, const ::IceProxy::OPI::DatabaseHandle& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::DatabaseHandle& l, const ::IceProxy::OPI::DatabaseHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::DatabaseHandle& l, const ::IceProxy::OPI::DatabaseHandle& r)
{
    return !(l < r);
}

::Ice::Int
IceProxy::OPI::DictionaryHandle::BaseType(const ::std::string& strnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__BaseType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->BaseType(strnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CheckExpression(const ::std::string& expression, const ::OPI::DBObjectHandlePrx& dbobjhandle, const ::std::string& clsnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CheckExpression_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CheckExpression(expression, dbobjhandle, clsnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CheckExpressionInClass(const ::OPI::DBObjectHandlePrx& resobj, const ::std::string& clsnames, const ::std::string& exprnames, const ::std::string& implnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CheckExpressionInClass_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CheckExpressionInClass(resobj, clsnames, exprnames, implnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CheckExtentDef(const ::std::string& scopedname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CheckExtentDef_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CheckExtentDef(scopedname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CheckValueSet(const ::std::string& scopedname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CheckValueSet_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CheckValueSet(scopedname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CopyCodeset(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strname, ::Ice::Int namespaceid, const ::std::string& newnames, ::OPI::PIREPL dbreplace, bool retainSID, bool retainschemav, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CopyCodeset_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CopyCodeset(srcedicthandle, strname, namespaceid, newnames, dbreplace, retainSID, retainschemav, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CopyExtentDef(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& extentname, const ::std::string& newnames, const ::std::string& targstruct, bool transaction, bool retainschemav, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CopyExtentDef_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CopyExtentDef(srcedicthandle, extentname, newnames, targstruct, transaction, retainschemav, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CopyStructure(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strname, ::Ice::Int namespaceid, const ::std::string& newnames, const ::std::string& topname, ::OPI::PIREPL dbreplace, bool retainSID, bool retainschemav, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CopyStructure_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CopyStructure(srcedicthandle, strname, namespaceid, newnames, topname, dbreplace, retainSID, retainschemav, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CopyType(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strnames, const ::std::string& newnames, const ::std::string& topname, ::OPI::PIREPL dbreplace, bool retainSID, bool transaction, bool retainschemav, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CopyType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CopyType(srcedicthandle, strnames, newnames, topname, dbreplace, retainSID, transaction, retainschemav, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::CreateEnum(const ::std::string& enumname, const ::std::string& basetype, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CreateEnum_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CreateEnum(enumname, basetype, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DictionaryHandle::CreateTempExtent(const ::std::string& strnames, const ::std::string& extnamesw, const ::std::string& keynamew, const ::std::string& baseextsw, bool weakoptw, bool ownoptw, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__CreateTempExtent_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->CreateTempExtent(strnames, extnamesw, keynamew, baseextsw, weakoptw, ownoptw, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::DeleteEnum(const ::std::string& enumname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__DeleteEnum_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->DeleteEnum(enumname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DictionaryHandle::EnumToString(const ::std::string& enumeration, ::Ice::Int enumval, const ::std::string& pstring, ::Ice::Int len, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__EnumToString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->EnumToString(enumeration, enumval, pstring, len, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DictionaryHandle::GetLastSchemaVersion(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__GetLastSchemaVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->GetLastSchemaVersion(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::DictionaryHandle::GetTempName(const ::std::string& extnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__GetTempName_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->GetTempName(extnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::IsBasicType(const ::std::string& typenames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__IsBasicType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->IsBasicType(typenames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::OpenDictionary(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& cpath, ::OPI::PIACC accopt, bool wnetopt, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, bool sysenv, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__OpenDictionary_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->OpenDictionary(podabaclient, cpath, accopt, wnetopt, versionnr, localressources, sysenv, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::DictionaryHandle::StringToEnum(const ::std::string& enumeration, const ::std::string& enumstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__StringToEnum_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->StringToEnum(enumeration, enumstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::DictionaryHandle::UpdateVersion(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__DictionaryHandle__UpdateVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::DictionaryHandle* __del = dynamic_cast< ::IceDelegate::OPI::DictionaryHandle*>(__delBase.get());
	    return __del->UpdateVersion(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::DictionaryHandle::ice_staticId()
{
    return ::OPI::DictionaryHandle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::DictionaryHandle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::DictionaryHandle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::DictionaryHandle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::DictionaryHandle);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::DictionaryHandle& l, const ::IceProxy::OPI::DictionaryHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::DictionaryHandle& l, const ::IceProxy::OPI::DictionaryHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::DictionaryHandle& l, const ::IceProxy::OPI::DictionaryHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::DictionaryHandle& l, const ::IceProxy::OPI::DictionaryHandle& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::DictionaryHandle& l, const ::IceProxy::OPI::DictionaryHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::DictionaryHandle& l, const ::IceProxy::OPI::DictionaryHandle& r)
{
    return !(l < r);
}

void
IceProxy::OPI::ODABAClient::ActivateGUIMessages(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    __del->ActivateGUIMessages(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::BackupDB(const ::std::string& cpath, const ::std::string& target, ::Ice::Int waitsec, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__BackupDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->BackupDB(cpath, target, waitsec, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::CheckDB(const ::std::string& dictpath, const ::std::string& cpath, const ::OPI::CheckOptionsPrx& checkopts, const ::std::string& source, ::Ice::Int waitsec, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__CheckDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->CheckDB(dictpath, cpath, checkopts, source, waitsec, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::Close(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__Close_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->Close(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::Connect(const ::std::string& servername, ::Ice::Int hostport, const ::std::string& cachestring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__Connect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->Connect(servername, hostport, cachestring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::DictDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__DictDisplay_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->DictDisplay(dbpath, ppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::ODABAClient::Disconnect(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    __del->Disconnect(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::Exist(const ::std::string& cpath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__Exist_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->Exist(cpath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::ODABAClient::GetDataSource(::Ice::Int indx0, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__GetDataSource_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->GetDataSource(indx0, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::ODABAClient::GetHost(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__GetHost_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->GetHost(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::ODABAClient::GetPort(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__GetPort_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->GetPort(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::ODABAClient::GetServerVariable(const ::std::string& varname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__GetServerVariable_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->GetServerVariable(varname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::ODABAClient::Initialize(const ::std::string& inipath, const ::std::string& applicationname, const ::std::string& progpath, ::OPI::ApplicationTypes applicationtype, bool initservices, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    __del->Initialize(inipath, applicationname, progpath, applicationtype, initservices, __ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::IsConnected(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__IsConnected_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->IsConnected(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::KillClient(::Ice::Int clientid, ::Ice::Int waitsec, bool sendmessage, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__KillClient_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->KillClient(clientid, waitsec, sendmessage, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::Open(const ::std::string& inipath, const ::std::string& applicationname, const ::std::string& progpath, ::OPI::ApplicationTypes applicationtype, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__Open_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->Open(inipath, applicationname, progpath, applicationtype, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DBObjectHandlePrx
IceProxy::OPI::ODABAClient::OpenDataSource(const ::std::string& datasourcename, ::OPI::PIACC accopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__OpenDataSource_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->OpenDataSource(datasourcename, accopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::PackDatabase(const ::std::string& cpath, const ::std::string& temppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__PackDatabase_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->PackDatabase(cpath, temppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::RestoreDB(const ::std::string& cpath, const ::std::string& source, ::Ice::Int waitsec, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__RestoreDB_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->RestoreDB(cpath, source, waitsec, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::SendClientMessage(::Ice::Int clientid, const ::std::string& mtext, const ::std::string& mtitle, const ::std::string& mtype, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__SendClientMessage_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->SendClientMessage(clientid, mtext, mtitle, mtype, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::SetServerVariable(const ::std::string& varname, const ::std::string& varstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__SetServerVariable_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->SetServerVariable(varname, varstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::ShutDown(const ::std::string& closesystem, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__ShutDown_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->ShutDown(closesystem, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::StartPause(::Ice::Int waitsec, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__StartPause_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->StartPause(waitsec, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::StatDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__StatDisplay_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->StatDisplay(dbpath, ppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::ODABAClient::StopPause(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    __del->StopPause(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::ODABAClient::SysInfoDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__ODABAClient__SysInfoDisplay_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::ODABAClient* __del = dynamic_cast< ::IceDelegate::OPI::ODABAClient*>(__delBase.get());
	    return __del->SysInfoDisplay(dbpath, ppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::ODABAClient::ice_staticId()
{
    return ::OPI::ODABAClient::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::ODABAClient::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::ODABAClient);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::ODABAClient::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::ODABAClient);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::ODABAClient& l, const ::IceProxy::OPI::ODABAClient& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::ODABAClient& l, const ::IceProxy::OPI::ODABAClient& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::ODABAClient& l, const ::IceProxy::OPI::ODABAClient& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::ODABAClient& l, const ::IceProxy::OPI::ODABAClient& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::ODABAClient& l, const ::IceProxy::OPI::ODABAClient& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::ODABAClient& l, const ::IceProxy::OPI::ODABAClient& r)
{
    return !(l < r);
}

bool
IceProxy::OPI::OperationHandle::CheckExpression(const ::OPI::DictionaryHandlePrx& dictptr, const ::std::string& expression, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& clsnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__CheckExpression_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->CheckExpression(dictptr, expression, obhandle, clsnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::OperationHandle::CheckExpressionInClass(const ::OPI::DictionaryHandlePrx& dictptr, const ::OPI::DBObjectHandlePrx& resobj, const ::std::string& clsnames, const ::std::string& exprnames, const ::std::string& impnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__CheckExpressionInClass_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->CheckExpressionInClass(dictptr, resobj, clsnames, exprnames, impnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::OperationHandle::Execute(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__Execute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->Execute(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::OperationHandle::GetResult(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__GetResult_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->GetResult(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::OperationHandle::GetSize(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__GetSize_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->GetSize(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::OperationHandle::IsValid(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__IsValid_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->IsValid(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::OperationHandle::Open(const ::OPI::PropertyHandlePrx& prophdlref, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__Open_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->Open(prophdlref, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::OperationHandle::ProvideExpression(const ::OPI::DictionaryHandlePrx& pdictionary, const ::OPI::DBObjectHandlePrx& resobj, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& expression, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OperationHandle__ProvideExpression_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OperationHandle* __del = dynamic_cast< ::IceDelegate::OPI::OperationHandle*>(__delBase.get());
	    return __del->ProvideExpression(pdictionary, resobj, obhandle, expression, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::OperationHandle::ice_staticId()
{
    return ::OPI::OperationHandle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::OperationHandle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::OperationHandle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::OperationHandle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::OperationHandle);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::OperationHandle& l, const ::IceProxy::OPI::OperationHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::OperationHandle& l, const ::IceProxy::OPI::OperationHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::OperationHandle& l, const ::IceProxy::OPI::OperationHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::OperationHandle& l, const ::IceProxy::OPI::OperationHandle& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::OperationHandle& l, const ::IceProxy::OPI::OperationHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::OperationHandle& l, const ::IceProxy::OPI::OperationHandle& r)
{
    return !(l < r);
}

bool
IceProxy::OPI::PropertyHandle::Add(::Ice::Int setpos0, const ::std::string& sortkey, const ::std::string& identkeyw, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Add_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Add(setpos0, sortkey, identkeyw, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddByKey(const ::std::string& sortkey, const ::std::string& identkeyw, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddByKey(sortkey, identkeyw, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddInstance(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddInstance_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddInstance(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddOnPosition(::Ice::Int setpos0w, bool initinst, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddOnPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddOnPosition(setpos0w, initinst, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddGlobal(::Ice::Int setpos0, const ::std::string& sortkey, const ::std::string& identkeyw, bool initinst, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddGlobal_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddGlobal(setpos0, sortkey, identkeyw, initinst, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddGlobalByKey(const ::std::string& sortkey, const ::std::string& identkeyw, bool initinst, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddGlobalByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddGlobalByKey(sortkey, identkeyw, initinst, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddGlobalOnPosition(::Ice::Int setpos0w, bool initinst, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddGlobalOnPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddGlobalOnPosition(setpos0w, initinst, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AddReference(const ::OPI::PropertyHandlePrx& sourcehandle, ::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AddReference_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AddReference(sourcehandle, setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AllocDescription(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AllocDescription_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AllocDescription(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AllocateArea(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AllocateArea_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AllocateArea(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AppendString(const ::std::string& pstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AppendString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AppendString(pstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::AutoLocate(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__AutoLocate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->AutoLocate(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Cancel(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Cancel_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Cancel(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CancelBuffer(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CancelBuffer_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CancelBuffer(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::ChangeBuffer(::Ice::Int buffnum, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ChangeBuffer_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ChangeBuffer(buffnum, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ChangeCache(::Ice::Int buffnum, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ChangeCache_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ChangeCache(buffnum, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PIACC
IceProxy::OPI::PropertyHandle::ChangeMode(::OPI::PIACC newmode, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ChangeMode_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ChangeMode(newmode, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Check(bool iniopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Check_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Check(iniopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CheckPosition(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CheckPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CheckPosition(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CheckUpdate(bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CheckUpdate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CheckUpdate(pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CheckWProtect(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CheckWProtect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CheckWProtect(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Close(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Close_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Close(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::Compare(const ::OPI::PropertyHandlePrx& cprophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Compare_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Compare(cprophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareDate(::Ice::Long dateval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareDate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareDate(dateval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareFloat(::Ice::Float doubleval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareFloat_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareFloat(doubleval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareInteger(::Ice::Int longval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareInteger_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareInteger(longval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareString(const ::std::string& pstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareString(pstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareTime(::Ice::Long timeval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareTime_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareTime(timeval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareKey(const ::std::string& identkey1, const ::std::string& identkey2, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareKey(identkey1, identkey2, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CompareSortKey(const ::std::string& sortkey1, const ::std::string& sortkey2, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareSortKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareSortKey(sortkey1, sortkey2, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CompareType(const ::OPI::PropertyHandlePrx& prophdl, bool convert, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CompareType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CompareType(prophdl, convert, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Copy(const ::OPI::PropertyHandlePrx& sourcehandle, const ::std::string& newkey, ::Ice::Int setpos0, ::OPI::PIREPL replopt, ::OPI::PIREPL copytype, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Copy_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Copy(sourcehandle, newkey, setpos0, replopt, copytype, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CopyData(const ::OPI::PropertyHandlePrx& sourcehandle, ::OPI::PIREPL replopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CopyData_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CopyData(sourcehandle, replopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CopyHandle(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CopyHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CopyHandle(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CopyInstanceArea(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CopyInstanceArea_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CopyInstanceArea(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::CopySet(const ::OPI::PropertyHandlePrx& csourcehandle, ::OPI::PIREPL replopt, ::OPI::PIREPL copytype, bool inversecheck, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CopySet_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CopySet(csourcehandle, replopt, copytype, inversecheck, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::CreateTempExtent(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& extnamesw, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__CreateTempExtent_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->CreateTempExtent(prophdlref, extnamesw, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Delete(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Delete_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Delete(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::DeleteByKey(const ::std::string& sortkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__DeleteByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->DeleteByKey(sortkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::DeleteOnPosition(::Ice::Int setpos0w, bool deldep, bool delinst, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__DeleteOnPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->DeleteOnPosition(setpos0w, deldep, delinst, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::DeleteIndexEntry(::Ice::Int setpos0, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__DeleteIndexEntry_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->DeleteIndexEntry(setpos0, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::DeleteSet(bool deldep, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__DeleteSet_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->DeleteSet(deldep, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::DisableKeyCheck(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__DisableKeyCheck_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->DisableKeyCheck(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Duplicate(::Ice::Int setpos0, ::OPI::PIREPL replopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Duplicate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Duplicate(setpos0, replopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::DuplicateKey(const ::std::string& identkey, ::OPI::PIREPL replopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__DuplicateKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->DuplicateKey(identkey, replopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::EnableKeyCheck(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__EnableKeyCheck_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->EnableKeyCheck(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Execute(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Execute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Execute(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::ExecuteExpression(const ::OPI::DBObjectHandlePrx& resobhandle, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& expression, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ExecuteExpression_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ExecuteExpression(resobhandle, obhandle, expression, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ExecuteInstanceAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ExecuteInstanceAction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ExecuteInstanceAction(actionname, parmstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ExecutePropertyAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ExecutePropertyAction_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ExecutePropertyAction(actionname, parmstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Exist(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Exist_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Exist(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::ExtractKey(const ::std::string& keyname, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ExtractKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ExtractKey(keyname, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::ExtractSortKey(const ::std::string& sortkeyw, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ExtractSortKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ExtractSortKey(sortkeyw, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::FirstKey(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__FirstKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->FirstKey(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Get(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Get_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Get(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::GetAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetAtPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetAtPosition(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::GetByKey(const ::std::string& sortkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetByKey(sortkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetActionResult(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetActionResult_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetActionResult(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetArea(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetArea_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetArea(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetAttribute(::Ice::Int indx0, bool fullpath, bool generic, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetAttribute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetAttribute(indx0, fullpath, generic, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::GetBaseProperty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetBaseProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetBaseProperty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetCollectionID(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetCollectionID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetCollectionID(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::GetCollectionProperty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetCollectionProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetCollectionProperty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetCount(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetCount_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetCount(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetCurrentIndex(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetCurrentIndex_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetCurrentIndex(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetCurrentSize(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetCurrentSize_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetCurrentSize(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetCurrentType(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetCurrentType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetCurrentType(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DatabaseHandlePrx
IceProxy::OPI::PropertyHandle::GetDBHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDBHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDBHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Long
IceProxy::OPI::PropertyHandle::GetDate(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDate(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Long
IceProxy::OPI::PropertyHandle::GetDateTime(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDateTime_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDateTime(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetDay(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDay_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDay(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DictionaryHandlePrx
IceProxy::OPI::PropertyHandle::GetDictionary(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDictionary_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDictionary(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetDimension(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDimension_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDimension(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Float
IceProxy::OPI::PropertyHandle::GetDouble(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetDouble_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetDouble(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetExtInstModCount(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetExtInstModCount_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetExtInstModCount(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetExtentName(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetExtentName_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetExtentName(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetGUID(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetGUID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetGUID(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetGenAttrType(const ::std::string& wpropnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetGenAttrType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetGenAttrType(wpropnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetGenOrderType(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetGenOrderType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetGenOrderType(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetGlobalID(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetGlobalID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetGlobalID(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetHours(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetHours_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetHours(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetID(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetID(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetIdentity(const ::std::string& idstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetIdentity_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetIdentity(idstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetIndexName(::Ice::Int indx0, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetIndexName_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetIndexName(indx0, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::GetInitInstance(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetInitInstance_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetInitInstance(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetInstModCount(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetInstModCount_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetInstModCount(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetInt(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetInt_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetInt(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetIntValue(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetIntValue_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetIntValue(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetKey(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetKey(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetKeyLength(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetKeyLength_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetKeyLength(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetLOID(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetLOID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetLOID(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetLOIDByKey(const ::std::string& sortkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetLOIDByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetLOIDByKey(sortkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetMinutes(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetMinutes_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetMinutes(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PIACC
IceProxy::OPI::PropertyHandle::GetMode(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetMode_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetMode(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetMonth(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetMonth_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetMonth(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetNormalized(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetNormalized_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetNormalized(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DBObjectHandlePrx
IceProxy::OPI::PropertyHandle::GetObjectHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetObjectHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetObjectHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetOrigin(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetOrigin_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetOrigin(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::GetParentProperty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetParentProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetParentProperty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::GetPropertyHandle(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetPropertyHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetPropertyHandle(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetPropertyPath(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetPropertyPath_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetPropertyPath(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetRefModCount(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetRefModCount_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetRefModCount(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetReference(::Ice::Int indx0, bool fullpath, bool generic, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetReference_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetReference(indx0, fullpath, generic, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::GetRelative(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetRelative_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetRelative(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetRelativeCount(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetRelativeCount_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetRelativeCount(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetRelativeIndex(bool lastopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetRelativeIndex_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetRelativeIndex(lastopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetSeconds(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSeconds_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSeconds(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetSelectedKey(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSelectedKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSelectedKey(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetSize(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSize_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSize(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetSizeOf(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSizeOf_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSizeOf(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetSortKey(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSortKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSortKey(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetSortKeyLength(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSortKeyLength_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSortKeyLength(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetString(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetString(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetStringLength(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetStringLength_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetStringLength(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetStringValue(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetStringValue_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetStringValue(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetSubString(::Ice::Int startpos, ::Ice::Int length, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetSubString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetSubString(startpos, length, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetText(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetText_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetText(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Long
IceProxy::OPI::PropertyHandle::GetTime(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetTime_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetTime(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::GetType(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetType(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::GetValid(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetValid_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetValid(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetVersion(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetVersion(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::GetYear(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__GetYear_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->GetYear(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::Group(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& groupingrule, bool distinct, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Group_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Group(prophdlref, groupingrule, distinct, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::HasData(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__HasData_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->HasData(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::HasDescription(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__HasDescription_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->HasDescription(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::HasGenericAttributes(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__HasGenericAttributes_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->HasGenericAttributes(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::HasIndex(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__HasIndex_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->HasIndex(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Inherits(const ::std::string& strnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Inherits_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Inherits(strnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::InsertString(const ::std::string& pstring, ::Ice::Int position, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__InsertString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->InsertString(pstring, position, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::InsertTerminator(const ::std::string& pstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__InsertTerminator_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->InsertTerminator(pstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::InstanceInserted(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__InstanceInserted_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->InstanceInserted(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::InstanceToString(const ::std::string& stringsep, const ::std::string& fieldsep, const ::std::string& blocksep, const ::std::string& emptystring, bool skiptrans, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__InstanceToString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->InstanceToString(stringsep, fieldsep, blocksep, emptystring, skiptrans, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::Intersect(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Intersect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Intersect(prophdl1, prophdl2, skopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Is(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Is_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Is(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsA(const ::std::string& strnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsA_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsA(strnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsActive(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsActive_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsActive(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsAttribute(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsAttribute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsAttribute(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsAutoSelection(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsAutoSelection_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsAutoSelection(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsBasedOn(const ::std::string& strnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsBasedOn_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsBasedOn(strnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsBasetypeProperty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsBasetypeProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsBasetypeProperty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsBasicType(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsBasicType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsBasicType(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsClient(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsClient_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsClient(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsCollection(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsCollection_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsCollection(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsCollectionUpdate(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsCollectionUpdate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsCollectionUpdate(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsCopyHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsCopyHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsCopyHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsDirty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsDirty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsDirty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsEmpty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsEmpty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsEmpty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsEnumeration(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsEnumeration_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsEnumeration(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsGenericAttribute(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsGenericAttribute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsGenericAttribute(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsInitInstance(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsInitInstance_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsInitInstance(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsMemo(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsMemo_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsMemo(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsModified(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsModified_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsModified(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsNewInstance(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsNewInstance_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsNewInstance(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsNumeric(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsNumeric_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsNumeric(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsOldInstance(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsOldInstance_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsOldInstance(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsOwner(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsOwner_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsOwner(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsPositioned(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsPositioned_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsPositioned(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsReadOnly(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsReadOnly_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsReadOnly(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsSelected(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsSelected_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsSelected(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsSensitive(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsSensitive_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsSensitive(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsServer(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsServer_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsServer(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsShareBaseHandle(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsShareBaseHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsShareBaseHandle(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsStructure(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsStructure_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsStructure(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsText(const ::std::string& chkopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsText_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsText(chkopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsTransient(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsTransient_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsTransient(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsTrue(const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsTrue_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsTrue(proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsTyped(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsTyped_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsTyped(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsUserHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsUserHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsUserHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsValid(bool topt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsValid_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsValid(topt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsValidText(const ::std::string& pstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsValidText_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsValidText(pstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsVariableType(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsVariableType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsVariableType(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsWeakTyped(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsWeakTyped_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsWeakTyped(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::IsWrite(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__IsWrite_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->IsWrite(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Locate(::Ice::Int obident, bool readopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Locate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Locate(obident, readopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::LocatePath(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__LocatePath_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->LocatePath(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Lock(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Lock_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Lock(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::LockSet(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__LockSet_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->LockSet(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::PropertyHandle::MarkUnused(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    __del->MarkUnused(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::PropertyHandle::MarkUsed(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    __del->MarkUsed(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::Minus(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Minus_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Minus(prophdl1, prophdl2, skopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Modify(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Modify_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Modify(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Move(const ::OPI::PropertyHandlePrx& sourcehandle, const ::std::string& newkey, ::OPI::PIREPL replopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Move_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Move(sourcehandle, newkey, replopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::MoveDown(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__MoveDown_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->MoveDown(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::MoveUp(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__MoveUp_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->MoveUp(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::NextKey(const ::std::string& sortkeyw, ::Ice::Int switchlevel, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__NextKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->NextKey(sortkeyw, switchlevel, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::NoWrite(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__NoWrite_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->NoWrite(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Open(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Open_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Open(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenBigInt(::Ice::Int int64val, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenBigInt_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenBigInt(int64val, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenBoolean(bool logval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenBoolean_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenBoolean(logval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenChild(const ::OPI::PropertyHandlePrx& prophdl, const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenChild_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenChild(prophdl, proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenChildReference(const ::OPI::PropertyHandlePrx& ppropertyhandle, const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenChildReference_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenChildReference(ppropertyhandle, proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenCopy(const ::OPI::PropertyHandlePrx& cprophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenCopy_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenCopy(cprophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenDate(::Ice::Long dateval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenDate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenDate(dateval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenExtent(const ::OPI::DBObjectHandlePrx& objecthandle, const ::std::string& extnames, ::OPI::PIACC accopt, bool transientw, const ::std::string& keynamew, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenExtent_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenExtent(objecthandle, extnames, accopt, transientw, keynamew, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenFloat(::Ice::Float dblvalue, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenFloat_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenFloat(dblvalue, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenInteger(::Ice::Int intval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenInteger_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenInteger(intval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenReference(const ::OPI::PropertyHandlePrx& ppropertyhandle, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenReference_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenReference(ppropertyhandle, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenSizedString(const ::std::string& pstring, ::Ice::Int stringlen, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenSizedString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenSizedString(pstring, stringlen, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenString(const ::std::string& pstring, bool convopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenString(pstring, convopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenTime(::Ice::Long timeval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenTime_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenTime(timeval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenTimestamp(::Ice::Long datetimeval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenTimestamp_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenTimestamp(datetimeval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OpenHierarchy(const ::OPI::PropertyHandlePrx& bottomph, const ::OPI::PropertyHandlePrx& topph, bool pathopt, ::OPI::PIACC accmode, bool copyselection, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OpenHierarchy_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OpenHierarchy(bottomph, topph, pathopt, accmode, copyselection, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::OwnsData(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__OwnsData_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->OwnsData(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Position(::Ice::Int count, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Position_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Position(count, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::PositionTop(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__PositionTop_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->PositionTop(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::Power(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Power_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Power(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvGenAttribute(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvGenAttribute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvGenAttribute(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Provide(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Provide_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Provide(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvideAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideAtPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideAtPosition(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvideByKey(const ::std::string& sortkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideByKey(sortkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvideArea(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideArea_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideArea(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::PropertyHandle::ProvideGUID(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideGUID_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideGUID(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvideGlobal(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideGlobal_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideGlobal(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvideGlobalAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideGlobalAtPosition_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideGlobalAtPosition(setpos0w, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ProvideGlobalByKey(const ::std::string& sortkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideGlobalByKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideGlobalByKey(sortkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::OperationHandlePrx
IceProxy::OPI::PropertyHandle::ProvideOperation(const ::std::string& expression, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ProvideOperation_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ProvideOperation(expression, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Refresh(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Refresh_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Refresh(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ReleaseBuffer(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ReleaseBuffer_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ReleaseBuffer(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::RemoveFromCollection(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__RemoveFromCollection_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->RemoveFromCollection(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::RemoveString(const ::std::string& pstring, ::Ice::Int position, ::Ice::Int len, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__RemoveString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->RemoveString(pstring, position, len, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::RemoveTerminator(const ::std::string& pstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__RemoveTerminator_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->RemoveTerminator(pstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Rename(const ::std::string& newkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Rename_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Rename(newkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::RepairIndex(const ::std::string& keynamew, const ::std::string& attrstrw, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__RepairIndex_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->RepairIndex(keynamew, attrstrw, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ReplaceString(const ::std::string& oldstr, const ::std::string& newstr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ReplaceString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ReplaceString(oldstr, newstr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ReplaceSysVariables(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ReplaceSysVariables_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ReplaceSysVariables(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Reset(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Reset_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Reset(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::PropertyHandle::ResetDirty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    __del->ResetDirty(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ResetTransientProperty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ResetTransientProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ResetTransientProperty(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ResetWProtect(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ResetWProtect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ResetWProtect(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Save(const ::std::string& savopt, bool switchopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Save_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Save(savopt, switchopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::Ice::Int
IceProxy::OPI::PropertyHandle::SearchText(const ::std::string& pstring, ::Ice::Int curpos, bool caseopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SearchText_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SearchText(pstring, curpos, caseopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::Select(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& expression, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Select_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Select(prophdlref, expression, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::PropertyHandle::SetActionResult(const ::std::string& resultstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    __del->SetActionResult(resultstring, __ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetContextVariables(const ::std::string& contextstring, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetContextVariables_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetContextVariables(contextstring, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::PropertyHandle::SetDirty(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    __del->SetDirty(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetDynLength(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetDynLength_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetDynLength(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetGenAttribute(const ::std::string& attrstr, const ::std::string& proppath, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetGenAttribute_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetGenAttribute(attrstr, proppath, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetKey(const ::std::string& identkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetKey(identkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::PropertyHandle::SetModified(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    __del->SetModified(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetNormalized(::Ice::Int longval, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetNormalized_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetNormalized(longval, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetOrder(const ::std::string& keyname, const ::std::string& attrstr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetOrder_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetOrder(keyname, attrstr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetSelection(const ::std::string& expression, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetSelection_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetSelection(expression, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetSortKey(const ::std::string& sortkey, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetSortKey_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetSortKey(sortkey, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetTransientProperty(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetTransientProperty_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetTransientProperty(prophdl, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetType(const ::std::string& strnames, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetType_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetType(strnames, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetUpdate(bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetUpdate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetUpdate(pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValue(const ::OPI::PropertyHandlePrx& cprophdl, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValue_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValue(cprophdl, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueBigInt(::Ice::Int int64val, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueBigInt_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueBigInt(int64val, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueBoolean(bool logval, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueBoolean_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueBoolean(logval, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueDate(::Ice::Long dateval, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueDate_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueDate(dateval, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueFloat(::Ice::Float dblvalue, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueFloat_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueFloat(dblvalue, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueInteger(::Ice::Int longval, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueInteger_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueInteger(longval, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueString(const ::std::string& pstring, bool pcheckupdate, bool convopt, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueString_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueString(pstring, pcheckupdate, convopt, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueTime(::Ice::Long timeval, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueTime_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueTime(timeval, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::SetValueTimestamp(::Ice::Long datetimeval, bool pcheckupdate, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetValueTimestamp_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetValueTimestamp(datetimeval, pcheckupdate, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetVersion(::Ice::Int versionnr, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetVersion_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetVersion(versionnr, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::SetWProtect(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__SetWProtect_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->SetWProtect(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::ToTop(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__ToTop_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->ToTop(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::PropertyHandle::Union(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, bool distinct, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Union_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Union(prophdl1, prophdl2, skopt, distinct, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::Unlock(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__Unlock_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->Unlock(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

bool
IceProxy::OPI::PropertyHandle::UnlockSet(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__PropertyHandle__UnlockSet_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::PropertyHandle* __del = dynamic_cast< ::IceDelegate::OPI::PropertyHandle*>(__delBase.get());
	    return __del->UnlockSet(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::PropertyHandle::ice_staticId()
{
    return ::OPI::PropertyHandle::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::PropertyHandle::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::PropertyHandle);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::PropertyHandle::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::PropertyHandle);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::PropertyHandle& l, const ::IceProxy::OPI::PropertyHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::PropertyHandle& l, const ::IceProxy::OPI::PropertyHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::PropertyHandle& l, const ::IceProxy::OPI::PropertyHandle& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::PropertyHandle& l, const ::IceProxy::OPI::PropertyHandle& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::PropertyHandle& l, const ::IceProxy::OPI::PropertyHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::PropertyHandle& l, const ::IceProxy::OPI::PropertyHandle& r)
{
    return !(l < r);
}

void
IceProxy::OPI::OPIFactory::Destroy(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    __del->Destroy(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::CheckOptionsPrx
IceProxy::OPI::OPIFactory::GetCheckOptions(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetCheckOptions_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetCheckOptions(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DBObjectHandlePrx
IceProxy::OPI::OPIFactory::GetDBObjectHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetDBObjectHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetDBObjectHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DataSourceHandlePrx
IceProxy::OPI::OPIFactory::GetDataSourceHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetDataSourceHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetDataSourceHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DatabaseHandlePrx
IceProxy::OPI::OPIFactory::GetDatabaseHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetDatabaseHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetDatabaseHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::DictionaryHandlePrx
IceProxy::OPI::OPIFactory::GetDictionaryHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetDictionaryHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetDictionaryHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::ODABAClientPrx
IceProxy::OPI::OPIFactory::GetODABAClient(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetODABAClient_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetODABAClient(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::OperationHandlePrx
IceProxy::OPI::OPIFactory::GetOperationHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetOperationHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetOperationHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::OPI::PropertyHandlePrx
IceProxy::OPI::OPIFactory::GetPropertyHandle(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__OPIFactory__GetPropertyHandle_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::OPIFactory* __del = dynamic_cast< ::IceDelegate::OPI::OPIFactory*>(__delBase.get());
	    return __del->GetPropertyHandle(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::OPIFactory::ice_staticId()
{
    return ::OPI::OPIFactory::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::OPIFactory::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::OPIFactory);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::OPIFactory::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::OPIFactory);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::OPIFactory& l, const ::IceProxy::OPI::OPIFactory& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::OPIFactory& l, const ::IceProxy::OPI::OPIFactory& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::OPIFactory& l, const ::IceProxy::OPI::OPIFactory& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::OPIFactory& l, const ::IceProxy::OPI::OPIFactory& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::OPIFactory& l, const ::IceProxy::OPI::OPIFactory& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::OPIFactory& l, const ::IceProxy::OPI::OPIFactory& r)
{
    return !(l < r);
}

::OPI::OPIFactoryPrx
IceProxy::OPI::Session::CreateSession(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__Session__CreateSession_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::Session* __del = dynamic_cast< ::IceDelegate::OPI::Session*>(__delBase.get());
	    return __del->CreateSession(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::Session::Destroy(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::Session* __del = dynamic_cast< ::IceDelegate::OPI::Session*>(__delBase.get());
	    __del->Destroy(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::Session::TimeOut(::Ice::Int seconds, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::Session* __del = dynamic_cast< ::IceDelegate::OPI::Session*>(__delBase.get());
	    __del->TimeOut(seconds, __ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

::std::string
IceProxy::OPI::Session::getName(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__Session__getName_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::Session* __del = dynamic_cast< ::IceDelegate::OPI::Session*>(__delBase.get());
	    return __del->getName(__ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::Session::ice_staticId()
{
    return ::OPI::Session::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::Session::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::Session);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::Session::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::Session);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::Session& l, const ::IceProxy::OPI::Session& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::Session& l, const ::IceProxy::OPI::Session& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::Session& l, const ::IceProxy::OPI::Session& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::Session& l, const ::IceProxy::OPI::Session& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::Session& l, const ::IceProxy::OPI::Session& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::Session& l, const ::IceProxy::OPI::Session& r)
{
    return !(l < r);
}

::OPI::SessionPrx
IceProxy::OPI::SessionFactory::CreateProxy(const ::std::string& name, const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    __checkTwowayOnly(__OPI__SessionFactory__CreateProxy_name);
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::SessionFactory* __del = dynamic_cast< ::IceDelegate::OPI::SessionFactory*>(__delBase.get());
	    return __del->CreateProxy(name, __ctx);
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

void
IceProxy::OPI::SessionFactory::shutdown(const ::Ice::Context& __ctx)
{
    int __cnt = 0;
    while(true)
    {
	try
	{
	    ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase = __getDelegate();
	    ::IceDelegate::OPI::SessionFactory* __del = dynamic_cast< ::IceDelegate::OPI::SessionFactory*>(__delBase.get());
	    __del->shutdown(__ctx);
	    return;
	}
	catch(const ::IceInternal::LocalExceptionWrapper& __ex)
	{
	    __handleExceptionWrapper(__ex);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    __handleException(__ex, __cnt);
	}
    }
}

const ::std::string&
IceProxy::OPI::SessionFactory::ice_staticId()
{
    return ::OPI::SessionFactory::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OPI::SessionFactory::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OPI::SessionFactory);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OPI::SessionFactory::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OPI::SessionFactory);
}

bool
IceProxy::OPI::operator==(const ::IceProxy::OPI::SessionFactory& l, const ::IceProxy::OPI::SessionFactory& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) == static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator!=(const ::IceProxy::OPI::SessionFactory& l, const ::IceProxy::OPI::SessionFactory& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) != static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<(const ::IceProxy::OPI::SessionFactory& l, const ::IceProxy::OPI::SessionFactory& r)
{
    return static_cast<const ::IceProxy::Ice::Object&>(l) < static_cast<const ::IceProxy::Ice::Object&>(r);
}

bool
IceProxy::OPI::operator<=(const ::IceProxy::OPI::SessionFactory& l, const ::IceProxy::OPI::SessionFactory& r)
{
    return l < r || l == r;
}

bool
IceProxy::OPI::operator>(const ::IceProxy::OPI::SessionFactory& l, const ::IceProxy::OPI::SessionFactory& r)
{
    return !(l < r) && !(l == r);
}

bool
IceProxy::OPI::operator>=(const ::IceProxy::OPI::SessionFactory& l, const ::IceProxy::OPI::SessionFactory& r)
{
    return !(l < r);
}

bool
IceDelegateM::OPI::CheckOptions::Initialize(const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__CheckOptions__Initialize_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(parmstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DBObjectHandle::BeginTransaction(bool extTA, ::Ice::Int wmaxnum, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__BeginTransaction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extTA);
	__os->write(wmaxnum);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::ChangeTimeStamp(::Ice::Int versionnr, ::Ice::Long timestamp, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__ChangeTimeStamp_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(versionnr);
	__os->write(timestamp);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::CommitTransaction(::Ice::Int talevel, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__CommitTransaction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(talevel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::DBObjectHandle::CreateTempPropertyHandle(const ::OPI::PropertyHandlePrx& prophdlref, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__CreateTempPropertyHandle_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdlref);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::DeleteExtent(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__DeleteExtent_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::DeleteExtentRef(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__DeleteExtentRef_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::DBObjectHandle::DisableEventHandling(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__DisableEventHandling_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::DBObjectHandle::EnableEventHandling(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__EnableEventHandling_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::EventHandling(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__EventHandling_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::ExecuteDBObjectAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__ExecuteDBObjectAction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(actionname);
	__os->write(parmstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::DBObjectHandle::ExecuteExpression(const ::OPI::DBObjectHandlePrx& resobhandle, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__ExecuteExpression_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, resobhandle);
	__os->write(expression);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::ExtentExist(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__ExtentExist_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PIACC
IceDelegateM::OPI::DBObjectHandle::GetAccess(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetAccess_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PIACC __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DBObjectHandle::GetActionResult(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetActionResult_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DatabaseHandlePrx
IceDelegateM::OPI::DBObjectHandle::GetDBHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetDBHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DatabaseHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DataSourceHandlePrx
IceDelegateM::OPI::DBObjectHandle::GetDataSource(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetDataSource_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DataSourceHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DictionaryHandlePrx
IceDelegateM::OPI::DBObjectHandle::GetDictionary(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetDictionary_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DictionaryHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DBObjectHandle::GetExtent(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetExtent_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(indx0);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DBObjectHandlePrx
IceDelegateM::OPI::DBObjectHandle::GetHighObject(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetHighObject_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DBObjectHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DBObjectHandle::GetObject(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetObject_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(indx0);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DBObjectHandle::GetServerVariable(const ::std::string& varname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetServerVariable_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(varname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DBObjectHandle::GetSystemVersion(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetSystemVersion_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Long
IceDelegateM::OPI::DBObjectHandle::GetTimeStamp(::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetTimeStamp_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(versionnr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Long __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DBObjectHandle::GetTransactionLevel(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetTransactionLevel_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DBObjectHandle::GetVersion(::Ice::Long timestamp, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__GetVersion_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(timestamp);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::IsClient(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__IsClient_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::IsEmpty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__IsEmpty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::IsOpened(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__IsOpened_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::IsServer(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__IsServer_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::IsValid(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__IsValid_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::NewVersion(::Ice::Long timestamp, ::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__NewVersion_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(timestamp);
	__os->write(versionnr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::OpenObject(const ::OPI::DBObjectHandlePrx& dbobject, const ::std::string& objname, ::OPI::PIACC accopt, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__OpenObject_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dbobject);
	__os->write(objname);
	::OPI::__write(__os, accopt);
	__os->write(versionnr);
	::OPI::__write(__os, localressources);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::RollBack(::Ice::Int talevel, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__RollBack_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(talevel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::DBObjectHandle::SetActionResult(const ::std::string& resultstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetActionResult_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(resultstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DBObjectHandle::SetOverload(bool overloadopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetOverload_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(overloadopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::SetServerVariable(const ::std::string& varname, const ::std::string& varstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetServerVariable_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(varname);
	__os->write(varstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::SetUserDefinedIdentity(bool identityopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetUserDefinedIdentity_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(identityopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::SetVersion(::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetVersion_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(versionnr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::SetVersioni1(::Ice::Long date, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetVersioni1_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(date);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DBObjectHandle::SetVersioni2(::Ice::Long timestamp, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__SetVersioni2_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(timestamp);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DBObjectHandle::VersionCount(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DBObjectHandle__VersionCount_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::BeginTransaction(bool extta, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__BeginTransaction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extta);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Close(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Close_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::CloseDBObject(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__CloseDBObject_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::CloseDatabase(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__CloseDatabase_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::CloseDictionary(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__CloseDictionary_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::CloseProperty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__CloseProperty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::CloseResourceDB(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__CloseResourceDB_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::CommitTransaction(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__CommitTransaction_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Connect(const ::OPI::ODABAClientPrx& podabaclient, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Connect_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, podabaclient);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Disconnect(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Disconnect_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Open(const ::OPI::ODABAClientPrx& podabaclient, ::OPI::PIACC accmod, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Open_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, podabaclient);
	::OPI::__write(__os, accmod);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Openi02(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& inifile, const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Openi02_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, podabaclient);
	__os->write(inifile);
	__os->write(datasourcename);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Openi1(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Openi1_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, podabaclient);
	__os->write(datasourcename);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DBObjectHandlePrx
IceDelegateM::OPI::DataSourceHandle::OpenDBObject(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__OpenDBObject_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DBObjectHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DatabaseHandlePrx
IceDelegateM::OPI::DataSourceHandle::OpenDatabase(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__OpenDatabase_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DatabaseHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DictionaryHandlePrx
IceDelegateM::OPI::DataSourceHandle::OpenDictionary(::OPI::PIACC accopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__OpenDictionary_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, accopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DictionaryHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::DataSourceHandle::OpenProperty(const ::std::string& extname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__OpenProperty_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DatabaseHandlePrx
IceDelegateM::OPI::DataSourceHandle::OpenResourceDB(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__OpenResourceDB_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DatabaseHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::RollBack(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__RollBack_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetDBObject(const ::OPI::DBObjectHandlePrx& ohandle, const ::std::string& wobjname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetDBObject_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, ohandle);
	__os->write(wobjname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetDataSource(const ::OPI::DataSourceHandlePrx& dbdefptr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetDataSource_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dbdefptr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetDatabase(const ::OPI::DatabaseHandlePrx& dbhandle, const ::std::string& wbasepath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetDatabase_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dbhandle);
	__os->write(wbasepath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetDictionary(const ::OPI::DictionaryHandlePrx& dictptr, const ::std::string& wdictpath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetDictionary_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dictptr);
	__os->write(wdictpath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetResourceDB(const ::OPI::DatabaseHandlePrx& dbhandle, const ::std::string& wbasepath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetResourceDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dbhandle);
	__os->write(wbasepath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetVariables(const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetVariables_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(datasourcename);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::Setup(const ::std::string& inifile, const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__Setup_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(inifile);
	__os->write(datasourcename);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DataSourceHandle::SetupVariables(const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DataSourceHandle__SetupVariables_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(datasourcename);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::ActivateShadowBase(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__ActivateShadowBase_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::BackupDB(const ::std::string& target, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__BackupDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(target);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::CheckDB(const ::OPI::CheckOptionsPrx& checkopts, const ::std::string& source, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__CheckDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, checkopts);
	__os->write(source);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::CheckLicence(const ::std::string& licowner, const ::std::string& licnumber, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__CheckLicence_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(licowner);
	__os->write(licnumber);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::CloseWorkspace(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__CloseWorkspace_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::ConsolidateWorkspace(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__ConsolidateWorkspace_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::DeactivateShadowBase(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__DeactivateShadowBase_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::DeleteWorkspace(const ::std::string& wsnames, const ::std::string& username, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__DeleteWorkspace_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(wsnames);
	__os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::DisableWorkspace(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__DisableWorkspace_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::DiscardWorkspace(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__DiscardWorkspace_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::EnableWorkspace(const ::std::string& sdwpath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__EnableWorkspace_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sdwpath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::ExecuteDatabaseAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__ExecuteDatabaseAction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(actionname);
	__os->write(parmstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::ExistWorkspace(const ::std::string& wsnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__ExistWorkspace_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(wsnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DatabaseHandle::GetDatabaseID(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__GetDatabaseID_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DatabaseHandle::GetPath(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__GetPath_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DatabaseHandle::GetSchemaVersion(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__GetSchemaVersion_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DatabaseHandle::GetVersionString(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__GetVersionString_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DatabaseHandle::GetWorkspace(const ::std::string& wsroot, ::Ice::Int wsindex, const ::std::string& username, const ::std::string& wsname, bool refreshopt, const ::std::string& wsinfo, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__GetWorkspace_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(wsroot);
	__os->write(wsindex);
	__os->write(username);
	__os->write(wsname);
	__os->write(refreshopt);
	__os->write(wsinfo);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::IgnoreWriteProtect(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__IgnoreWriteProtect_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::InitDataArea(::Ice::Int mbnumber, ::Ice::Int sbnumber, ::Ice::Int danumber, const ::std::string& filename, ::Ice::Int dasize, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__InitDataArea_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(mbnumber);
	__os->write(sbnumber);
	__os->write(danumber);
	__os->write(filename);
	__os->write(dasize);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::InitMainBase(::Ice::Int mbnumber, const ::std::string& filename, ::Ice::Int lowEBN, ::Ice::Int highEBN, ::Ice::Int dasize, bool largedb, bool pindep, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__InitMainBase_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(mbnumber);
	__os->write(filename);
	__os->write(lowEBN);
	__os->write(highEBN);
	__os->write(dasize);
	__os->write(largedb);
	__os->write(pindep);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::InitSubBase(::Ice::Int mbnumber, ::Ice::Int sbnumber, const ::std::string& filename, ::Ice::Int dasize, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__InitSubBase_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(mbnumber);
	__os->write(sbnumber);
	__os->write(filename);
	__os->write(dasize);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::IsLicenced(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__IsLicenced_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::IsShared(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__IsShared_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::LocateWorkspace(const ::std::string& wsnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__LocateWorkspace_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(wsnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::OpenDatabase(const ::OPI::DictionaryHandlePrx& dicthandle, const ::std::string& cpath, ::OPI::PIACC accopt, bool wnetopt, bool onlineversion, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, bool sysenv, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__OpenDatabase_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dicthandle);
	__os->write(cpath);
	::OPI::__write(__os, accopt);
	__os->write(wnetopt);
	__os->write(onlineversion);
	__os->write(versionnr);
	::OPI::__write(__os, localressources);
	__os->write(sysenv);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::OpenWorkspace(const ::std::string& wsnames, const ::std::string& username, bool exclusive, const ::std::string& wspath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__OpenWorkspace_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(wsnames);
	__os->write(username);
	__os->write(exclusive);
	__os->write(wspath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::RecreateExtent(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__RecreateExtent_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::RestoreDB(const ::std::string& source, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__RestoreDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(source);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DatabaseHandle::SetupTypeID(::Ice::Int sid, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DatabaseHandle__SetupTypeID_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sid);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DictionaryHandle::BaseType(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__BaseType_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(strnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CheckExpression(const ::std::string& expression, const ::OPI::DBObjectHandlePrx& dbobjhandle, const ::std::string& clsnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CheckExpression_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(expression);
	::OPI::__write(__os, dbobjhandle);
	__os->write(clsnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CheckExpressionInClass(const ::OPI::DBObjectHandlePrx& resobj, const ::std::string& clsnames, const ::std::string& exprnames, const ::std::string& implnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CheckExpressionInClass_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, resobj);
	__os->write(clsnames);
	__os->write(exprnames);
	__os->write(implnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CheckExtentDef(const ::std::string& scopedname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CheckExtentDef_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(scopedname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CheckValueSet(const ::std::string& scopedname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CheckValueSet_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(scopedname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CopyCodeset(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strname, ::Ice::Int namespaceid, const ::std::string& newnames, ::OPI::PIREPL dbreplace, bool retainSID, bool retainschemav, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CopyCodeset_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, srcedicthandle);
	__os->write(strname);
	__os->write(namespaceid);
	__os->write(newnames);
	::OPI::__write(__os, dbreplace);
	__os->write(retainSID);
	__os->write(retainschemav);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CopyExtentDef(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& extentname, const ::std::string& newnames, const ::std::string& targstruct, bool transaction, bool retainschemav, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CopyExtentDef_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, srcedicthandle);
	__os->write(extentname);
	__os->write(newnames);
	__os->write(targstruct);
	__os->write(transaction);
	__os->write(retainschemav);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CopyStructure(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strname, ::Ice::Int namespaceid, const ::std::string& newnames, const ::std::string& topname, ::OPI::PIREPL dbreplace, bool retainSID, bool retainschemav, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CopyStructure_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, srcedicthandle);
	__os->write(strname);
	__os->write(namespaceid);
	__os->write(newnames);
	__os->write(topname);
	::OPI::__write(__os, dbreplace);
	__os->write(retainSID);
	__os->write(retainschemav);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CopyType(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strnames, const ::std::string& newnames, const ::std::string& topname, ::OPI::PIREPL dbreplace, bool retainSID, bool transaction, bool retainschemav, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CopyType_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, srcedicthandle);
	__os->write(strnames);
	__os->write(newnames);
	__os->write(topname);
	::OPI::__write(__os, dbreplace);
	__os->write(retainSID);
	__os->write(transaction);
	__os->write(retainschemav);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::CreateEnum(const ::std::string& enumname, const ::std::string& basetype, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CreateEnum_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(enumname);
	__os->write(basetype);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DictionaryHandle::CreateTempExtent(const ::std::string& strnames, const ::std::string& extnamesw, const ::std::string& keynamew, const ::std::string& baseextsw, bool weakoptw, bool ownoptw, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__CreateTempExtent_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(strnames);
	__os->write(extnamesw);
	__os->write(keynamew);
	__os->write(baseextsw);
	__os->write(weakoptw);
	__os->write(ownoptw);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::DeleteEnum(const ::std::string& enumname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__DeleteEnum_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(enumname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DictionaryHandle::EnumToString(const ::std::string& enumeration, ::Ice::Int enumval, const ::std::string& pstring, ::Ice::Int len, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__EnumToString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(enumeration);
	__os->write(enumval);
	__os->write(pstring);
	__os->write(len);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DictionaryHandle::GetLastSchemaVersion(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__GetLastSchemaVersion_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::DictionaryHandle::GetTempName(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__GetTempName_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(extnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::IsBasicType(const ::std::string& typenames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__IsBasicType_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(typenames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::OpenDictionary(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& cpath, ::OPI::PIACC accopt, bool wnetopt, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, bool sysenv, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__OpenDictionary_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, podabaclient);
	__os->write(cpath);
	::OPI::__write(__os, accopt);
	__os->write(wnetopt);
	__os->write(versionnr);
	::OPI::__write(__os, localressources);
	__os->write(sysenv);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::DictionaryHandle::StringToEnum(const ::std::string& enumeration, const ::std::string& enumstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__StringToEnum_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(enumeration);
	__os->write(enumstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::DictionaryHandle::UpdateVersion(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__DictionaryHandle__UpdateVersion_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::ODABAClient::ActivateGUIMessages(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__ActivateGUIMessages_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::BackupDB(const ::std::string& cpath, const ::std::string& target, ::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__BackupDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(cpath);
	__os->write(target);
	__os->write(waitsec);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::CheckDB(const ::std::string& dictpath, const ::std::string& cpath, const ::OPI::CheckOptionsPrx& checkopts, const ::std::string& source, ::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__CheckDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dictpath);
	__os->write(cpath);
	::OPI::__write(__os, checkopts);
	__os->write(source);
	__os->write(waitsec);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::Close(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__Close_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::Connect(const ::std::string& servername, ::Ice::Int hostport, const ::std::string& cachestring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__Connect_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(servername);
	__os->write(hostport);
	__os->write(cachestring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::DictDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__DictDisplay_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dbpath);
	__os->write(ppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::ODABAClient::Disconnect(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__Disconnect_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::Exist(const ::std::string& cpath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__Exist_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(cpath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::ODABAClient::GetDataSource(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__GetDataSource_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(indx0);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::ODABAClient::GetHost(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__GetHost_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::ODABAClient::GetPort(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__GetPort_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::ODABAClient::GetServerVariable(const ::std::string& varname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__GetServerVariable_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(varname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::ODABAClient::Initialize(const ::std::string& inipath, const ::std::string& applicationname, const ::std::string& progpath, ::OPI::ApplicationTypes applicationtype, bool initservices, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__Initialize_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(inipath);
	__os->write(applicationname);
	__os->write(progpath);
	::OPI::__write(__os, applicationtype);
	__os->write(initservices);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::IsConnected(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__IsConnected_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::KillClient(::Ice::Int clientid, ::Ice::Int waitsec, bool sendmessage, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__KillClient_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(clientid);
	__os->write(waitsec);
	__os->write(sendmessage);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::Open(const ::std::string& inipath, const ::std::string& applicationname, const ::std::string& progpath, ::OPI::ApplicationTypes applicationtype, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__Open_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(inipath);
	__os->write(applicationname);
	__os->write(progpath);
	::OPI::__write(__os, applicationtype);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DBObjectHandlePrx
IceDelegateM::OPI::ODABAClient::OpenDataSource(const ::std::string& datasourcename, ::OPI::PIACC accopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__OpenDataSource_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(datasourcename);
	::OPI::__write(__os, accopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DBObjectHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::PackDatabase(const ::std::string& cpath, const ::std::string& temppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__PackDatabase_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(cpath);
	__os->write(temppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::RestoreDB(const ::std::string& cpath, const ::std::string& source, ::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__RestoreDB_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(cpath);
	__os->write(source);
	__os->write(waitsec);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::SendClientMessage(::Ice::Int clientid, const ::std::string& mtext, const ::std::string& mtitle, const ::std::string& mtype, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__SendClientMessage_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(clientid);
	__os->write(mtext);
	__os->write(mtitle);
	__os->write(mtype);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::SetServerVariable(const ::std::string& varname, const ::std::string& varstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__SetServerVariable_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(varname);
	__os->write(varstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::ShutDown(const ::std::string& closesystem, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__ShutDown_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(closesystem);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::StartPause(::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__StartPause_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(waitsec);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::StatDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__StatDisplay_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dbpath);
	__os->write(ppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::ODABAClient::StopPause(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__StopPause_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::ODABAClient::SysInfoDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__ODABAClient__SysInfoDisplay_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dbpath);
	__os->write(ppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::OperationHandle::CheckExpression(const ::OPI::DictionaryHandlePrx& dictptr, const ::std::string& expression, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& clsnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__CheckExpression_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dictptr);
	__os->write(expression);
	::OPI::__write(__os, obhandle);
	__os->write(clsnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::OperationHandle::CheckExpressionInClass(const ::OPI::DictionaryHandlePrx& dictptr, const ::OPI::DBObjectHandlePrx& resobj, const ::std::string& clsnames, const ::std::string& exprnames, const ::std::string& impnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__CheckExpressionInClass_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, dictptr);
	::OPI::__write(__os, resobj);
	__os->write(clsnames);
	__os->write(exprnames);
	__os->write(impnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::OperationHandle::Execute(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__Execute_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::OperationHandle::GetResult(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__GetResult_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::OperationHandle::GetSize(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__GetSize_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::OperationHandle::IsValid(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__IsValid_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::OperationHandle::Open(const ::OPI::PropertyHandlePrx& prophdlref, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__Open_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdlref);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::OperationHandle::ProvideExpression(const ::OPI::DictionaryHandlePrx& pdictionary, const ::OPI::DBObjectHandlePrx& resobj, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OperationHandle__ProvideExpression_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, pdictionary);
	::OPI::__write(__os, resobj);
	::OPI::__write(__os, obhandle);
	__os->write(expression);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Add(::Ice::Int setpos0, const ::std::string& sortkey, const ::std::string& identkeyw, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Add_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0);
	__os->write(sortkey);
	__os->write(identkeyw);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddByKey(const ::std::string& sortkey, const ::std::string& identkeyw, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
	__os->write(identkeyw);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddInstance(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddInstance_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddOnPosition(::Ice::Int setpos0w, bool initinst, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddOnPosition_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
	__os->write(initinst);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddGlobal(::Ice::Int setpos0, const ::std::string& sortkey, const ::std::string& identkeyw, bool initinst, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddGlobal_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0);
	__os->write(sortkey);
	__os->write(identkeyw);
	__os->write(initinst);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddGlobalByKey(const ::std::string& sortkey, const ::std::string& identkeyw, bool initinst, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddGlobalByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
	__os->write(identkeyw);
	__os->write(initinst);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddGlobalOnPosition(::Ice::Int setpos0w, bool initinst, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddGlobalOnPosition_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
	__os->write(initinst);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AddReference(const ::OPI::PropertyHandlePrx& sourcehandle, ::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AddReference_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, sourcehandle);
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AllocDescription(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AllocDescription_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AllocateArea(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AllocateArea_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AppendString(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AppendString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::AutoLocate(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__AutoLocate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Cancel(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Cancel_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CancelBuffer(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CancelBuffer_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::ChangeBuffer(::Ice::Int buffnum, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ChangeBuffer_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(buffnum);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ChangeCache(::Ice::Int buffnum, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ChangeCache_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(buffnum);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PIACC
IceDelegateM::OPI::PropertyHandle::ChangeMode(::OPI::PIACC newmode, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ChangeMode_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, newmode);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PIACC __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Check(bool iniopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Check_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(iniopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CheckPosition(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CheckPosition_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CheckUpdate(bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CheckUpdate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CheckWProtect(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CheckWProtect_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Close(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Close_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::Compare(const ::OPI::PropertyHandlePrx& cprophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Compare_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, cprophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareDate(::Ice::Long dateval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareDate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dateval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareFloat(::Ice::Float doubleval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareFloat_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(doubleval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareInteger(::Ice::Int longval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareInteger_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(longval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareString(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareTime(::Ice::Long timeval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareTime_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(timeval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareKey(const ::std::string& identkey1, const ::std::string& identkey2, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(identkey1);
	__os->write(identkey2);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CompareSortKey(const ::std::string& sortkey1, const ::std::string& sortkey2, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareSortKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey1);
	__os->write(sortkey2);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CompareType(const ::OPI::PropertyHandlePrx& prophdl, bool convert, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CompareType_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
	__os->write(convert);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Copy(const ::OPI::PropertyHandlePrx& sourcehandle, const ::std::string& newkey, ::Ice::Int setpos0, ::OPI::PIREPL replopt, ::OPI::PIREPL copytype, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Copy_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, sourcehandle);
	__os->write(newkey);
	__os->write(setpos0);
	::OPI::__write(__os, replopt);
	::OPI::__write(__os, copytype);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CopyData(const ::OPI::PropertyHandlePrx& sourcehandle, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CopyData_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, sourcehandle);
	::OPI::__write(__os, replopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CopyHandle(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CopyHandle_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CopyInstanceArea(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CopyInstanceArea_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::CopySet(const ::OPI::PropertyHandlePrx& csourcehandle, ::OPI::PIREPL replopt, ::OPI::PIREPL copytype, bool inversecheck, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CopySet_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, csourcehandle);
	::OPI::__write(__os, replopt);
	::OPI::__write(__os, copytype);
	__os->write(inversecheck);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::CreateTempExtent(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& extnamesw, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__CreateTempExtent_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdlref);
	__os->write(extnamesw);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Delete(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Delete_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::DeleteByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__DeleteByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::DeleteOnPosition(::Ice::Int setpos0w, bool deldep, bool delinst, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__DeleteOnPosition_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
	__os->write(deldep);
	__os->write(delinst);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::DeleteIndexEntry(::Ice::Int setpos0, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__DeleteIndexEntry_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::DeleteSet(bool deldep, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__DeleteSet_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(deldep);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::DisableKeyCheck(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__DisableKeyCheck_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Duplicate(::Ice::Int setpos0, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Duplicate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0);
	::OPI::__write(__os, replopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::DuplicateKey(const ::std::string& identkey, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__DuplicateKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(identkey);
	::OPI::__write(__os, replopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::EnableKeyCheck(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__EnableKeyCheck_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Execute(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Execute_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::ExecuteExpression(const ::OPI::DBObjectHandlePrx& resobhandle, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ExecuteExpression_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, resobhandle);
	::OPI::__write(__os, obhandle);
	__os->write(expression);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ExecuteInstanceAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ExecuteInstanceAction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(actionname);
	__os->write(parmstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ExecutePropertyAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ExecutePropertyAction_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(actionname);
	__os->write(parmstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Exist(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Exist_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::ExtractKey(const ::std::string& keyname, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ExtractKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(keyname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::ExtractSortKey(const ::std::string& sortkeyw, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ExtractSortKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkeyw);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::FirstKey(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__FirstKey_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Get(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Get_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::GetAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetAtPosition_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::GetByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetActionResult(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetActionResult_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetArea(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetArea_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetAttribute(::Ice::Int indx0, bool fullpath, bool generic, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetAttribute_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(indx0);
	__os->write(fullpath);
	__os->write(generic);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::GetBaseProperty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetBaseProperty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetCollectionID(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetCollectionID_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::GetCollectionProperty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetCollectionProperty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetCount(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetCount_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetCurrentIndex(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetCurrentIndex_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetCurrentSize(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetCurrentSize_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetCurrentType(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetCurrentType_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DatabaseHandlePrx
IceDelegateM::OPI::PropertyHandle::GetDBHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDBHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DatabaseHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Long
IceDelegateM::OPI::PropertyHandle::GetDate(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Long __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Long
IceDelegateM::OPI::PropertyHandle::GetDateTime(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDateTime_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Long __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetDay(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDay_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DictionaryHandlePrx
IceDelegateM::OPI::PropertyHandle::GetDictionary(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDictionary_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DictionaryHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetDimension(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDimension_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Float
IceDelegateM::OPI::PropertyHandle::GetDouble(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetDouble_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Float __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetExtInstModCount(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetExtInstModCount_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetExtentName(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetExtentName_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetGUID(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetGUID_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetGenAttrType(const ::std::string& wpropnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetGenAttrType_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(wpropnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetGenOrderType(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetGenOrderType_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetGlobalID(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetGlobalID_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetHours(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetHours_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetID(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetID_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetIdentity(const ::std::string& idstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetIdentity_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(idstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetIndexName(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetIndexName_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(indx0);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::GetInitInstance(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetInitInstance_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetInstModCount(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetInstModCount_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetInt(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetInt_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetIntValue(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetIntValue_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetKey(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetKeyLength(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetKeyLength_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetLOID(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetLOID_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetLOIDByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetLOIDByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetMinutes(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetMinutes_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PIACC
IceDelegateM::OPI::PropertyHandle::GetMode(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetMode_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PIACC __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetMonth(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetMonth_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetNormalized(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetNormalized_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DBObjectHandlePrx
IceDelegateM::OPI::PropertyHandle::GetObjectHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetObjectHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DBObjectHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetOrigin(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetOrigin_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::GetParentProperty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetParentProperty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::GetPropertyHandle(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetPropertyHandle_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetPropertyPath(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetPropertyPath_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetRefModCount(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetRefModCount_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetReference(::Ice::Int indx0, bool fullpath, bool generic, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetReference_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(indx0);
	__os->write(fullpath);
	__os->write(generic);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::GetRelative(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetRelative_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetRelativeCount(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetRelativeCount_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetRelativeIndex(bool lastopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetRelativeIndex_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(lastopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetSeconds(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSeconds_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetSelectedKey(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSelectedKey_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetSize(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSize_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetSizeOf(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSizeOf_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetSortKey(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSortKey_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetSortKeyLength(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSortKeyLength_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetString(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetStringLength(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetStringLength_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetStringValue(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetStringValue_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetSubString(::Ice::Int startpos, ::Ice::Int length, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetSubString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(startpos);
	__os->write(length);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetText(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetText_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Long
IceDelegateM::OPI::PropertyHandle::GetTime(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetTime_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Long __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::GetType(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetType_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::GetValid(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetValid_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetVersion(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetVersion_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::GetYear(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__GetYear_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::Group(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& groupingrule, bool distinct, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Group_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdlref);
	__os->write(groupingrule);
	__os->write(distinct);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::HasData(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__HasData_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::HasDescription(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__HasDescription_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::HasGenericAttributes(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__HasGenericAttributes_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::HasIndex(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__HasIndex_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Inherits(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Inherits_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(strnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::InsertString(const ::std::string& pstring, ::Ice::Int position, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__InsertString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
	__os->write(position);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::InsertTerminator(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__InsertTerminator_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::InstanceInserted(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__InstanceInserted_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::InstanceToString(const ::std::string& stringsep, const ::std::string& fieldsep, const ::std::string& blocksep, const ::std::string& emptystring, bool skiptrans, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__InstanceToString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(stringsep);
	__os->write(fieldsep);
	__os->write(blocksep);
	__os->write(emptystring);
	__os->write(skiptrans);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::Intersect(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Intersect_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl1);
	::OPI::__write(__os, prophdl2);
	__os->write(skopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Is(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Is_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsA(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsA_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(strnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsActive(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsActive_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsAttribute(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsAttribute_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsAutoSelection(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsAutoSelection_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsBasedOn(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsBasedOn_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(strnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsBasetypeProperty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsBasetypeProperty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsBasicType(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsBasicType_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsClient(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsClient_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsCollection(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsCollection_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsCollectionUpdate(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsCollectionUpdate_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsCopyHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsCopyHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsDirty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsDirty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsEmpty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsEmpty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsEnumeration(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsEnumeration_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsGenericAttribute(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsGenericAttribute_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsInitInstance(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsInitInstance_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsMemo(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsMemo_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsModified(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsModified_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsNewInstance(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsNewInstance_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsNumeric(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsNumeric_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsOldInstance(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsOldInstance_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsOwner(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsOwner_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsPositioned(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsPositioned_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsReadOnly(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsReadOnly_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsSelected(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsSelected_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsSensitive(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsSensitive_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsServer(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsServer_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsShareBaseHandle(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsShareBaseHandle_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsStructure(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsStructure_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsText(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsText_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(chkopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsTransient(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsTransient_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsTrue(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsTrue_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsTyped(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsTyped_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsUserHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsUserHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsValid(bool topt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsValid_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(topt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsValidText(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsValidText_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsVariableType(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsVariableType_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsWeakTyped(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsWeakTyped_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::IsWrite(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__IsWrite_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Locate(::Ice::Int obident, bool readopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Locate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(obident);
	__os->write(readopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::LocatePath(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__LocatePath_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Lock(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Lock_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::LockSet(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__LockSet_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::PropertyHandle::MarkUnused(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__MarkUnused_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::PropertyHandle::MarkUsed(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__MarkUsed_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::Minus(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Minus_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl1);
	::OPI::__write(__os, prophdl2);
	__os->write(skopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Modify(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Modify_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Move(const ::OPI::PropertyHandlePrx& sourcehandle, const ::std::string& newkey, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Move_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, sourcehandle);
	__os->write(newkey);
	::OPI::__write(__os, replopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::MoveDown(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__MoveDown_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::MoveUp(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__MoveUp_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::NextKey(const ::std::string& sortkeyw, ::Ice::Int switchlevel, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__NextKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkeyw);
	__os->write(switchlevel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::NoWrite(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__NoWrite_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Open(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Open_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenBigInt(::Ice::Int int64val, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenBigInt_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(int64val);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenBoolean(bool logval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenBoolean_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(logval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenChild(const ::OPI::PropertyHandlePrx& prophdl, const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenChild_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenChildReference(const ::OPI::PropertyHandlePrx& ppropertyhandle, const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenChildReference_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, ppropertyhandle);
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenCopy(const ::OPI::PropertyHandlePrx& cprophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenCopy_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, cprophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenDate(::Ice::Long dateval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenDate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dateval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenExtent(const ::OPI::DBObjectHandlePrx& objecthandle, const ::std::string& extnames, ::OPI::PIACC accopt, bool transientw, const ::std::string& keynamew, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenExtent_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, objecthandle);
	__os->write(extnames);
	::OPI::__write(__os, accopt);
	__os->write(transientw);
	__os->write(keynamew);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenFloat(::Ice::Float dblvalue, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenFloat_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dblvalue);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenInteger(::Ice::Int intval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenInteger_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(intval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenReference(const ::OPI::PropertyHandlePrx& ppropertyhandle, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenReference_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, ppropertyhandle);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenSizedString(const ::std::string& pstring, ::Ice::Int stringlen, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenSizedString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
	__os->write(stringlen);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenString(const ::std::string& pstring, bool convopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
	__os->write(convopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenTime(::Ice::Long timeval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenTime_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(timeval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenTimestamp(::Ice::Long datetimeval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenTimestamp_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(datetimeval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OpenHierarchy(const ::OPI::PropertyHandlePrx& bottomph, const ::OPI::PropertyHandlePrx& topph, bool pathopt, ::OPI::PIACC accmode, bool copyselection, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OpenHierarchy_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, bottomph);
	::OPI::__write(__os, topph);
	__os->write(pathopt);
	::OPI::__write(__os, accmode);
	__os->write(copyselection);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::OwnsData(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__OwnsData_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Position(::Ice::Int count, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Position_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(count);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::PositionTop(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__PositionTop_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::Power(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Power_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvGenAttribute(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvGenAttribute_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Provide(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Provide_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvideAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideAtPosition_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvideByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvideArea(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideArea_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::PropertyHandle::ProvideGUID(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideGUID_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvideGlobal(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideGlobal_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvideGlobalAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideGlobalAtPosition_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(setpos0w);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ProvideGlobalByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideGlobalByKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::OperationHandlePrx
IceDelegateM::OPI::PropertyHandle::ProvideOperation(const ::std::string& expression, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ProvideOperation_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(expression);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::OperationHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Refresh(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Refresh_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ReleaseBuffer(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ReleaseBuffer_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::RemoveFromCollection(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__RemoveFromCollection_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::RemoveString(const ::std::string& pstring, ::Ice::Int position, ::Ice::Int len, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__RemoveString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
	__os->write(position);
	__os->write(len);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::RemoveTerminator(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__RemoveTerminator_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Rename(const ::std::string& newkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Rename_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(newkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::RepairIndex(const ::std::string& keynamew, const ::std::string& attrstrw, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__RepairIndex_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(keynamew);
	__os->write(attrstrw);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ReplaceString(const ::std::string& oldstr, const ::std::string& newstr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ReplaceString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(oldstr);
	__os->write(newstr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ReplaceSysVariables(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ReplaceSysVariables_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Reset(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Reset_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::PropertyHandle::ResetDirty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ResetDirty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ResetTransientProperty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ResetTransientProperty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ResetWProtect(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ResetWProtect_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Save(const ::std::string& savopt, bool switchopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Save_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(savopt);
	__os->write(switchopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OPI::PropertyHandle::SearchText(const ::std::string& pstring, ::Ice::Int curpos, bool caseopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SearchText_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
	__os->write(curpos);
	__os->write(caseopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::Ice::Int __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::Select(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Select_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdlref);
	__os->write(expression);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::PropertyHandle::SetActionResult(const ::std::string& resultstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetActionResult_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(resultstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetContextVariables(const ::std::string& contextstring, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetContextVariables_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(contextstring);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::PropertyHandle::SetDirty(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetDirty_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetDynLength(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetDynLength_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetGenAttribute(const ::std::string& attrstr, const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetGenAttribute_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(attrstr);
	__os->write(proppath);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetKey(const ::std::string& identkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(identkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::PropertyHandle::SetModified(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetModified_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetNormalized(::Ice::Int longval, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetNormalized_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(longval);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetOrder(const ::std::string& keyname, const ::std::string& attrstr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetOrder_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(keyname);
	__os->write(attrstr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetSelection(const ::std::string& expression, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetSelection_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(expression);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetSortKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetSortKey_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(sortkey);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetTransientProperty(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetTransientProperty_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetType(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetType_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(strnames);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetUpdate(bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetUpdate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValue(const ::OPI::PropertyHandlePrx& cprophdl, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValue_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, cprophdl);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueBigInt(::Ice::Int int64val, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueBigInt_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(int64val);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueBoolean(bool logval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueBoolean_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(logval);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueDate(::Ice::Long dateval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueDate_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dateval);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueFloat(::Ice::Float dblvalue, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueFloat_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(dblvalue);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueInteger(::Ice::Int longval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueInteger_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(longval);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueString(const ::std::string& pstring, bool pcheckupdate, bool convopt, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueString_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(pstring);
	__os->write(pcheckupdate);
	__os->write(convopt);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueTime(::Ice::Long timeval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueTime_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(timeval);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::SetValueTimestamp(::Ice::Long datetimeval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetValueTimestamp_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(datetimeval);
	__os->write(pcheckupdate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetVersion(::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetVersion_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(versionnr);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::SetWProtect(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__SetWProtect_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::ToTop(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__ToTop_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::PropertyHandle::Union(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, bool distinct, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Union_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	::OPI::__write(__os, prophdl1);
	::OPI::__write(__os, prophdl2);
	__os->write(skopt);
	__os->write(distinct);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::Unlock(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__Unlock_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::OPI::PropertyHandle::UnlockSet(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__PropertyHandle__UnlockSet_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	bool __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::OPIFactory::Destroy(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__Destroy_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::CheckOptionsPrx
IceDelegateM::OPI::OPIFactory::GetCheckOptions(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetCheckOptions_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::CheckOptionsPrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DBObjectHandlePrx
IceDelegateM::OPI::OPIFactory::GetDBObjectHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetDBObjectHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DBObjectHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DataSourceHandlePrx
IceDelegateM::OPI::OPIFactory::GetDataSourceHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetDataSourceHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DataSourceHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DatabaseHandlePrx
IceDelegateM::OPI::OPIFactory::GetDatabaseHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetDatabaseHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DatabaseHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::DictionaryHandlePrx
IceDelegateM::OPI::OPIFactory::GetDictionaryHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetDictionaryHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::DictionaryHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::ODABAClientPrx
IceDelegateM::OPI::OPIFactory::GetODABAClient(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetODABAClient_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::ODABAClientPrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::OperationHandlePrx
IceDelegateM::OPI::OPIFactory::GetOperationHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetOperationHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::OperationHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::PropertyHandlePrx
IceDelegateM::OPI::OPIFactory::GetPropertyHandle(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__OPIFactory__GetPropertyHandle_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::PropertyHandlePrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::OPIFactoryPrx
IceDelegateM::OPI::Session::CreateSession(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__Session__CreateSession_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::OPIFactoryPrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::Session::Destroy(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__Session__Destroy_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::Session::TimeOut(::Ice::Int seconds, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__Session__TimeOut_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(seconds);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::OPI::Session::getName(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__Session__getName_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::std::string __ret;
	__is->read(__ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::OPI::SessionPrx
IceDelegateM::OPI::SessionFactory::CreateProxy(const ::std::string& name, const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__SessionFactory__CreateProxy_name, ::Ice::Normal, __context, __compress);
    try
    {
	::IceInternal::BasicStream* __os = __og.os();
	__os->write(name);
    }
    catch(const ::Ice::LocalException& __ex)
    {
	__og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
	::OPI::SessionPrx __ret;
	::OPI::__read(__is, __ret);
	return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::OPI::SessionFactory::shutdown(const ::Ice::Context& __context)
{
    ::IceInternal::Outgoing __og(__connection.get(), __reference.get(), __OPI__SessionFactory__shutdown_name, ::Ice::Normal, __context, __compress);
    bool __ok = __og.invoke();
    try
    {
	::IceInternal::BasicStream* __is = __og.is();
	if(!__ok)
	{
	    try
	    {
		__is->throwException();
	    }
	    catch(const ::Ice::UserException& __ex)
	    {
		throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
	    }
	}
    }
    catch(const ::Ice::LocalException& __ex)
    {
	throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateD::OPI::CheckOptions::Initialize(const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__CheckOptions__Initialize_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::CheckOptions* __servant = dynamic_cast< ::OPI::CheckOptions*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Initialize(parmstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DBObjectHandle::BeginTransaction(bool extTA, ::Ice::Int wmaxnum, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__BeginTransaction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->BeginTransaction(extTA, wmaxnum, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::ChangeTimeStamp(::Ice::Int versionnr, ::Ice::Long timestamp, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__ChangeTimeStamp_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ChangeTimeStamp(versionnr, timestamp, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::CommitTransaction(::Ice::Int talevel, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__CommitTransaction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CommitTransaction(talevel, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::DBObjectHandle::CreateTempPropertyHandle(const ::OPI::PropertyHandlePrx& prophdlref, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__CreateTempPropertyHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CreateTempPropertyHandle(prophdlref, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::DeleteExtent(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__DeleteExtent_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteExtent(extnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::DeleteExtentRef(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__DeleteExtentRef_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteExtentRef(extnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::DBObjectHandle::DisableEventHandling(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__DisableEventHandling_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->DisableEventHandling(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::DBObjectHandle::EnableEventHandling(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__EnableEventHandling_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->EnableEventHandling(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::EventHandling(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__EventHandling_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->EventHandling(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::ExecuteDBObjectAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__ExecuteDBObjectAction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExecuteDBObjectAction(actionname, parmstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::DBObjectHandle::ExecuteExpression(const ::OPI::DBObjectHandlePrx& resobhandle, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__ExecuteExpression_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExecuteExpression(resobhandle, expression, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::ExtentExist(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__ExtentExist_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExtentExist(extnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PIACC
IceDelegateD::OPI::DBObjectHandle::GetAccess(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetAccess_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetAccess(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DBObjectHandle::GetActionResult(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetActionResult_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetActionResult(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DatabaseHandlePrx
IceDelegateD::OPI::DBObjectHandle::GetDBHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetDBHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDBHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DataSourceHandlePrx
IceDelegateD::OPI::DBObjectHandle::GetDataSource(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetDataSource_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDataSource(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DictionaryHandlePrx
IceDelegateD::OPI::DBObjectHandle::GetDictionary(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetDictionary_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDictionary(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DBObjectHandle::GetExtent(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetExtent_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetExtent(indx0, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DBObjectHandlePrx
IceDelegateD::OPI::DBObjectHandle::GetHighObject(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetHighObject_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetHighObject(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DBObjectHandle::GetObject(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetObject_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetObject(indx0, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DBObjectHandle::GetServerVariable(const ::std::string& varname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetServerVariable_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetServerVariable(varname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DBObjectHandle::GetSystemVersion(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetSystemVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSystemVersion(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Long
IceDelegateD::OPI::DBObjectHandle::GetTimeStamp(::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetTimeStamp_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetTimeStamp(versionnr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DBObjectHandle::GetTransactionLevel(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetTransactionLevel_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetTransactionLevel(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DBObjectHandle::GetVersion(::Ice::Long timestamp, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__GetVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetVersion(timestamp, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::IsClient(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__IsClient_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsClient(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::IsEmpty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__IsEmpty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsEmpty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::IsOpened(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__IsOpened_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsOpened(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::IsServer(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__IsServer_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsServer(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::IsValid(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__IsValid_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsValid(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::NewVersion(::Ice::Long timestamp, ::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__NewVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->NewVersion(timestamp, versionnr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::OpenObject(const ::OPI::DBObjectHandlePrx& dbobject, const ::std::string& objname, ::OPI::PIACC accopt, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__OpenObject_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenObject(dbobject, objname, accopt, versionnr, localressources, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::RollBack(::Ice::Int talevel, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__RollBack_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RollBack(talevel, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::DBObjectHandle::SetActionResult(const ::std::string& resultstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetActionResult_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->SetActionResult(resultstring, __current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DBObjectHandle::SetOverload(bool overloadopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetOverload_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetOverload(overloadopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::SetServerVariable(const ::std::string& varname, const ::std::string& varstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetServerVariable_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetServerVariable(varname, varstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::SetUserDefinedIdentity(bool identityopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetUserDefinedIdentity_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetUserDefinedIdentity(identityopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::SetVersion(::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetVersion(versionnr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::SetVersioni1(::Ice::Long date, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetVersioni1_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetVersioni1(date, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DBObjectHandle::SetVersioni2(::Ice::Long timestamp, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__SetVersioni2_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetVersioni2(timestamp, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DBObjectHandle::VersionCount(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DBObjectHandle__VersionCount_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DBObjectHandle* __servant = dynamic_cast< ::OPI::DBObjectHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->VersionCount(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::BeginTransaction(bool extta, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__BeginTransaction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->BeginTransaction(extta, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Close(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Close_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Close(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::CloseDBObject(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__CloseDBObject_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CloseDBObject(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::CloseDatabase(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__CloseDatabase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CloseDatabase(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::CloseDictionary(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__CloseDictionary_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CloseDictionary(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::CloseProperty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__CloseProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CloseProperty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::CloseResourceDB(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__CloseResourceDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CloseResourceDB(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::CommitTransaction(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__CommitTransaction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CommitTransaction(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Connect(const ::OPI::ODABAClientPrx& podabaclient, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Connect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Connect(podabaclient, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Disconnect(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Disconnect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Disconnect(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Open(const ::OPI::ODABAClientPrx& podabaclient, ::OPI::PIACC accmod, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Open_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Open(podabaclient, accmod, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Openi02(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& inifile, const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Openi02_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Openi02(podabaclient, inifile, datasourcename, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Openi1(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Openi1_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Openi1(podabaclient, datasourcename, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DBObjectHandlePrx
IceDelegateD::OPI::DataSourceHandle::OpenDBObject(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__OpenDBObject_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDBObject(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DatabaseHandlePrx
IceDelegateD::OPI::DataSourceHandle::OpenDatabase(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__OpenDatabase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDatabase(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DictionaryHandlePrx
IceDelegateD::OPI::DataSourceHandle::OpenDictionary(::OPI::PIACC accopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__OpenDictionary_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDictionary(accopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::DataSourceHandle::OpenProperty(const ::std::string& extname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__OpenProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenProperty(extname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DatabaseHandlePrx
IceDelegateD::OPI::DataSourceHandle::OpenResourceDB(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__OpenResourceDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenResourceDB(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::RollBack(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__RollBack_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RollBack(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetDBObject(const ::OPI::DBObjectHandlePrx& ohandle, const ::std::string& wobjname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetDBObject_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetDBObject(ohandle, wobjname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetDataSource(const ::OPI::DataSourceHandlePrx& dbdefptr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetDataSource_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetDataSource(dbdefptr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetDatabase(const ::OPI::DatabaseHandlePrx& dbhandle, const ::std::string& wbasepath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetDatabase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetDatabase(dbhandle, wbasepath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetDictionary(const ::OPI::DictionaryHandlePrx& dictptr, const ::std::string& wdictpath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetDictionary_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetDictionary(dictptr, wdictpath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetResourceDB(const ::OPI::DatabaseHandlePrx& dbhandle, const ::std::string& wbasepath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetResourceDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetResourceDB(dbhandle, wbasepath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetVariables(const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetVariables_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetVariables(datasourcename, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::Setup(const ::std::string& inifile, const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__Setup_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Setup(inifile, datasourcename, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DataSourceHandle::SetupVariables(const ::std::string& datasourcename, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DataSourceHandle__SetupVariables_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DataSourceHandle* __servant = dynamic_cast< ::OPI::DataSourceHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetupVariables(datasourcename, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::ActivateShadowBase(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__ActivateShadowBase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ActivateShadowBase(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::BackupDB(const ::std::string& target, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__BackupDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->BackupDB(target, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::CheckDB(const ::OPI::CheckOptionsPrx& checkopts, const ::std::string& source, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__CheckDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckDB(checkopts, source, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::CheckLicence(const ::std::string& licowner, const ::std::string& licnumber, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__CheckLicence_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckLicence(licowner, licnumber, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::CloseWorkspace(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__CloseWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CloseWorkspace(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::ConsolidateWorkspace(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__ConsolidateWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ConsolidateWorkspace(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::DeactivateShadowBase(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__DeactivateShadowBase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeactivateShadowBase(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::DeleteWorkspace(const ::std::string& wsnames, const ::std::string& username, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__DeleteWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteWorkspace(wsnames, username, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::DisableWorkspace(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__DisableWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DisableWorkspace(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::DiscardWorkspace(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__DiscardWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DiscardWorkspace(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::EnableWorkspace(const ::std::string& sdwpath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__EnableWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->EnableWorkspace(sdwpath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::ExecuteDatabaseAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__ExecuteDatabaseAction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExecuteDatabaseAction(actionname, parmstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::ExistWorkspace(const ::std::string& wsnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__ExistWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExistWorkspace(wsnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DatabaseHandle::GetDatabaseID(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__GetDatabaseID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDatabaseID(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DatabaseHandle::GetPath(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__GetPath_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetPath(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DatabaseHandle::GetSchemaVersion(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__GetSchemaVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSchemaVersion(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DatabaseHandle::GetVersionString(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__GetVersionString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetVersionString(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DatabaseHandle::GetWorkspace(const ::std::string& wsroot, ::Ice::Int wsindex, const ::std::string& username, const ::std::string& wsname, bool refreshopt, const ::std::string& wsinfo, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__GetWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetWorkspace(wsroot, wsindex, username, wsname, refreshopt, wsinfo, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::IgnoreWriteProtect(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__IgnoreWriteProtect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IgnoreWriteProtect(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::InitDataArea(::Ice::Int mbnumber, ::Ice::Int sbnumber, ::Ice::Int danumber, const ::std::string& filename, ::Ice::Int dasize, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__InitDataArea_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InitDataArea(mbnumber, sbnumber, danumber, filename, dasize, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::InitMainBase(::Ice::Int mbnumber, const ::std::string& filename, ::Ice::Int lowEBN, ::Ice::Int highEBN, ::Ice::Int dasize, bool largedb, bool pindep, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__InitMainBase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InitMainBase(mbnumber, filename, lowEBN, highEBN, dasize, largedb, pindep, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::InitSubBase(::Ice::Int mbnumber, ::Ice::Int sbnumber, const ::std::string& filename, ::Ice::Int dasize, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__InitSubBase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InitSubBase(mbnumber, sbnumber, filename, dasize, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::IsLicenced(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__IsLicenced_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsLicenced(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::IsShared(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__IsShared_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsShared(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::LocateWorkspace(const ::std::string& wsnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__LocateWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->LocateWorkspace(wsnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::OpenDatabase(const ::OPI::DictionaryHandlePrx& dicthandle, const ::std::string& cpath, ::OPI::PIACC accopt, bool wnetopt, bool onlineversion, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, bool sysenv, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__OpenDatabase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDatabase(dicthandle, cpath, accopt, wnetopt, onlineversion, versionnr, localressources, sysenv, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::OpenWorkspace(const ::std::string& wsnames, const ::std::string& username, bool exclusive, const ::std::string& wspath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__OpenWorkspace_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenWorkspace(wsnames, username, exclusive, wspath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::RecreateExtent(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__RecreateExtent_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RecreateExtent(extnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::RestoreDB(const ::std::string& source, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__RestoreDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RestoreDB(source, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DatabaseHandle::SetupTypeID(::Ice::Int sid, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DatabaseHandle__SetupTypeID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DatabaseHandle* __servant = dynamic_cast< ::OPI::DatabaseHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetupTypeID(sid, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DictionaryHandle::BaseType(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__BaseType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->BaseType(strnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CheckExpression(const ::std::string& expression, const ::OPI::DBObjectHandlePrx& dbobjhandle, const ::std::string& clsnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CheckExpression_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckExpression(expression, dbobjhandle, clsnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CheckExpressionInClass(const ::OPI::DBObjectHandlePrx& resobj, const ::std::string& clsnames, const ::std::string& exprnames, const ::std::string& implnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CheckExpressionInClass_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckExpressionInClass(resobj, clsnames, exprnames, implnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CheckExtentDef(const ::std::string& scopedname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CheckExtentDef_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckExtentDef(scopedname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CheckValueSet(const ::std::string& scopedname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CheckValueSet_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckValueSet(scopedname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CopyCodeset(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strname, ::Ice::Int namespaceid, const ::std::string& newnames, ::OPI::PIREPL dbreplace, bool retainSID, bool retainschemav, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CopyCodeset_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyCodeset(srcedicthandle, strname, namespaceid, newnames, dbreplace, retainSID, retainschemav, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CopyExtentDef(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& extentname, const ::std::string& newnames, const ::std::string& targstruct, bool transaction, bool retainschemav, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CopyExtentDef_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyExtentDef(srcedicthandle, extentname, newnames, targstruct, transaction, retainschemav, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CopyStructure(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strname, ::Ice::Int namespaceid, const ::std::string& newnames, const ::std::string& topname, ::OPI::PIREPL dbreplace, bool retainSID, bool retainschemav, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CopyStructure_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyStructure(srcedicthandle, strname, namespaceid, newnames, topname, dbreplace, retainSID, retainschemav, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CopyType(const ::OPI::DictionaryHandlePrx& srcedicthandle, const ::std::string& strnames, const ::std::string& newnames, const ::std::string& topname, ::OPI::PIREPL dbreplace, bool retainSID, bool transaction, bool retainschemav, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CopyType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyType(srcedicthandle, strnames, newnames, topname, dbreplace, retainSID, transaction, retainschemav, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::CreateEnum(const ::std::string& enumname, const ::std::string& basetype, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CreateEnum_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CreateEnum(enumname, basetype, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DictionaryHandle::CreateTempExtent(const ::std::string& strnames, const ::std::string& extnamesw, const ::std::string& keynamew, const ::std::string& baseextsw, bool weakoptw, bool ownoptw, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__CreateTempExtent_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CreateTempExtent(strnames, extnamesw, keynamew, baseextsw, weakoptw, ownoptw, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::DeleteEnum(const ::std::string& enumname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__DeleteEnum_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteEnum(enumname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DictionaryHandle::EnumToString(const ::std::string& enumeration, ::Ice::Int enumval, const ::std::string& pstring, ::Ice::Int len, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__EnumToString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->EnumToString(enumeration, enumval, pstring, len, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DictionaryHandle::GetLastSchemaVersion(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__GetLastSchemaVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetLastSchemaVersion(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::DictionaryHandle::GetTempName(const ::std::string& extnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__GetTempName_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetTempName(extnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::IsBasicType(const ::std::string& typenames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__IsBasicType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsBasicType(typenames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::OpenDictionary(const ::OPI::ODABAClientPrx& podabaclient, const ::std::string& cpath, ::OPI::PIACC accopt, bool wnetopt, ::Ice::Int versionnr, ::OPI::ResourceTypes localressources, bool sysenv, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__OpenDictionary_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDictionary(podabaclient, cpath, accopt, wnetopt, versionnr, localressources, sysenv, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::DictionaryHandle::StringToEnum(const ::std::string& enumeration, const ::std::string& enumstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__StringToEnum_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->StringToEnum(enumeration, enumstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::DictionaryHandle::UpdateVersion(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__DictionaryHandle__UpdateVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::DictionaryHandle* __servant = dynamic_cast< ::OPI::DictionaryHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->UpdateVersion(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::ODABAClient::ActivateGUIMessages(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__ActivateGUIMessages_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->ActivateGUIMessages(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::BackupDB(const ::std::string& cpath, const ::std::string& target, ::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__BackupDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->BackupDB(cpath, target, waitsec, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::CheckDB(const ::std::string& dictpath, const ::std::string& cpath, const ::OPI::CheckOptionsPrx& checkopts, const ::std::string& source, ::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__CheckDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckDB(dictpath, cpath, checkopts, source, waitsec, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::Close(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__Close_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Close(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::Connect(const ::std::string& servername, ::Ice::Int hostport, const ::std::string& cachestring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__Connect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Connect(servername, hostport, cachestring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::DictDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__DictDisplay_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DictDisplay(dbpath, ppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::ODABAClient::Disconnect(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__Disconnect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->Disconnect(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::Exist(const ::std::string& cpath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__Exist_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Exist(cpath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::ODABAClient::GetDataSource(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__GetDataSource_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDataSource(indx0, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::ODABAClient::GetHost(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__GetHost_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetHost(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::ODABAClient::GetPort(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__GetPort_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetPort(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::ODABAClient::GetServerVariable(const ::std::string& varname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__GetServerVariable_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetServerVariable(varname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::ODABAClient::Initialize(const ::std::string& inipath, const ::std::string& applicationname, const ::std::string& progpath, ::OPI::ApplicationTypes applicationtype, bool initservices, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__Initialize_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->Initialize(inipath, applicationname, progpath, applicationtype, initservices, __current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::IsConnected(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__IsConnected_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsConnected(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::KillClient(::Ice::Int clientid, ::Ice::Int waitsec, bool sendmessage, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__KillClient_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->KillClient(clientid, waitsec, sendmessage, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::Open(const ::std::string& inipath, const ::std::string& applicationname, const ::std::string& progpath, ::OPI::ApplicationTypes applicationtype, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__Open_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Open(inipath, applicationname, progpath, applicationtype, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DBObjectHandlePrx
IceDelegateD::OPI::ODABAClient::OpenDataSource(const ::std::string& datasourcename, ::OPI::PIACC accopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__OpenDataSource_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDataSource(datasourcename, accopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::PackDatabase(const ::std::string& cpath, const ::std::string& temppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__PackDatabase_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->PackDatabase(cpath, temppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::RestoreDB(const ::std::string& cpath, const ::std::string& source, ::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__RestoreDB_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RestoreDB(cpath, source, waitsec, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::SendClientMessage(::Ice::Int clientid, const ::std::string& mtext, const ::std::string& mtitle, const ::std::string& mtype, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__SendClientMessage_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SendClientMessage(clientid, mtext, mtitle, mtype, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::SetServerVariable(const ::std::string& varname, const ::std::string& varstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__SetServerVariable_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetServerVariable(varname, varstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::ShutDown(const ::std::string& closesystem, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__ShutDown_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ShutDown(closesystem, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::StartPause(::Ice::Int waitsec, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__StartPause_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->StartPause(waitsec, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::StatDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__StatDisplay_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->StatDisplay(dbpath, ppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::ODABAClient::StopPause(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__StopPause_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->StopPause(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::ODABAClient::SysInfoDisplay(const ::std::string& dbpath, const ::std::string& ppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__ODABAClient__SysInfoDisplay_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::ODABAClient* __servant = dynamic_cast< ::OPI::ODABAClient*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SysInfoDisplay(dbpath, ppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::OperationHandle::CheckExpression(const ::OPI::DictionaryHandlePrx& dictptr, const ::std::string& expression, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& clsnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__CheckExpression_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckExpression(dictptr, expression, obhandle, clsnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::OperationHandle::CheckExpressionInClass(const ::OPI::DictionaryHandlePrx& dictptr, const ::OPI::DBObjectHandlePrx& resobj, const ::std::string& clsnames, const ::std::string& exprnames, const ::std::string& impnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__CheckExpressionInClass_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckExpressionInClass(dictptr, resobj, clsnames, exprnames, impnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::OperationHandle::Execute(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__Execute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Execute(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::OperationHandle::GetResult(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__GetResult_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetResult(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::OperationHandle::GetSize(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__GetSize_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSize(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::OperationHandle::IsValid(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__IsValid_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsValid(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::OperationHandle::Open(const ::OPI::PropertyHandlePrx& prophdlref, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__Open_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Open(prophdlref, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::OperationHandle::ProvideExpression(const ::OPI::DictionaryHandlePrx& pdictionary, const ::OPI::DBObjectHandlePrx& resobj, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OperationHandle__ProvideExpression_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OperationHandle* __servant = dynamic_cast< ::OPI::OperationHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideExpression(pdictionary, resobj, obhandle, expression, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Add(::Ice::Int setpos0, const ::std::string& sortkey, const ::std::string& identkeyw, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Add_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Add(setpos0, sortkey, identkeyw, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddByKey(const ::std::string& sortkey, const ::std::string& identkeyw, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddByKey(sortkey, identkeyw, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddInstance(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddInstance_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddInstance(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddOnPosition(::Ice::Int setpos0w, bool initinst, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddOnPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddOnPosition(setpos0w, initinst, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddGlobal(::Ice::Int setpos0, const ::std::string& sortkey, const ::std::string& identkeyw, bool initinst, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddGlobal_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddGlobal(setpos0, sortkey, identkeyw, initinst, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddGlobalByKey(const ::std::string& sortkey, const ::std::string& identkeyw, bool initinst, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddGlobalByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddGlobalByKey(sortkey, identkeyw, initinst, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddGlobalOnPosition(::Ice::Int setpos0w, bool initinst, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddGlobalOnPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddGlobalOnPosition(setpos0w, initinst, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AddReference(const ::OPI::PropertyHandlePrx& sourcehandle, ::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AddReference_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AddReference(sourcehandle, setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AllocDescription(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AllocDescription_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AllocDescription(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AllocateArea(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AllocateArea_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AllocateArea(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AppendString(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AppendString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AppendString(pstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::AutoLocate(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__AutoLocate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->AutoLocate(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Cancel(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Cancel_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Cancel(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CancelBuffer(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CancelBuffer_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CancelBuffer(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::ChangeBuffer(::Ice::Int buffnum, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ChangeBuffer_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ChangeBuffer(buffnum, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ChangeCache(::Ice::Int buffnum, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ChangeCache_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ChangeCache(buffnum, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PIACC
IceDelegateD::OPI::PropertyHandle::ChangeMode(::OPI::PIACC newmode, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ChangeMode_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ChangeMode(newmode, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Check(bool iniopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Check_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Check(iniopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CheckPosition(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CheckPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckPosition(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CheckUpdate(bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CheckUpdate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckUpdate(pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CheckWProtect(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CheckWProtect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CheckWProtect(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Close(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Close_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Close(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::Compare(const ::OPI::PropertyHandlePrx& cprophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Compare_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Compare(cprophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareDate(::Ice::Long dateval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareDate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareDate(dateval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareFloat(::Ice::Float doubleval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareFloat_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareFloat(doubleval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareInteger(::Ice::Int longval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareInteger_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareInteger(longval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareString(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareString(pstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareTime(::Ice::Long timeval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareTime_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareTime(timeval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareKey(const ::std::string& identkey1, const ::std::string& identkey2, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareKey(identkey1, identkey2, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CompareSortKey(const ::std::string& sortkey1, const ::std::string& sortkey2, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareSortKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareSortKey(sortkey1, sortkey2, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CompareType(const ::OPI::PropertyHandlePrx& prophdl, bool convert, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CompareType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CompareType(prophdl, convert, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Copy(const ::OPI::PropertyHandlePrx& sourcehandle, const ::std::string& newkey, ::Ice::Int setpos0, ::OPI::PIREPL replopt, ::OPI::PIREPL copytype, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Copy_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Copy(sourcehandle, newkey, setpos0, replopt, copytype, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CopyData(const ::OPI::PropertyHandlePrx& sourcehandle, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CopyData_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyData(sourcehandle, replopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CopyHandle(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CopyHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyHandle(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CopyInstanceArea(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CopyInstanceArea_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopyInstanceArea(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::CopySet(const ::OPI::PropertyHandlePrx& csourcehandle, ::OPI::PIREPL replopt, ::OPI::PIREPL copytype, bool inversecheck, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CopySet_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CopySet(csourcehandle, replopt, copytype, inversecheck, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::CreateTempExtent(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& extnamesw, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__CreateTempExtent_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CreateTempExtent(prophdlref, extnamesw, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Delete(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Delete_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Delete(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::DeleteByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__DeleteByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteByKey(sortkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::DeleteOnPosition(::Ice::Int setpos0w, bool deldep, bool delinst, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__DeleteOnPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteOnPosition(setpos0w, deldep, delinst, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::DeleteIndexEntry(::Ice::Int setpos0, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__DeleteIndexEntry_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteIndexEntry(setpos0, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::DeleteSet(bool deldep, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__DeleteSet_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DeleteSet(deldep, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::DisableKeyCheck(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__DisableKeyCheck_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DisableKeyCheck(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Duplicate(::Ice::Int setpos0, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Duplicate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Duplicate(setpos0, replopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::DuplicateKey(const ::std::string& identkey, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__DuplicateKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->DuplicateKey(identkey, replopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::EnableKeyCheck(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__EnableKeyCheck_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->EnableKeyCheck(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Execute(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Execute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Execute(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::ExecuteExpression(const ::OPI::DBObjectHandlePrx& resobhandle, const ::OPI::DBObjectHandlePrx& obhandle, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ExecuteExpression_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExecuteExpression(resobhandle, obhandle, expression, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ExecuteInstanceAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ExecuteInstanceAction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExecuteInstanceAction(actionname, parmstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ExecutePropertyAction(const ::std::string& actionname, const ::std::string& parmstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ExecutePropertyAction_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExecutePropertyAction(actionname, parmstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Exist(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Exist_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Exist(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::ExtractKey(const ::std::string& keyname, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ExtractKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExtractKey(keyname, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::ExtractSortKey(const ::std::string& sortkeyw, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ExtractSortKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ExtractSortKey(sortkeyw, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::FirstKey(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__FirstKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->FirstKey(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Get(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Get_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Get(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::GetAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetAtPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetAtPosition(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::GetByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetByKey(sortkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetActionResult(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetActionResult_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetActionResult(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetArea(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetArea_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetArea(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetAttribute(::Ice::Int indx0, bool fullpath, bool generic, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetAttribute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetAttribute(indx0, fullpath, generic, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::GetBaseProperty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetBaseProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetBaseProperty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetCollectionID(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetCollectionID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCollectionID(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::GetCollectionProperty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetCollectionProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCollectionProperty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetCount(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetCount_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCount(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetCurrentIndex(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetCurrentIndex_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCurrentIndex(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetCurrentSize(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetCurrentSize_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCurrentSize(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetCurrentType(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetCurrentType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCurrentType(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DatabaseHandlePrx
IceDelegateD::OPI::PropertyHandle::GetDBHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDBHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDBHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Long
IceDelegateD::OPI::PropertyHandle::GetDate(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDate(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Long
IceDelegateD::OPI::PropertyHandle::GetDateTime(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDateTime_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDateTime(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetDay(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDay_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDay(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DictionaryHandlePrx
IceDelegateD::OPI::PropertyHandle::GetDictionary(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDictionary_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDictionary(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetDimension(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDimension_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDimension(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Float
IceDelegateD::OPI::PropertyHandle::GetDouble(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetDouble_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDouble(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetExtInstModCount(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetExtInstModCount_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetExtInstModCount(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetExtentName(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetExtentName_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetExtentName(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetGUID(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetGUID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetGUID(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetGenAttrType(const ::std::string& wpropnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetGenAttrType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetGenAttrType(wpropnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetGenOrderType(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetGenOrderType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetGenOrderType(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetGlobalID(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetGlobalID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetGlobalID(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetHours(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetHours_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetHours(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetID(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetID(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetIdentity(const ::std::string& idstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetIdentity_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetIdentity(idstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetIndexName(::Ice::Int indx0, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetIndexName_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetIndexName(indx0, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::GetInitInstance(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetInitInstance_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetInitInstance(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetInstModCount(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetInstModCount_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetInstModCount(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetInt(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetInt_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetInt(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetIntValue(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetIntValue_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetIntValue(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetKey(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetKey(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetKeyLength(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetKeyLength_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetKeyLength(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetLOID(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetLOID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetLOID(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetLOIDByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetLOIDByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetLOIDByKey(sortkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetMinutes(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetMinutes_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetMinutes(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PIACC
IceDelegateD::OPI::PropertyHandle::GetMode(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetMode_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetMode(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetMonth(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetMonth_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetMonth(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetNormalized(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetNormalized_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetNormalized(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DBObjectHandlePrx
IceDelegateD::OPI::PropertyHandle::GetObjectHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetObjectHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetObjectHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetOrigin(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetOrigin_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetOrigin(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::GetParentProperty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetParentProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetParentProperty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::GetPropertyHandle(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetPropertyHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetPropertyHandle(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetPropertyPath(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetPropertyPath_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetPropertyPath(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetRefModCount(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetRefModCount_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetRefModCount(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetReference(::Ice::Int indx0, bool fullpath, bool generic, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetReference_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetReference(indx0, fullpath, generic, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::GetRelative(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetRelative_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetRelative(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetRelativeCount(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetRelativeCount_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetRelativeCount(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetRelativeIndex(bool lastopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetRelativeIndex_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetRelativeIndex(lastopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetSeconds(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSeconds_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSeconds(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetSelectedKey(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSelectedKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSelectedKey(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetSize(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSize_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSize(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetSizeOf(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSizeOf_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSizeOf(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetSortKey(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSortKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSortKey(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetSortKeyLength(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSortKeyLength_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSortKeyLength(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetString(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetString(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetStringLength(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetStringLength_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetStringLength(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetStringValue(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetStringValue_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetStringValue(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetSubString(::Ice::Int startpos, ::Ice::Int length, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetSubString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetSubString(startpos, length, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetText(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetText_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetText(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Long
IceDelegateD::OPI::PropertyHandle::GetTime(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetTime_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetTime(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::GetType(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetType(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::GetValid(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetValid_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetValid(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetVersion(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetVersion(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::GetYear(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__GetYear_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetYear(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::Group(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& groupingrule, bool distinct, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Group_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Group(prophdlref, groupingrule, distinct, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::HasData(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__HasData_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->HasData(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::HasDescription(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__HasDescription_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->HasDescription(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::HasGenericAttributes(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__HasGenericAttributes_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->HasGenericAttributes(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::HasIndex(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__HasIndex_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->HasIndex(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Inherits(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Inherits_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Inherits(strnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::InsertString(const ::std::string& pstring, ::Ice::Int position, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__InsertString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InsertString(pstring, position, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::InsertTerminator(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__InsertTerminator_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InsertTerminator(pstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::InstanceInserted(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__InstanceInserted_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InstanceInserted(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::InstanceToString(const ::std::string& stringsep, const ::std::string& fieldsep, const ::std::string& blocksep, const ::std::string& emptystring, bool skiptrans, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__InstanceToString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->InstanceToString(stringsep, fieldsep, blocksep, emptystring, skiptrans, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::Intersect(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Intersect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Intersect(prophdl1, prophdl2, skopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Is(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Is_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Is(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsA(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsA_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsA(strnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsActive(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsActive_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsActive(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsAttribute(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsAttribute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsAttribute(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsAutoSelection(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsAutoSelection_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsAutoSelection(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsBasedOn(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsBasedOn_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsBasedOn(strnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsBasetypeProperty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsBasetypeProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsBasetypeProperty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsBasicType(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsBasicType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsBasicType(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsClient(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsClient_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsClient(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsCollection(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsCollection_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsCollection(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsCollectionUpdate(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsCollectionUpdate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsCollectionUpdate(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsCopyHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsCopyHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsCopyHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsDirty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsDirty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsDirty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsEmpty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsEmpty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsEmpty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsEnumeration(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsEnumeration_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsEnumeration(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsGenericAttribute(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsGenericAttribute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsGenericAttribute(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsInitInstance(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsInitInstance_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsInitInstance(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsMemo(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsMemo_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsMemo(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsModified(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsModified_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsModified(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsNewInstance(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsNewInstance_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsNewInstance(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsNumeric(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsNumeric_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsNumeric(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsOldInstance(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsOldInstance_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsOldInstance(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsOwner(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsOwner_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsOwner(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsPositioned(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsPositioned_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsPositioned(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsReadOnly(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsReadOnly_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsReadOnly(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsSelected(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsSelected_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsSelected(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsSensitive(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsSensitive_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsSensitive(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsServer(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsServer_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsServer(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsShareBaseHandle(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsShareBaseHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsShareBaseHandle(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsStructure(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsStructure_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsStructure(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsText(const ::std::string& chkopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsText_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsText(chkopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsTransient(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsTransient_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsTransient(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsTrue(const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsTrue_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsTrue(proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsTyped(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsTyped_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsTyped(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsUserHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsUserHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsUserHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsValid(bool topt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsValid_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsValid(topt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsValidText(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsValidText_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsValidText(pstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsVariableType(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsVariableType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsVariableType(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsWeakTyped(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsWeakTyped_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsWeakTyped(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::IsWrite(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__IsWrite_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->IsWrite(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Locate(::Ice::Int obident, bool readopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Locate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Locate(obident, readopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::LocatePath(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__LocatePath_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->LocatePath(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Lock(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Lock_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Lock(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::LockSet(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__LockSet_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->LockSet(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::PropertyHandle::MarkUnused(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__MarkUnused_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->MarkUnused(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::PropertyHandle::MarkUsed(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__MarkUsed_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->MarkUsed(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::Minus(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Minus_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Minus(prophdl1, prophdl2, skopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Modify(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Modify_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Modify(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Move(const ::OPI::PropertyHandlePrx& sourcehandle, const ::std::string& newkey, ::OPI::PIREPL replopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Move_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Move(sourcehandle, newkey, replopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::MoveDown(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__MoveDown_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->MoveDown(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::MoveUp(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__MoveUp_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->MoveUp(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::NextKey(const ::std::string& sortkeyw, ::Ice::Int switchlevel, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__NextKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->NextKey(sortkeyw, switchlevel, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::NoWrite(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__NoWrite_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->NoWrite(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Open(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Open_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Open(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenBigInt(::Ice::Int int64val, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenBigInt_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenBigInt(int64val, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenBoolean(bool logval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenBoolean_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenBoolean(logval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenChild(const ::OPI::PropertyHandlePrx& prophdl, const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenChild_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenChild(prophdl, proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenChildReference(const ::OPI::PropertyHandlePrx& ppropertyhandle, const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenChildReference_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenChildReference(ppropertyhandle, proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenCopy(const ::OPI::PropertyHandlePrx& cprophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenCopy_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenCopy(cprophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenDate(::Ice::Long dateval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenDate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenDate(dateval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenExtent(const ::OPI::DBObjectHandlePrx& objecthandle, const ::std::string& extnames, ::OPI::PIACC accopt, bool transientw, const ::std::string& keynamew, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenExtent_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenExtent(objecthandle, extnames, accopt, transientw, keynamew, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenFloat(::Ice::Float dblvalue, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenFloat_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenFloat(dblvalue, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenInteger(::Ice::Int intval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenInteger_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenInteger(intval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenReference(const ::OPI::PropertyHandlePrx& ppropertyhandle, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenReference_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenReference(ppropertyhandle, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenSizedString(const ::std::string& pstring, ::Ice::Int stringlen, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenSizedString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenSizedString(pstring, stringlen, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenString(const ::std::string& pstring, bool convopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenString(pstring, convopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenTime(::Ice::Long timeval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenTime_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenTime(timeval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenTimestamp(::Ice::Long datetimeval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenTimestamp_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenTimestamp(datetimeval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OpenHierarchy(const ::OPI::PropertyHandlePrx& bottomph, const ::OPI::PropertyHandlePrx& topph, bool pathopt, ::OPI::PIACC accmode, bool copyselection, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OpenHierarchy_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OpenHierarchy(bottomph, topph, pathopt, accmode, copyselection, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::OwnsData(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__OwnsData_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->OwnsData(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Position(::Ice::Int count, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Position_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Position(count, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::PositionTop(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__PositionTop_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->PositionTop(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::Power(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Power_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Power(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvGenAttribute(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvGenAttribute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvGenAttribute(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Provide(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Provide_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Provide(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvideAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideAtPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideAtPosition(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvideByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideByKey(sortkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvideArea(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideArea_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideArea(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::PropertyHandle::ProvideGUID(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideGUID_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideGUID(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvideGlobal(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideGlobal_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideGlobal(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvideGlobalAtPosition(::Ice::Int setpos0w, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideGlobalAtPosition_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideGlobalAtPosition(setpos0w, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ProvideGlobalByKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideGlobalByKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideGlobalByKey(sortkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::OperationHandlePrx
IceDelegateD::OPI::PropertyHandle::ProvideOperation(const ::std::string& expression, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ProvideOperation_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ProvideOperation(expression, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Refresh(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Refresh_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Refresh(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ReleaseBuffer(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ReleaseBuffer_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ReleaseBuffer(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::RemoveFromCollection(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__RemoveFromCollection_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RemoveFromCollection(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::RemoveString(const ::std::string& pstring, ::Ice::Int position, ::Ice::Int len, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__RemoveString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RemoveString(pstring, position, len, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::RemoveTerminator(const ::std::string& pstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__RemoveTerminator_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RemoveTerminator(pstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Rename(const ::std::string& newkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Rename_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Rename(newkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::RepairIndex(const ::std::string& keynamew, const ::std::string& attrstrw, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__RepairIndex_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->RepairIndex(keynamew, attrstrw, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ReplaceString(const ::std::string& oldstr, const ::std::string& newstr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ReplaceString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ReplaceString(oldstr, newstr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ReplaceSysVariables(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ReplaceSysVariables_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ReplaceSysVariables(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Reset(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Reset_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Reset(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::PropertyHandle::ResetDirty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ResetDirty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->ResetDirty(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ResetTransientProperty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ResetTransientProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ResetTransientProperty(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ResetWProtect(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ResetWProtect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ResetWProtect(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Save(const ::std::string& savopt, bool switchopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Save_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Save(savopt, switchopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::Int
IceDelegateD::OPI::PropertyHandle::SearchText(const ::std::string& pstring, ::Ice::Int curpos, bool caseopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SearchText_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SearchText(pstring, curpos, caseopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::Select(const ::OPI::PropertyHandlePrx& prophdlref, const ::std::string& expression, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Select_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Select(prophdlref, expression, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::PropertyHandle::SetActionResult(const ::std::string& resultstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetActionResult_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->SetActionResult(resultstring, __current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetContextVariables(const ::std::string& contextstring, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetContextVariables_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetContextVariables(contextstring, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::PropertyHandle::SetDirty(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetDirty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->SetDirty(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetDynLength(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetDynLength_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetDynLength(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetGenAttribute(const ::std::string& attrstr, const ::std::string& proppath, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetGenAttribute_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetGenAttribute(attrstr, proppath, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetKey(const ::std::string& identkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetKey(identkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::PropertyHandle::SetModified(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetModified_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->SetModified(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetNormalized(::Ice::Int longval, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetNormalized_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetNormalized(longval, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetOrder(const ::std::string& keyname, const ::std::string& attrstr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetOrder_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetOrder(keyname, attrstr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetSelection(const ::std::string& expression, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetSelection_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetSelection(expression, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetSortKey(const ::std::string& sortkey, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetSortKey_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetSortKey(sortkey, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetTransientProperty(const ::OPI::PropertyHandlePrx& prophdl, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetTransientProperty_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetTransientProperty(prophdl, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetType(const ::std::string& strnames, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetType_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetType(strnames, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetUpdate(bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetUpdate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetUpdate(pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValue(const ::OPI::PropertyHandlePrx& cprophdl, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValue_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValue(cprophdl, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueBigInt(::Ice::Int int64val, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueBigInt_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueBigInt(int64val, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueBoolean(bool logval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueBoolean_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueBoolean(logval, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueDate(::Ice::Long dateval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueDate_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueDate(dateval, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueFloat(::Ice::Float dblvalue, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueFloat_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueFloat(dblvalue, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueInteger(::Ice::Int longval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueInteger_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueInteger(longval, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueString(const ::std::string& pstring, bool pcheckupdate, bool convopt, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueString_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueString(pstring, pcheckupdate, convopt, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueTime(::Ice::Long timeval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueTime_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueTime(timeval, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::SetValueTimestamp(::Ice::Long datetimeval, bool pcheckupdate, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetValueTimestamp_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetValueTimestamp(datetimeval, pcheckupdate, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetVersion(::Ice::Int versionnr, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetVersion_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetVersion(versionnr, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::SetWProtect(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__SetWProtect_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->SetWProtect(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::ToTop(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__ToTop_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->ToTop(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::PropertyHandle::Union(const ::OPI::PropertyHandlePrx& prophdl1, const ::OPI::PropertyHandlePrx& prophdl2, const ::std::string& skopt, bool distinct, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Union_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Union(prophdl1, prophdl2, skopt, distinct, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::Unlock(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__Unlock_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->Unlock(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

bool
IceDelegateD::OPI::PropertyHandle::UnlockSet(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__PropertyHandle__UnlockSet_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::PropertyHandle* __servant = dynamic_cast< ::OPI::PropertyHandle*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->UnlockSet(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::OPIFactory::Destroy(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__Destroy_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->Destroy(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::CheckOptionsPrx
IceDelegateD::OPI::OPIFactory::GetCheckOptions(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetCheckOptions_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetCheckOptions(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DBObjectHandlePrx
IceDelegateD::OPI::OPIFactory::GetDBObjectHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetDBObjectHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDBObjectHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DataSourceHandlePrx
IceDelegateD::OPI::OPIFactory::GetDataSourceHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetDataSourceHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDataSourceHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DatabaseHandlePrx
IceDelegateD::OPI::OPIFactory::GetDatabaseHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetDatabaseHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDatabaseHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::DictionaryHandlePrx
IceDelegateD::OPI::OPIFactory::GetDictionaryHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetDictionaryHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetDictionaryHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::ODABAClientPrx
IceDelegateD::OPI::OPIFactory::GetODABAClient(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetODABAClient_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetODABAClient(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::OperationHandlePrx
IceDelegateD::OPI::OPIFactory::GetOperationHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetOperationHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetOperationHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::PropertyHandlePrx
IceDelegateD::OPI::OPIFactory::GetPropertyHandle(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__OPIFactory__GetPropertyHandle_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::OPIFactory* __servant = dynamic_cast< ::OPI::OPIFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->GetPropertyHandle(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::OPIFactoryPrx
IceDelegateD::OPI::Session::CreateSession(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__Session__CreateSession_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::Session* __servant = dynamic_cast< ::OPI::Session*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CreateSession(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::Session::Destroy(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__Session__Destroy_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::Session* __servant = dynamic_cast< ::OPI::Session*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->Destroy(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::Session::TimeOut(::Ice::Int seconds, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__Session__TimeOut_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::Session* __servant = dynamic_cast< ::OPI::Session*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->TimeOut(seconds, __current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::std::string
IceDelegateD::OPI::Session::getName(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__Session__getName_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::Session* __servant = dynamic_cast< ::OPI::Session*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->getName(__current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::OPI::SessionPrx
IceDelegateD::OPI::SessionFactory::CreateProxy(const ::std::string& name, const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__SessionFactory__CreateProxy_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::SessionFactory* __servant = dynamic_cast< ::OPI::SessionFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    return __servant->CreateProxy(name, __current);
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

void
IceDelegateD::OPI::SessionFactory::shutdown(const ::Ice::Context& __context)
{
    ::Ice::Current __current;
    __initCurrent(__current, __OPI__SessionFactory__shutdown_name, ::Ice::Normal, __context);
    while(true)
    {
	::IceInternal::Direct __direct(__current);
	::OPI::SessionFactory* __servant = dynamic_cast< ::OPI::SessionFactory*>(__direct.servant().get());
	if(!__servant)
	{
	    ::Ice::OperationNotExistException __opEx(__FILE__, __LINE__);
	    __opEx.id = __current.id;
	    __opEx.facet = __current.facet;
	    __opEx.operation = __current.operation;
	    throw __opEx;
	}
	try
	{
	    __servant->shutdown(__current);
	    return;
	}
	catch(const ::Ice::LocalException& __ex)
	{
	    throw ::IceInternal::LocalExceptionWrapper(__ex, false);
	}
    }
}

::Ice::ObjectPtr
OPI::CheckOptions::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__CheckOptions_ids[2] =
{
    "::Ice::Object",
    "::OPI::CheckOptions"
};

bool
OPI::CheckOptions::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__CheckOptions_ids, __OPI__CheckOptions_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::CheckOptions::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__CheckOptions_ids[0], &__OPI__CheckOptions_ids[2]);
}

const ::std::string&
OPI::CheckOptions::ice_id(const ::Ice::Current&) const
{
    return __OPI__CheckOptions_ids[1];
}

const ::std::string&
OPI::CheckOptions::ice_staticId()
{
    return __OPI__CheckOptions_ids[1];
}

::IceInternal::DispatchStatus
OPI::CheckOptions::___Initialize(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string parmstring;
    __is->read(parmstring);
    bool __ret = Initialize(parmstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__CheckOptions_all[] =
{
    "Initialize",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::CheckOptions::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__CheckOptions_all, __OPI__CheckOptions_all + 5, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__CheckOptions_all)
    {
	case 0:
	{
	    return ___Initialize(in, current);
	}
	case 1:
	{
	    return ___ice_id(in, current);
	}
	case 2:
	{
	    return ___ice_ids(in, current);
	}
	case 3:
	{
	    return ___ice_isA(in, current);
	}
	case 4:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::CheckOptions::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::CheckOptions::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::CheckOptions::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::CheckOptions was not generated with stream support";
    throw ex;
}

void
OPI::CheckOptions::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::CheckOptions was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__CheckOptionsPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::CheckOptionsPtr* p = static_cast< ::OPI::CheckOptionsPtr*>(__addr);
    assert(p);
    *p = ::OPI::CheckOptionsPtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::CheckOptions::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::CheckOptions& l, const ::OPI::CheckOptions& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::CheckOptions& l, const ::OPI::CheckOptions& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::CheckOptions& l, const ::OPI::CheckOptions& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::CheckOptions& l, const ::OPI::CheckOptions& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::CheckOptions& l, const ::OPI::CheckOptions& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::CheckOptions& l, const ::OPI::CheckOptions& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::DBObjectHandle::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__DBObjectHandle_ids[2] =
{
    "::Ice::Object",
    "::OPI::DBObjectHandle"
};

bool
OPI::DBObjectHandle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__DBObjectHandle_ids, __OPI__DBObjectHandle_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::DBObjectHandle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__DBObjectHandle_ids[0], &__OPI__DBObjectHandle_ids[2]);
}

const ::std::string&
OPI::DBObjectHandle::ice_id(const ::Ice::Current&) const
{
    return __OPI__DBObjectHandle_ids[1];
}

const ::std::string&
OPI::DBObjectHandle::ice_staticId()
{
    return __OPI__DBObjectHandle_ids[1];
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___BeginTransaction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool extTA;
    ::Ice::Int wmaxnum;
    __is->read(extTA);
    __is->read(wmaxnum);
    ::Ice::Int __ret = BeginTransaction(extTA, wmaxnum, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___ChangeTimeStamp(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int versionnr;
    ::Ice::Long timestamp;
    __is->read(versionnr);
    __is->read(timestamp);
    bool __ret = ChangeTimeStamp(versionnr, timestamp, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___CommitTransaction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int talevel;
    __is->read(talevel);
    bool __ret = CommitTransaction(talevel, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___CreateTempPropertyHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdlref;
    ::OPI::__read(__is, prophdlref);
    ::OPI::PropertyHandlePrx __ret = CreateTempPropertyHandle(prophdlref, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___DeleteExtent(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string extnames;
    __is->read(extnames);
    bool __ret = DeleteExtent(extnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___DeleteExtentRef(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string extnames;
    __is->read(extnames);
    bool __ret = DeleteExtentRef(extnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___DisableEventHandling(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    DisableEventHandling(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___EnableEventHandling(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    EnableEventHandling(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___EventHandling(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = EventHandling(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___ExecuteDBObjectAction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string actionname;
    ::std::string parmstring;
    __is->read(actionname);
    __is->read(parmstring);
    bool __ret = ExecuteDBObjectAction(actionname, parmstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___ExecuteExpression(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx resobhandle;
    ::std::string expression;
    ::OPI::__read(__is, resobhandle);
    __is->read(expression);
    ::OPI::PropertyHandlePrx __ret = ExecuteExpression(resobhandle, expression, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___ExtentExist(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string extnames;
    __is->read(extnames);
    bool __ret = ExtentExist(extnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetAccess(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PIACC __ret = GetAccess(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetActionResult(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetActionResult(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetDBHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx __ret = GetDBHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetDataSource(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DataSourceHandlePrx __ret = GetDataSource(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetDictionary(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx __ret = GetDictionary(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetExtent(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int indx0;
    __is->read(indx0);
    ::std::string __ret = GetExtent(indx0, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetHighObject(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx __ret = GetHighObject(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetObject(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int indx0;
    __is->read(indx0);
    ::std::string __ret = GetObject(indx0, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetServerVariable(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string varname;
    __is->read(varname);
    ::std::string __ret = GetServerVariable(varname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetSystemVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetSystemVersion(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetTimeStamp(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int versionnr;
    __is->read(versionnr);
    ::Ice::Long __ret = GetTimeStamp(versionnr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetTransactionLevel(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetTransactionLevel(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___GetVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long timestamp;
    __is->read(timestamp);
    ::Ice::Int __ret = GetVersion(timestamp, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___IsClient(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsClient(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___IsEmpty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsEmpty(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___IsOpened(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsOpened(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___IsServer(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsServer(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___IsValid(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsValid(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___NewVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long timestamp;
    ::Ice::Int versionnr;
    __is->read(timestamp);
    __is->read(versionnr);
    bool __ret = NewVersion(timestamp, versionnr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___OpenObject(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx dbobject;
    ::std::string objname;
    ::OPI::PIACC accopt;
    ::Ice::Int versionnr;
    ::OPI::ResourceTypes localressources;
    ::OPI::__read(__is, dbobject);
    __is->read(objname);
    ::OPI::__read(__is, accopt);
    __is->read(versionnr);
    ::OPI::__read(__is, localressources);
    bool __ret = OpenObject(dbobject, objname, accopt, versionnr, localressources, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___RollBack(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int talevel;
    __is->read(talevel);
    bool __ret = RollBack(talevel, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetActionResult(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::std::string resultstring;
    __is->read(resultstring);
    SetActionResult(resultstring, __current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetOverload(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool overloadopt;
    __is->read(overloadopt);
    ::Ice::Int __ret = SetOverload(overloadopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetServerVariable(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string varname;
    ::std::string varstring;
    __is->read(varname);
    __is->read(varstring);
    bool __ret = SetServerVariable(varname, varstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetUserDefinedIdentity(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool identityopt;
    __is->read(identityopt);
    bool __ret = SetUserDefinedIdentity(identityopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int versionnr;
    __is->read(versionnr);
    bool __ret = SetVersion(versionnr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetVersioni1(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long date;
    __is->read(date);
    bool __ret = SetVersioni1(date, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___SetVersioni2(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long timestamp;
    __is->read(timestamp);
    bool __ret = SetVersioni2(timestamp, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DBObjectHandle::___VersionCount(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = VersionCount(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__DBObjectHandle_all[] =
{
    "BeginTransaction",
    "ChangeTimeStamp",
    "CommitTransaction",
    "CreateTempPropertyHandle",
    "DeleteExtent",
    "DeleteExtentRef",
    "DisableEventHandling",
    "EnableEventHandling",
    "EventHandling",
    "ExecuteDBObjectAction",
    "ExecuteExpression",
    "ExtentExist",
    "GetAccess",
    "GetActionResult",
    "GetDBHandle",
    "GetDataSource",
    "GetDictionary",
    "GetExtent",
    "GetHighObject",
    "GetObject",
    "GetServerVariable",
    "GetSystemVersion",
    "GetTimeStamp",
    "GetTransactionLevel",
    "GetVersion",
    "IsClient",
    "IsEmpty",
    "IsOpened",
    "IsServer",
    "IsValid",
    "NewVersion",
    "OpenObject",
    "RollBack",
    "SetActionResult",
    "SetOverload",
    "SetServerVariable",
    "SetUserDefinedIdentity",
    "SetVersion",
    "SetVersioni1",
    "SetVersioni2",
    "VersionCount",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::DBObjectHandle::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__DBObjectHandle_all, __OPI__DBObjectHandle_all + 45, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__DBObjectHandle_all)
    {
	case 0:
	{
	    return ___BeginTransaction(in, current);
	}
	case 1:
	{
	    return ___ChangeTimeStamp(in, current);
	}
	case 2:
	{
	    return ___CommitTransaction(in, current);
	}
	case 3:
	{
	    return ___CreateTempPropertyHandle(in, current);
	}
	case 4:
	{
	    return ___DeleteExtent(in, current);
	}
	case 5:
	{
	    return ___DeleteExtentRef(in, current);
	}
	case 6:
	{
	    return ___DisableEventHandling(in, current);
	}
	case 7:
	{
	    return ___EnableEventHandling(in, current);
	}
	case 8:
	{
	    return ___EventHandling(in, current);
	}
	case 9:
	{
	    return ___ExecuteDBObjectAction(in, current);
	}
	case 10:
	{
	    return ___ExecuteExpression(in, current);
	}
	case 11:
	{
	    return ___ExtentExist(in, current);
	}
	case 12:
	{
	    return ___GetAccess(in, current);
	}
	case 13:
	{
	    return ___GetActionResult(in, current);
	}
	case 14:
	{
	    return ___GetDBHandle(in, current);
	}
	case 15:
	{
	    return ___GetDataSource(in, current);
	}
	case 16:
	{
	    return ___GetDictionary(in, current);
	}
	case 17:
	{
	    return ___GetExtent(in, current);
	}
	case 18:
	{
	    return ___GetHighObject(in, current);
	}
	case 19:
	{
	    return ___GetObject(in, current);
	}
	case 20:
	{
	    return ___GetServerVariable(in, current);
	}
	case 21:
	{
	    return ___GetSystemVersion(in, current);
	}
	case 22:
	{
	    return ___GetTimeStamp(in, current);
	}
	case 23:
	{
	    return ___GetTransactionLevel(in, current);
	}
	case 24:
	{
	    return ___GetVersion(in, current);
	}
	case 25:
	{
	    return ___IsClient(in, current);
	}
	case 26:
	{
	    return ___IsEmpty(in, current);
	}
	case 27:
	{
	    return ___IsOpened(in, current);
	}
	case 28:
	{
	    return ___IsServer(in, current);
	}
	case 29:
	{
	    return ___IsValid(in, current);
	}
	case 30:
	{
	    return ___NewVersion(in, current);
	}
	case 31:
	{
	    return ___OpenObject(in, current);
	}
	case 32:
	{
	    return ___RollBack(in, current);
	}
	case 33:
	{
	    return ___SetActionResult(in, current);
	}
	case 34:
	{
	    return ___SetOverload(in, current);
	}
	case 35:
	{
	    return ___SetServerVariable(in, current);
	}
	case 36:
	{
	    return ___SetUserDefinedIdentity(in, current);
	}
	case 37:
	{
	    return ___SetVersion(in, current);
	}
	case 38:
	{
	    return ___SetVersioni1(in, current);
	}
	case 39:
	{
	    return ___SetVersioni2(in, current);
	}
	case 40:
	{
	    return ___VersionCount(in, current);
	}
	case 41:
	{
	    return ___ice_id(in, current);
	}
	case 42:
	{
	    return ___ice_ids(in, current);
	}
	case 43:
	{
	    return ___ice_isA(in, current);
	}
	case 44:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::DBObjectHandle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::DBObjectHandle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::DBObjectHandle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DBObjectHandle was not generated with stream support";
    throw ex;
}

void
OPI::DBObjectHandle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DBObjectHandle was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__DBObjectHandlePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::DBObjectHandlePtr* p = static_cast< ::OPI::DBObjectHandlePtr*>(__addr);
    assert(p);
    *p = ::OPI::DBObjectHandlePtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::DBObjectHandle::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::DBObjectHandle& l, const ::OPI::DBObjectHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::DBObjectHandle& l, const ::OPI::DBObjectHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::DBObjectHandle& l, const ::OPI::DBObjectHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::DBObjectHandle& l, const ::OPI::DBObjectHandle& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::DBObjectHandle& l, const ::OPI::DBObjectHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::DBObjectHandle& l, const ::OPI::DBObjectHandle& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::DataSourceHandle::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__DataSourceHandle_ids[2] =
{
    "::Ice::Object",
    "::OPI::DataSourceHandle"
};

bool
OPI::DataSourceHandle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__DataSourceHandle_ids, __OPI__DataSourceHandle_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::DataSourceHandle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__DataSourceHandle_ids[0], &__OPI__DataSourceHandle_ids[2]);
}

const ::std::string&
OPI::DataSourceHandle::ice_id(const ::Ice::Current&) const
{
    return __OPI__DataSourceHandle_ids[1];
}

const ::std::string&
OPI::DataSourceHandle::ice_staticId()
{
    return __OPI__DataSourceHandle_ids[1];
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___BeginTransaction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool extta;
    __is->read(extta);
    bool __ret = BeginTransaction(extta, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Close(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Close(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___CloseDBObject(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CloseDBObject(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___CloseDatabase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CloseDatabase(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___CloseDictionary(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CloseDictionary(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___CloseProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CloseProperty(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___CloseResourceDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CloseResourceDB(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___CommitTransaction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CommitTransaction(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Connect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::ODABAClientPrx podabaclient;
    ::OPI::__read(__is, podabaclient);
    bool __ret = Connect(podabaclient, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Disconnect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Disconnect(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Open(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::ODABAClientPrx podabaclient;
    ::OPI::PIACC accmod;
    ::OPI::__read(__is, podabaclient);
    ::OPI::__read(__is, accmod);
    bool __ret = Open(podabaclient, accmod, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Openi02(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::ODABAClientPrx podabaclient;
    ::std::string inifile;
    ::std::string datasourcename;
    ::OPI::__read(__is, podabaclient);
    __is->read(inifile);
    __is->read(datasourcename);
    bool __ret = Openi02(podabaclient, inifile, datasourcename, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Openi1(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::ODABAClientPrx podabaclient;
    ::std::string datasourcename;
    ::OPI::__read(__is, podabaclient);
    __is->read(datasourcename);
    bool __ret = Openi1(podabaclient, datasourcename, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___OpenDBObject(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx __ret = OpenDBObject(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___OpenDatabase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx __ret = OpenDatabase(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___OpenDictionary(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PIACC accopt;
    ::OPI::__read(__is, accopt);
    ::OPI::DictionaryHandlePrx __ret = OpenDictionary(accopt, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___OpenProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string extname;
    __is->read(extname);
    ::OPI::PropertyHandlePrx __ret = OpenProperty(extname, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___OpenResourceDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx __ret = OpenResourceDB(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___RollBack(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = RollBack(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetDBObject(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx ohandle;
    ::std::string wobjname;
    ::OPI::__read(__is, ohandle);
    __is->read(wobjname);
    bool __ret = SetDBObject(ohandle, wobjname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetDataSource(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DataSourceHandlePrx dbdefptr;
    ::OPI::__read(__is, dbdefptr);
    bool __ret = SetDataSource(dbdefptr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetDatabase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx dbhandle;
    ::std::string wbasepath;
    ::OPI::__read(__is, dbhandle);
    __is->read(wbasepath);
    bool __ret = SetDatabase(dbhandle, wbasepath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetDictionary(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx dictptr;
    ::std::string wdictpath;
    ::OPI::__read(__is, dictptr);
    __is->read(wdictpath);
    bool __ret = SetDictionary(dictptr, wdictpath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetResourceDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx dbhandle;
    ::std::string wbasepath;
    ::OPI::__read(__is, dbhandle);
    __is->read(wbasepath);
    bool __ret = SetResourceDB(dbhandle, wbasepath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetVariables(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string datasourcename;
    __is->read(datasourcename);
    bool __ret = SetVariables(datasourcename, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___Setup(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string inifile;
    ::std::string datasourcename;
    __is->read(inifile);
    __is->read(datasourcename);
    bool __ret = Setup(inifile, datasourcename, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DataSourceHandle::___SetupVariables(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string datasourcename;
    __is->read(datasourcename);
    bool __ret = SetupVariables(datasourcename, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__DataSourceHandle_all[] =
{
    "BeginTransaction",
    "Close",
    "CloseDBObject",
    "CloseDatabase",
    "CloseDictionary",
    "CloseProperty",
    "CloseResourceDB",
    "CommitTransaction",
    "Connect",
    "Disconnect",
    "Open",
    "OpenDBObject",
    "OpenDatabase",
    "OpenDictionary",
    "OpenProperty",
    "OpenResourceDB",
    "Openi02",
    "Openi1",
    "RollBack",
    "SetDBObject",
    "SetDataSource",
    "SetDatabase",
    "SetDictionary",
    "SetResourceDB",
    "SetVariables",
    "Setup",
    "SetupVariables",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::DataSourceHandle::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__DataSourceHandle_all, __OPI__DataSourceHandle_all + 31, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__DataSourceHandle_all)
    {
	case 0:
	{
	    return ___BeginTransaction(in, current);
	}
	case 1:
	{
	    return ___Close(in, current);
	}
	case 2:
	{
	    return ___CloseDBObject(in, current);
	}
	case 3:
	{
	    return ___CloseDatabase(in, current);
	}
	case 4:
	{
	    return ___CloseDictionary(in, current);
	}
	case 5:
	{
	    return ___CloseProperty(in, current);
	}
	case 6:
	{
	    return ___CloseResourceDB(in, current);
	}
	case 7:
	{
	    return ___CommitTransaction(in, current);
	}
	case 8:
	{
	    return ___Connect(in, current);
	}
	case 9:
	{
	    return ___Disconnect(in, current);
	}
	case 10:
	{
	    return ___Open(in, current);
	}
	case 11:
	{
	    return ___OpenDBObject(in, current);
	}
	case 12:
	{
	    return ___OpenDatabase(in, current);
	}
	case 13:
	{
	    return ___OpenDictionary(in, current);
	}
	case 14:
	{
	    return ___OpenProperty(in, current);
	}
	case 15:
	{
	    return ___OpenResourceDB(in, current);
	}
	case 16:
	{
	    return ___Openi02(in, current);
	}
	case 17:
	{
	    return ___Openi1(in, current);
	}
	case 18:
	{
	    return ___RollBack(in, current);
	}
	case 19:
	{
	    return ___SetDBObject(in, current);
	}
	case 20:
	{
	    return ___SetDataSource(in, current);
	}
	case 21:
	{
	    return ___SetDatabase(in, current);
	}
	case 22:
	{
	    return ___SetDictionary(in, current);
	}
	case 23:
	{
	    return ___SetResourceDB(in, current);
	}
	case 24:
	{
	    return ___SetVariables(in, current);
	}
	case 25:
	{
	    return ___Setup(in, current);
	}
	case 26:
	{
	    return ___SetupVariables(in, current);
	}
	case 27:
	{
	    return ___ice_id(in, current);
	}
	case 28:
	{
	    return ___ice_ids(in, current);
	}
	case 29:
	{
	    return ___ice_isA(in, current);
	}
	case 30:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::DataSourceHandle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::DataSourceHandle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::DataSourceHandle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DataSourceHandle was not generated with stream support";
    throw ex;
}

void
OPI::DataSourceHandle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DataSourceHandle was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__DataSourceHandlePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::DataSourceHandlePtr* p = static_cast< ::OPI::DataSourceHandlePtr*>(__addr);
    assert(p);
    *p = ::OPI::DataSourceHandlePtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::DataSourceHandle::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::DataSourceHandle& l, const ::OPI::DataSourceHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::DataSourceHandle& l, const ::OPI::DataSourceHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::DataSourceHandle& l, const ::OPI::DataSourceHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::DataSourceHandle& l, const ::OPI::DataSourceHandle& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::DataSourceHandle& l, const ::OPI::DataSourceHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::DataSourceHandle& l, const ::OPI::DataSourceHandle& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::DatabaseHandle::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__DatabaseHandle_ids[3] =
{
    "::Ice::Object",
    "::OPI::DBObjectHandle",
    "::OPI::DatabaseHandle"
};

bool
OPI::DatabaseHandle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__DatabaseHandle_ids, __OPI__DatabaseHandle_ids + 3, _s);
}

::std::vector< ::std::string>
OPI::DatabaseHandle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__DatabaseHandle_ids[0], &__OPI__DatabaseHandle_ids[3]);
}

const ::std::string&
OPI::DatabaseHandle::ice_id(const ::Ice::Current&) const
{
    return __OPI__DatabaseHandle_ids[2];
}

const ::std::string&
OPI::DatabaseHandle::ice_staticId()
{
    return __OPI__DatabaseHandle_ids[2];
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___ActivateShadowBase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ActivateShadowBase(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___BackupDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string target;
    __is->read(target);
    bool __ret = BackupDB(target, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___CheckDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::CheckOptionsPrx checkopts;
    ::std::string source;
    ::OPI::__read(__is, checkopts);
    __is->read(source);
    bool __ret = CheckDB(checkopts, source, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___CheckLicence(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string licowner;
    ::std::string licnumber;
    __is->read(licowner);
    __is->read(licnumber);
    bool __ret = CheckLicence(licowner, licnumber, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___CloseWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CloseWorkspace(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___ConsolidateWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ConsolidateWorkspace(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___DeactivateShadowBase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = DeactivateShadowBase(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___DeleteWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string wsnames;
    ::std::string username;
    __is->read(wsnames);
    __is->read(username);
    bool __ret = DeleteWorkspace(wsnames, username, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___DisableWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = DisableWorkspace(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___DiscardWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = DiscardWorkspace(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___EnableWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sdwpath;
    __is->read(sdwpath);
    bool __ret = EnableWorkspace(sdwpath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___ExecuteDatabaseAction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string actionname;
    ::std::string parmstring;
    __is->read(actionname);
    __is->read(parmstring);
    bool __ret = ExecuteDatabaseAction(actionname, parmstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___ExistWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string wsnames;
    __is->read(wsnames);
    bool __ret = ExistWorkspace(wsnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___GetDatabaseID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetDatabaseID(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___GetPath(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetPath(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___GetSchemaVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetSchemaVersion(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___GetVersionString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetVersionString(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___GetWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string wsroot;
    ::Ice::Int wsindex;
    ::std::string username;
    ::std::string wsname;
    bool refreshopt;
    ::std::string wsinfo;
    __is->read(wsroot);
    __is->read(wsindex);
    __is->read(username);
    __is->read(wsname);
    __is->read(refreshopt);
    __is->read(wsinfo);
    ::std::string __ret = GetWorkspace(wsroot, wsindex, username, wsname, refreshopt, wsinfo, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___IgnoreWriteProtect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IgnoreWriteProtect(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___InitDataArea(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int mbnumber;
    ::Ice::Int sbnumber;
    ::Ice::Int danumber;
    ::std::string filename;
    ::Ice::Int dasize;
    __is->read(mbnumber);
    __is->read(sbnumber);
    __is->read(danumber);
    __is->read(filename);
    __is->read(dasize);
    bool __ret = InitDataArea(mbnumber, sbnumber, danumber, filename, dasize, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___InitMainBase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int mbnumber;
    ::std::string filename;
    ::Ice::Int lowEBN;
    ::Ice::Int highEBN;
    ::Ice::Int dasize;
    bool largedb;
    bool pindep;
    __is->read(mbnumber);
    __is->read(filename);
    __is->read(lowEBN);
    __is->read(highEBN);
    __is->read(dasize);
    __is->read(largedb);
    __is->read(pindep);
    bool __ret = InitMainBase(mbnumber, filename, lowEBN, highEBN, dasize, largedb, pindep, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___InitSubBase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int mbnumber;
    ::Ice::Int sbnumber;
    ::std::string filename;
    ::Ice::Int dasize;
    __is->read(mbnumber);
    __is->read(sbnumber);
    __is->read(filename);
    __is->read(dasize);
    bool __ret = InitSubBase(mbnumber, sbnumber, filename, dasize, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___IsLicenced(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsLicenced(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___IsShared(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsShared(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___LocateWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string wsnames;
    __is->read(wsnames);
    bool __ret = LocateWorkspace(wsnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___OpenDatabase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx dicthandle;
    ::std::string cpath;
    ::OPI::PIACC accopt;
    bool wnetopt;
    bool onlineversion;
    ::Ice::Int versionnr;
    ::OPI::ResourceTypes localressources;
    bool sysenv;
    ::OPI::__read(__is, dicthandle);
    __is->read(cpath);
    ::OPI::__read(__is, accopt);
    __is->read(wnetopt);
    __is->read(onlineversion);
    __is->read(versionnr);
    ::OPI::__read(__is, localressources);
    __is->read(sysenv);
    bool __ret = OpenDatabase(dicthandle, cpath, accopt, wnetopt, onlineversion, versionnr, localressources, sysenv, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___OpenWorkspace(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string wsnames;
    ::std::string username;
    bool exclusive;
    ::std::string wspath;
    __is->read(wsnames);
    __is->read(username);
    __is->read(exclusive);
    __is->read(wspath);
    bool __ret = OpenWorkspace(wsnames, username, exclusive, wspath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___RecreateExtent(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string extnames;
    __is->read(extnames);
    bool __ret = RecreateExtent(extnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___RestoreDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string source;
    __is->read(source);
    bool __ret = RestoreDB(source, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DatabaseHandle::___SetupTypeID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int sid;
    __is->read(sid);
    bool __ret = SetupTypeID(sid, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__DatabaseHandle_all[] =
{
    "ActivateShadowBase",
    "BackupDB",
    "BeginTransaction",
    "ChangeTimeStamp",
    "CheckDB",
    "CheckLicence",
    "CloseWorkspace",
    "CommitTransaction",
    "ConsolidateWorkspace",
    "CreateTempPropertyHandle",
    "DeactivateShadowBase",
    "DeleteExtent",
    "DeleteExtentRef",
    "DeleteWorkspace",
    "DisableEventHandling",
    "DisableWorkspace",
    "DiscardWorkspace",
    "EnableEventHandling",
    "EnableWorkspace",
    "EventHandling",
    "ExecuteDBObjectAction",
    "ExecuteDatabaseAction",
    "ExecuteExpression",
    "ExistWorkspace",
    "ExtentExist",
    "GetAccess",
    "GetActionResult",
    "GetDBHandle",
    "GetDataSource",
    "GetDatabaseID",
    "GetDictionary",
    "GetExtent",
    "GetHighObject",
    "GetObject",
    "GetPath",
    "GetSchemaVersion",
    "GetServerVariable",
    "GetSystemVersion",
    "GetTimeStamp",
    "GetTransactionLevel",
    "GetVersion",
    "GetVersionString",
    "GetWorkspace",
    "IgnoreWriteProtect",
    "InitDataArea",
    "InitMainBase",
    "InitSubBase",
    "IsClient",
    "IsEmpty",
    "IsLicenced",
    "IsOpened",
    "IsServer",
    "IsShared",
    "IsValid",
    "LocateWorkspace",
    "NewVersion",
    "OpenDatabase",
    "OpenObject",
    "OpenWorkspace",
    "RecreateExtent",
    "RestoreDB",
    "RollBack",
    "SetActionResult",
    "SetOverload",
    "SetServerVariable",
    "SetUserDefinedIdentity",
    "SetVersion",
    "SetVersioni1",
    "SetVersioni2",
    "SetupTypeID",
    "VersionCount",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::DatabaseHandle::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__DatabaseHandle_all, __OPI__DatabaseHandle_all + 75, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__DatabaseHandle_all)
    {
	case 0:
	{
	    return ___ActivateShadowBase(in, current);
	}
	case 1:
	{
	    return ___BackupDB(in, current);
	}
	case 2:
	{
	    return ___BeginTransaction(in, current);
	}
	case 3:
	{
	    return ___ChangeTimeStamp(in, current);
	}
	case 4:
	{
	    return ___CheckDB(in, current);
	}
	case 5:
	{
	    return ___CheckLicence(in, current);
	}
	case 6:
	{
	    return ___CloseWorkspace(in, current);
	}
	case 7:
	{
	    return ___CommitTransaction(in, current);
	}
	case 8:
	{
	    return ___ConsolidateWorkspace(in, current);
	}
	case 9:
	{
	    return ___CreateTempPropertyHandle(in, current);
	}
	case 10:
	{
	    return ___DeactivateShadowBase(in, current);
	}
	case 11:
	{
	    return ___DeleteExtent(in, current);
	}
	case 12:
	{
	    return ___DeleteExtentRef(in, current);
	}
	case 13:
	{
	    return ___DeleteWorkspace(in, current);
	}
	case 14:
	{
	    return ___DisableEventHandling(in, current);
	}
	case 15:
	{
	    return ___DisableWorkspace(in, current);
	}
	case 16:
	{
	    return ___DiscardWorkspace(in, current);
	}
	case 17:
	{
	    return ___EnableEventHandling(in, current);
	}
	case 18:
	{
	    return ___EnableWorkspace(in, current);
	}
	case 19:
	{
	    return ___EventHandling(in, current);
	}
	case 20:
	{
	    return ___ExecuteDBObjectAction(in, current);
	}
	case 21:
	{
	    return ___ExecuteDatabaseAction(in, current);
	}
	case 22:
	{
	    return ___ExecuteExpression(in, current);
	}
	case 23:
	{
	    return ___ExistWorkspace(in, current);
	}
	case 24:
	{
	    return ___ExtentExist(in, current);
	}
	case 25:
	{
	    return ___GetAccess(in, current);
	}
	case 26:
	{
	    return ___GetActionResult(in, current);
	}
	case 27:
	{
	    return ___GetDBHandle(in, current);
	}
	case 28:
	{
	    return ___GetDataSource(in, current);
	}
	case 29:
	{
	    return ___GetDatabaseID(in, current);
	}
	case 30:
	{
	    return ___GetDictionary(in, current);
	}
	case 31:
	{
	    return ___GetExtent(in, current);
	}
	case 32:
	{
	    return ___GetHighObject(in, current);
	}
	case 33:
	{
	    return ___GetObject(in, current);
	}
	case 34:
	{
	    return ___GetPath(in, current);
	}
	case 35:
	{
	    return ___GetSchemaVersion(in, current);
	}
	case 36:
	{
	    return ___GetServerVariable(in, current);
	}
	case 37:
	{
	    return ___GetSystemVersion(in, current);
	}
	case 38:
	{
	    return ___GetTimeStamp(in, current);
	}
	case 39:
	{
	    return ___GetTransactionLevel(in, current);
	}
	case 40:
	{
	    return ___GetVersion(in, current);
	}
	case 41:
	{
	    return ___GetVersionString(in, current);
	}
	case 42:
	{
	    return ___GetWorkspace(in, current);
	}
	case 43:
	{
	    return ___IgnoreWriteProtect(in, current);
	}
	case 44:
	{
	    return ___InitDataArea(in, current);
	}
	case 45:
	{
	    return ___InitMainBase(in, current);
	}
	case 46:
	{
	    return ___InitSubBase(in, current);
	}
	case 47:
	{
	    return ___IsClient(in, current);
	}
	case 48:
	{
	    return ___IsEmpty(in, current);
	}
	case 49:
	{
	    return ___IsLicenced(in, current);
	}
	case 50:
	{
	    return ___IsOpened(in, current);
	}
	case 51:
	{
	    return ___IsServer(in, current);
	}
	case 52:
	{
	    return ___IsShared(in, current);
	}
	case 53:
	{
	    return ___IsValid(in, current);
	}
	case 54:
	{
	    return ___LocateWorkspace(in, current);
	}
	case 55:
	{
	    return ___NewVersion(in, current);
	}
	case 56:
	{
	    return ___OpenDatabase(in, current);
	}
	case 57:
	{
	    return ___OpenObject(in, current);
	}
	case 58:
	{
	    return ___OpenWorkspace(in, current);
	}
	case 59:
	{
	    return ___RecreateExtent(in, current);
	}
	case 60:
	{
	    return ___RestoreDB(in, current);
	}
	case 61:
	{
	    return ___RollBack(in, current);
	}
	case 62:
	{
	    return ___SetActionResult(in, current);
	}
	case 63:
	{
	    return ___SetOverload(in, current);
	}
	case 64:
	{
	    return ___SetServerVariable(in, current);
	}
	case 65:
	{
	    return ___SetUserDefinedIdentity(in, current);
	}
	case 66:
	{
	    return ___SetVersion(in, current);
	}
	case 67:
	{
	    return ___SetVersioni1(in, current);
	}
	case 68:
	{
	    return ___SetVersioni2(in, current);
	}
	case 69:
	{
	    return ___SetupTypeID(in, current);
	}
	case 70:
	{
	    return ___VersionCount(in, current);
	}
	case 71:
	{
	    return ___ice_id(in, current);
	}
	case 72:
	{
	    return ___ice_ids(in, current);
	}
	case 73:
	{
	    return ___ice_isA(in, current);
	}
	case 74:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::DatabaseHandle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    DBObjectHandle::__write(__os);
#else
    ::OPI::DBObjectHandle::__write(__os);
#endif
}

void
OPI::DatabaseHandle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    DBObjectHandle::__read(__is, true);
#else
    ::OPI::DBObjectHandle::__read(__is, true);
#endif
}

void
OPI::DatabaseHandle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DatabaseHandle was not generated with stream support";
    throw ex;
}

void
OPI::DatabaseHandle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DatabaseHandle was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__DatabaseHandlePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::DatabaseHandlePtr* p = static_cast< ::OPI::DatabaseHandlePtr*>(__addr);
    assert(p);
    *p = ::OPI::DatabaseHandlePtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::DatabaseHandle::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::DatabaseHandle& l, const ::OPI::DatabaseHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::DatabaseHandle& l, const ::OPI::DatabaseHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::DatabaseHandle& l, const ::OPI::DatabaseHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::DatabaseHandle& l, const ::OPI::DatabaseHandle& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::DatabaseHandle& l, const ::OPI::DatabaseHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::DatabaseHandle& l, const ::OPI::DatabaseHandle& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::DictionaryHandle::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__DictionaryHandle_ids[4] =
{
    "::Ice::Object",
    "::OPI::DBObjectHandle",
    "::OPI::DatabaseHandle",
    "::OPI::DictionaryHandle"
};

bool
OPI::DictionaryHandle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__DictionaryHandle_ids, __OPI__DictionaryHandle_ids + 4, _s);
}

::std::vector< ::std::string>
OPI::DictionaryHandle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__DictionaryHandle_ids[0], &__OPI__DictionaryHandle_ids[4]);
}

const ::std::string&
OPI::DictionaryHandle::ice_id(const ::Ice::Current&) const
{
    return __OPI__DictionaryHandle_ids[3];
}

const ::std::string&
OPI::DictionaryHandle::ice_staticId()
{
    return __OPI__DictionaryHandle_ids[3];
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___BaseType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string strnames;
    __is->read(strnames);
    ::Ice::Int __ret = BaseType(strnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CheckExpression(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string expression;
    ::OPI::DBObjectHandlePrx dbobjhandle;
    ::std::string clsnames;
    __is->read(expression);
    ::OPI::__read(__is, dbobjhandle);
    __is->read(clsnames);
    bool __ret = CheckExpression(expression, dbobjhandle, clsnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CheckExpressionInClass(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx resobj;
    ::std::string clsnames;
    ::std::string exprnames;
    ::std::string implnames;
    ::OPI::__read(__is, resobj);
    __is->read(clsnames);
    __is->read(exprnames);
    __is->read(implnames);
    bool __ret = CheckExpressionInClass(resobj, clsnames, exprnames, implnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CheckExtentDef(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string scopedname;
    __is->read(scopedname);
    bool __ret = CheckExtentDef(scopedname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CheckValueSet(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string scopedname;
    __is->read(scopedname);
    bool __ret = CheckValueSet(scopedname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CopyCodeset(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx srcedicthandle;
    ::std::string strname;
    ::Ice::Int namespaceid;
    ::std::string newnames;
    ::OPI::PIREPL dbreplace;
    bool retainSID;
    bool retainschemav;
    ::OPI::__read(__is, srcedicthandle);
    __is->read(strname);
    __is->read(namespaceid);
    __is->read(newnames);
    ::OPI::__read(__is, dbreplace);
    __is->read(retainSID);
    __is->read(retainschemav);
    bool __ret = CopyCodeset(srcedicthandle, strname, namespaceid, newnames, dbreplace, retainSID, retainschemav, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CopyExtentDef(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx srcedicthandle;
    ::std::string extentname;
    ::std::string newnames;
    ::std::string targstruct;
    bool transaction;
    bool retainschemav;
    ::OPI::__read(__is, srcedicthandle);
    __is->read(extentname);
    __is->read(newnames);
    __is->read(targstruct);
    __is->read(transaction);
    __is->read(retainschemav);
    bool __ret = CopyExtentDef(srcedicthandle, extentname, newnames, targstruct, transaction, retainschemav, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CopyStructure(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx srcedicthandle;
    ::std::string strname;
    ::Ice::Int namespaceid;
    ::std::string newnames;
    ::std::string topname;
    ::OPI::PIREPL dbreplace;
    bool retainSID;
    bool retainschemav;
    ::OPI::__read(__is, srcedicthandle);
    __is->read(strname);
    __is->read(namespaceid);
    __is->read(newnames);
    __is->read(topname);
    ::OPI::__read(__is, dbreplace);
    __is->read(retainSID);
    __is->read(retainschemav);
    bool __ret = CopyStructure(srcedicthandle, strname, namespaceid, newnames, topname, dbreplace, retainSID, retainschemav, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CopyType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx srcedicthandle;
    ::std::string strnames;
    ::std::string newnames;
    ::std::string topname;
    ::OPI::PIREPL dbreplace;
    bool retainSID;
    bool transaction;
    bool retainschemav;
    ::OPI::__read(__is, srcedicthandle);
    __is->read(strnames);
    __is->read(newnames);
    __is->read(topname);
    ::OPI::__read(__is, dbreplace);
    __is->read(retainSID);
    __is->read(transaction);
    __is->read(retainschemav);
    bool __ret = CopyType(srcedicthandle, strnames, newnames, topname, dbreplace, retainSID, transaction, retainschemav, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CreateEnum(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string enumname;
    ::std::string basetype;
    __is->read(enumname);
    __is->read(basetype);
    bool __ret = CreateEnum(enumname, basetype, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___CreateTempExtent(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string strnames;
    ::std::string extnamesw;
    ::std::string keynamew;
    ::std::string baseextsw;
    bool weakoptw;
    bool ownoptw;
    __is->read(strnames);
    __is->read(extnamesw);
    __is->read(keynamew);
    __is->read(baseextsw);
    __is->read(weakoptw);
    __is->read(ownoptw);
    ::std::string __ret = CreateTempExtent(strnames, extnamesw, keynamew, baseextsw, weakoptw, ownoptw, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___DeleteEnum(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string enumname;
    __is->read(enumname);
    bool __ret = DeleteEnum(enumname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___EnumToString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string enumeration;
    ::Ice::Int enumval;
    ::std::string pstring;
    ::Ice::Int len;
    __is->read(enumeration);
    __is->read(enumval);
    __is->read(pstring);
    __is->read(len);
    ::std::string __ret = EnumToString(enumeration, enumval, pstring, len, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___GetLastSchemaVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetLastSchemaVersion(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___GetTempName(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string extnames;
    __is->read(extnames);
    ::std::string __ret = GetTempName(extnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___IsBasicType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string typenames;
    __is->read(typenames);
    bool __ret = IsBasicType(typenames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___OpenDictionary(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::ODABAClientPrx podabaclient;
    ::std::string cpath;
    ::OPI::PIACC accopt;
    bool wnetopt;
    ::Ice::Int versionnr;
    ::OPI::ResourceTypes localressources;
    bool sysenv;
    ::OPI::__read(__is, podabaclient);
    __is->read(cpath);
    ::OPI::__read(__is, accopt);
    __is->read(wnetopt);
    __is->read(versionnr);
    ::OPI::__read(__is, localressources);
    __is->read(sysenv);
    bool __ret = OpenDictionary(podabaclient, cpath, accopt, wnetopt, versionnr, localressources, sysenv, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___StringToEnum(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string enumeration;
    ::std::string enumstring;
    __is->read(enumeration);
    __is->read(enumstring);
    ::Ice::Int __ret = StringToEnum(enumeration, enumstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::DictionaryHandle::___UpdateVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = UpdateVersion(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__DictionaryHandle_all[] =
{
    "ActivateShadowBase",
    "BackupDB",
    "BaseType",
    "BeginTransaction",
    "ChangeTimeStamp",
    "CheckDB",
    "CheckExpression",
    "CheckExpressionInClass",
    "CheckExtentDef",
    "CheckLicence",
    "CheckValueSet",
    "CloseWorkspace",
    "CommitTransaction",
    "ConsolidateWorkspace",
    "CopyCodeset",
    "CopyExtentDef",
    "CopyStructure",
    "CopyType",
    "CreateEnum",
    "CreateTempExtent",
    "CreateTempPropertyHandle",
    "DeactivateShadowBase",
    "DeleteEnum",
    "DeleteExtent",
    "DeleteExtentRef",
    "DeleteWorkspace",
    "DisableEventHandling",
    "DisableWorkspace",
    "DiscardWorkspace",
    "EnableEventHandling",
    "EnableWorkspace",
    "EnumToString",
    "EventHandling",
    "ExecuteDBObjectAction",
    "ExecuteDatabaseAction",
    "ExecuteExpression",
    "ExistWorkspace",
    "ExtentExist",
    "GetAccess",
    "GetActionResult",
    "GetDBHandle",
    "GetDataSource",
    "GetDatabaseID",
    "GetDictionary",
    "GetExtent",
    "GetHighObject",
    "GetLastSchemaVersion",
    "GetObject",
    "GetPath",
    "GetSchemaVersion",
    "GetServerVariable",
    "GetSystemVersion",
    "GetTempName",
    "GetTimeStamp",
    "GetTransactionLevel",
    "GetVersion",
    "GetVersionString",
    "GetWorkspace",
    "IgnoreWriteProtect",
    "InitDataArea",
    "InitMainBase",
    "InitSubBase",
    "IsBasicType",
    "IsClient",
    "IsEmpty",
    "IsLicenced",
    "IsOpened",
    "IsServer",
    "IsShared",
    "IsValid",
    "LocateWorkspace",
    "NewVersion",
    "OpenDatabase",
    "OpenDictionary",
    "OpenObject",
    "OpenWorkspace",
    "RecreateExtent",
    "RestoreDB",
    "RollBack",
    "SetActionResult",
    "SetOverload",
    "SetServerVariable",
    "SetUserDefinedIdentity",
    "SetVersion",
    "SetVersioni1",
    "SetVersioni2",
    "SetupTypeID",
    "StringToEnum",
    "UpdateVersion",
    "VersionCount",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::DictionaryHandle::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__DictionaryHandle_all, __OPI__DictionaryHandle_all + 94, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__DictionaryHandle_all)
    {
	case 0:
	{
	    return ___ActivateShadowBase(in, current);
	}
	case 1:
	{
	    return ___BackupDB(in, current);
	}
	case 2:
	{
	    return ___BaseType(in, current);
	}
	case 3:
	{
	    return ___BeginTransaction(in, current);
	}
	case 4:
	{
	    return ___ChangeTimeStamp(in, current);
	}
	case 5:
	{
	    return ___CheckDB(in, current);
	}
	case 6:
	{
	    return ___CheckExpression(in, current);
	}
	case 7:
	{
	    return ___CheckExpressionInClass(in, current);
	}
	case 8:
	{
	    return ___CheckExtentDef(in, current);
	}
	case 9:
	{
	    return ___CheckLicence(in, current);
	}
	case 10:
	{
	    return ___CheckValueSet(in, current);
	}
	case 11:
	{
	    return ___CloseWorkspace(in, current);
	}
	case 12:
	{
	    return ___CommitTransaction(in, current);
	}
	case 13:
	{
	    return ___ConsolidateWorkspace(in, current);
	}
	case 14:
	{
	    return ___CopyCodeset(in, current);
	}
	case 15:
	{
	    return ___CopyExtentDef(in, current);
	}
	case 16:
	{
	    return ___CopyStructure(in, current);
	}
	case 17:
	{
	    return ___CopyType(in, current);
	}
	case 18:
	{
	    return ___CreateEnum(in, current);
	}
	case 19:
	{
	    return ___CreateTempExtent(in, current);
	}
	case 20:
	{
	    return ___CreateTempPropertyHandle(in, current);
	}
	case 21:
	{
	    return ___DeactivateShadowBase(in, current);
	}
	case 22:
	{
	    return ___DeleteEnum(in, current);
	}
	case 23:
	{
	    return ___DeleteExtent(in, current);
	}
	case 24:
	{
	    return ___DeleteExtentRef(in, current);
	}
	case 25:
	{
	    return ___DeleteWorkspace(in, current);
	}
	case 26:
	{
	    return ___DisableEventHandling(in, current);
	}
	case 27:
	{
	    return ___DisableWorkspace(in, current);
	}
	case 28:
	{
	    return ___DiscardWorkspace(in, current);
	}
	case 29:
	{
	    return ___EnableEventHandling(in, current);
	}
	case 30:
	{
	    return ___EnableWorkspace(in, current);
	}
	case 31:
	{
	    return ___EnumToString(in, current);
	}
	case 32:
	{
	    return ___EventHandling(in, current);
	}
	case 33:
	{
	    return ___ExecuteDBObjectAction(in, current);
	}
	case 34:
	{
	    return ___ExecuteDatabaseAction(in, current);
	}
	case 35:
	{
	    return ___ExecuteExpression(in, current);
	}
	case 36:
	{
	    return ___ExistWorkspace(in, current);
	}
	case 37:
	{
	    return ___ExtentExist(in, current);
	}
	case 38:
	{
	    return ___GetAccess(in, current);
	}
	case 39:
	{
	    return ___GetActionResult(in, current);
	}
	case 40:
	{
	    return ___GetDBHandle(in, current);
	}
	case 41:
	{
	    return ___GetDataSource(in, current);
	}
	case 42:
	{
	    return ___GetDatabaseID(in, current);
	}
	case 43:
	{
	    return ___GetDictionary(in, current);
	}
	case 44:
	{
	    return ___GetExtent(in, current);
	}
	case 45:
	{
	    return ___GetHighObject(in, current);
	}
	case 46:
	{
	    return ___GetLastSchemaVersion(in, current);
	}
	case 47:
	{
	    return ___GetObject(in, current);
	}
	case 48:
	{
	    return ___GetPath(in, current);
	}
	case 49:
	{
	    return ___GetSchemaVersion(in, current);
	}
	case 50:
	{
	    return ___GetServerVariable(in, current);
	}
	case 51:
	{
	    return ___GetSystemVersion(in, current);
	}
	case 52:
	{
	    return ___GetTempName(in, current);
	}
	case 53:
	{
	    return ___GetTimeStamp(in, current);
	}
	case 54:
	{
	    return ___GetTransactionLevel(in, current);
	}
	case 55:
	{
	    return ___GetVersion(in, current);
	}
	case 56:
	{
	    return ___GetVersionString(in, current);
	}
	case 57:
	{
	    return ___GetWorkspace(in, current);
	}
	case 58:
	{
	    return ___IgnoreWriteProtect(in, current);
	}
	case 59:
	{
	    return ___InitDataArea(in, current);
	}
	case 60:
	{
	    return ___InitMainBase(in, current);
	}
	case 61:
	{
	    return ___InitSubBase(in, current);
	}
	case 62:
	{
	    return ___IsBasicType(in, current);
	}
	case 63:
	{
	    return ___IsClient(in, current);
	}
	case 64:
	{
	    return ___IsEmpty(in, current);
	}
	case 65:
	{
	    return ___IsLicenced(in, current);
	}
	case 66:
	{
	    return ___IsOpened(in, current);
	}
	case 67:
	{
	    return ___IsServer(in, current);
	}
	case 68:
	{
	    return ___IsShared(in, current);
	}
	case 69:
	{
	    return ___IsValid(in, current);
	}
	case 70:
	{
	    return ___LocateWorkspace(in, current);
	}
	case 71:
	{
	    return ___NewVersion(in, current);
	}
	case 72:
	{
	    return ___OpenDatabase(in, current);
	}
	case 73:
	{
	    return ___OpenDictionary(in, current);
	}
	case 74:
	{
	    return ___OpenObject(in, current);
	}
	case 75:
	{
	    return ___OpenWorkspace(in, current);
	}
	case 76:
	{
	    return ___RecreateExtent(in, current);
	}
	case 77:
	{
	    return ___RestoreDB(in, current);
	}
	case 78:
	{
	    return ___RollBack(in, current);
	}
	case 79:
	{
	    return ___SetActionResult(in, current);
	}
	case 80:
	{
	    return ___SetOverload(in, current);
	}
	case 81:
	{
	    return ___SetServerVariable(in, current);
	}
	case 82:
	{
	    return ___SetUserDefinedIdentity(in, current);
	}
	case 83:
	{
	    return ___SetVersion(in, current);
	}
	case 84:
	{
	    return ___SetVersioni1(in, current);
	}
	case 85:
	{
	    return ___SetVersioni2(in, current);
	}
	case 86:
	{
	    return ___SetupTypeID(in, current);
	}
	case 87:
	{
	    return ___StringToEnum(in, current);
	}
	case 88:
	{
	    return ___UpdateVersion(in, current);
	}
	case 89:
	{
	    return ___VersionCount(in, current);
	}
	case 90:
	{
	    return ___ice_id(in, current);
	}
	case 91:
	{
	    return ___ice_ids(in, current);
	}
	case 92:
	{
	    return ___ice_isA(in, current);
	}
	case 93:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::DictionaryHandle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    DatabaseHandle::__write(__os);
#else
    ::OPI::DatabaseHandle::__write(__os);
#endif
}

void
OPI::DictionaryHandle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    DatabaseHandle::__read(__is, true);
#else
    ::OPI::DatabaseHandle::__read(__is, true);
#endif
}

void
OPI::DictionaryHandle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DictionaryHandle was not generated with stream support";
    throw ex;
}

void
OPI::DictionaryHandle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::DictionaryHandle was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__DictionaryHandlePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::DictionaryHandlePtr* p = static_cast< ::OPI::DictionaryHandlePtr*>(__addr);
    assert(p);
    *p = ::OPI::DictionaryHandlePtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::DictionaryHandle::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::DictionaryHandle& l, const ::OPI::DictionaryHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::DictionaryHandle& l, const ::OPI::DictionaryHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::DictionaryHandle& l, const ::OPI::DictionaryHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::DictionaryHandle& l, const ::OPI::DictionaryHandle& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::DictionaryHandle& l, const ::OPI::DictionaryHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::DictionaryHandle& l, const ::OPI::DictionaryHandle& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::ODABAClient::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__ODABAClient_ids[2] =
{
    "::Ice::Object",
    "::OPI::ODABAClient"
};

bool
OPI::ODABAClient::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__ODABAClient_ids, __OPI__ODABAClient_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::ODABAClient::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__ODABAClient_ids[0], &__OPI__ODABAClient_ids[2]);
}

const ::std::string&
OPI::ODABAClient::ice_id(const ::Ice::Current&) const
{
    return __OPI__ODABAClient_ids[1];
}

const ::std::string&
OPI::ODABAClient::ice_staticId()
{
    return __OPI__ODABAClient_ids[1];
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___ActivateGUIMessages(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ActivateGUIMessages(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___BackupDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string cpath;
    ::std::string target;
    ::Ice::Int waitsec;
    __is->read(cpath);
    __is->read(target);
    __is->read(waitsec);
    bool __ret = BackupDB(cpath, target, waitsec, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___CheckDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string dictpath;
    ::std::string cpath;
    ::OPI::CheckOptionsPrx checkopts;
    ::std::string source;
    ::Ice::Int waitsec;
    __is->read(dictpath);
    __is->read(cpath);
    ::OPI::__read(__is, checkopts);
    __is->read(source);
    __is->read(waitsec);
    bool __ret = CheckDB(dictpath, cpath, checkopts, source, waitsec, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___Close(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Close(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___Connect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string servername;
    ::Ice::Int hostport;
    ::std::string cachestring;
    __is->read(servername);
    __is->read(hostport);
    __is->read(cachestring);
    bool __ret = Connect(servername, hostport, cachestring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___DictDisplay(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string dbpath;
    ::std::string ppath;
    __is->read(dbpath);
    __is->read(ppath);
    bool __ret = DictDisplay(dbpath, ppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___Disconnect(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    Disconnect(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___Exist(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string cpath;
    __is->read(cpath);
    bool __ret = Exist(cpath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___GetDataSource(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int indx0;
    __is->read(indx0);
    ::std::string __ret = GetDataSource(indx0, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___GetHost(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetHost(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___GetPort(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetPort(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___GetServerVariable(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string varname;
    __is->read(varname);
    ::std::string __ret = GetServerVariable(varname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___Initialize(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::std::string inipath;
    ::std::string applicationname;
    ::std::string progpath;
    ::OPI::ApplicationTypes applicationtype;
    bool initservices;
    __is->read(inipath);
    __is->read(applicationname);
    __is->read(progpath);
    ::OPI::__read(__is, applicationtype);
    __is->read(initservices);
    Initialize(inipath, applicationname, progpath, applicationtype, initservices, __current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___IsConnected(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsConnected(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___KillClient(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int clientid;
    ::Ice::Int waitsec;
    bool sendmessage;
    __is->read(clientid);
    __is->read(waitsec);
    __is->read(sendmessage);
    bool __ret = KillClient(clientid, waitsec, sendmessage, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___Open(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string inipath;
    ::std::string applicationname;
    ::std::string progpath;
    ::OPI::ApplicationTypes applicationtype;
    __is->read(inipath);
    __is->read(applicationname);
    __is->read(progpath);
    ::OPI::__read(__is, applicationtype);
    bool __ret = Open(inipath, applicationname, progpath, applicationtype, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___OpenDataSource(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string datasourcename;
    ::OPI::PIACC accopt;
    __is->read(datasourcename);
    ::OPI::__read(__is, accopt);
    ::OPI::DBObjectHandlePrx __ret = OpenDataSource(datasourcename, accopt, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___PackDatabase(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string cpath;
    ::std::string temppath;
    __is->read(cpath);
    __is->read(temppath);
    bool __ret = PackDatabase(cpath, temppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___RestoreDB(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string cpath;
    ::std::string source;
    ::Ice::Int waitsec;
    __is->read(cpath);
    __is->read(source);
    __is->read(waitsec);
    bool __ret = RestoreDB(cpath, source, waitsec, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___SendClientMessage(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int clientid;
    ::std::string mtext;
    ::std::string mtitle;
    ::std::string mtype;
    __is->read(clientid);
    __is->read(mtext);
    __is->read(mtitle);
    __is->read(mtype);
    bool __ret = SendClientMessage(clientid, mtext, mtitle, mtype, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___SetServerVariable(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string varname;
    ::std::string varstring;
    __is->read(varname);
    __is->read(varstring);
    bool __ret = SetServerVariable(varname, varstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___ShutDown(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string closesystem;
    __is->read(closesystem);
    bool __ret = ShutDown(closesystem, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___StartPause(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int waitsec;
    __is->read(waitsec);
    bool __ret = StartPause(waitsec, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___StatDisplay(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string dbpath;
    ::std::string ppath;
    __is->read(dbpath);
    __is->read(ppath);
    bool __ret = StatDisplay(dbpath, ppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___StopPause(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    StopPause(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::ODABAClient::___SysInfoDisplay(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string dbpath;
    ::std::string ppath;
    __is->read(dbpath);
    __is->read(ppath);
    bool __ret = SysInfoDisplay(dbpath, ppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__ODABAClient_all[] =
{
    "ActivateGUIMessages",
    "BackupDB",
    "CheckDB",
    "Close",
    "Connect",
    "DictDisplay",
    "Disconnect",
    "Exist",
    "GetDataSource",
    "GetHost",
    "GetPort",
    "GetServerVariable",
    "Initialize",
    "IsConnected",
    "KillClient",
    "Open",
    "OpenDataSource",
    "PackDatabase",
    "RestoreDB",
    "SendClientMessage",
    "SetServerVariable",
    "ShutDown",
    "StartPause",
    "StatDisplay",
    "StopPause",
    "SysInfoDisplay",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::ODABAClient::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__ODABAClient_all, __OPI__ODABAClient_all + 30, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__ODABAClient_all)
    {
	case 0:
	{
	    return ___ActivateGUIMessages(in, current);
	}
	case 1:
	{
	    return ___BackupDB(in, current);
	}
	case 2:
	{
	    return ___CheckDB(in, current);
	}
	case 3:
	{
	    return ___Close(in, current);
	}
	case 4:
	{
	    return ___Connect(in, current);
	}
	case 5:
	{
	    return ___DictDisplay(in, current);
	}
	case 6:
	{
	    return ___Disconnect(in, current);
	}
	case 7:
	{
	    return ___Exist(in, current);
	}
	case 8:
	{
	    return ___GetDataSource(in, current);
	}
	case 9:
	{
	    return ___GetHost(in, current);
	}
	case 10:
	{
	    return ___GetPort(in, current);
	}
	case 11:
	{
	    return ___GetServerVariable(in, current);
	}
	case 12:
	{
	    return ___Initialize(in, current);
	}
	case 13:
	{
	    return ___IsConnected(in, current);
	}
	case 14:
	{
	    return ___KillClient(in, current);
	}
	case 15:
	{
	    return ___Open(in, current);
	}
	case 16:
	{
	    return ___OpenDataSource(in, current);
	}
	case 17:
	{
	    return ___PackDatabase(in, current);
	}
	case 18:
	{
	    return ___RestoreDB(in, current);
	}
	case 19:
	{
	    return ___SendClientMessage(in, current);
	}
	case 20:
	{
	    return ___SetServerVariable(in, current);
	}
	case 21:
	{
	    return ___ShutDown(in, current);
	}
	case 22:
	{
	    return ___StartPause(in, current);
	}
	case 23:
	{
	    return ___StatDisplay(in, current);
	}
	case 24:
	{
	    return ___StopPause(in, current);
	}
	case 25:
	{
	    return ___SysInfoDisplay(in, current);
	}
	case 26:
	{
	    return ___ice_id(in, current);
	}
	case 27:
	{
	    return ___ice_ids(in, current);
	}
	case 28:
	{
	    return ___ice_isA(in, current);
	}
	case 29:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::ODABAClient::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::ODABAClient::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::ODABAClient::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::ODABAClient was not generated with stream support";
    throw ex;
}

void
OPI::ODABAClient::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::ODABAClient was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__ODABAClientPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::ODABAClientPtr* p = static_cast< ::OPI::ODABAClientPtr*>(__addr);
    assert(p);
    *p = ::OPI::ODABAClientPtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::ODABAClient::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::ODABAClient& l, const ::OPI::ODABAClient& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::ODABAClient& l, const ::OPI::ODABAClient& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::ODABAClient& l, const ::OPI::ODABAClient& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::ODABAClient& l, const ::OPI::ODABAClient& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::ODABAClient& l, const ::OPI::ODABAClient& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::ODABAClient& l, const ::OPI::ODABAClient& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::OperationHandle::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__OperationHandle_ids[2] =
{
    "::Ice::Object",
    "::OPI::OperationHandle"
};

bool
OPI::OperationHandle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__OperationHandle_ids, __OPI__OperationHandle_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::OperationHandle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__OperationHandle_ids[0], &__OPI__OperationHandle_ids[2]);
}

const ::std::string&
OPI::OperationHandle::ice_id(const ::Ice::Current&) const
{
    return __OPI__OperationHandle_ids[1];
}

const ::std::string&
OPI::OperationHandle::ice_staticId()
{
    return __OPI__OperationHandle_ids[1];
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___CheckExpression(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx dictptr;
    ::std::string expression;
    ::OPI::DBObjectHandlePrx obhandle;
    ::std::string clsnames;
    ::OPI::__read(__is, dictptr);
    __is->read(expression);
    ::OPI::__read(__is, obhandle);
    __is->read(clsnames);
    bool __ret = CheckExpression(dictptr, expression, obhandle, clsnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___CheckExpressionInClass(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx dictptr;
    ::OPI::DBObjectHandlePrx resobj;
    ::std::string clsnames;
    ::std::string exprnames;
    ::std::string impnames;
    ::OPI::__read(__is, dictptr);
    ::OPI::__read(__is, resobj);
    __is->read(clsnames);
    __is->read(exprnames);
    __is->read(impnames);
    bool __ret = CheckExpressionInClass(dictptr, resobj, clsnames, exprnames, impnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___Execute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Execute(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___GetResult(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx __ret = GetResult(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___GetSize(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetSize(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___IsValid(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsValid(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___Open(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdlref;
    ::OPI::__read(__is, prophdlref);
    bool __ret = Open(prophdlref, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OperationHandle::___ProvideExpression(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx pdictionary;
    ::OPI::DBObjectHandlePrx resobj;
    ::OPI::DBObjectHandlePrx obhandle;
    ::std::string expression;
    ::OPI::__read(__is, pdictionary);
    ::OPI::__read(__is, resobj);
    ::OPI::__read(__is, obhandle);
    __is->read(expression);
    bool __ret = ProvideExpression(pdictionary, resobj, obhandle, expression, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__OperationHandle_all[] =
{
    "CheckExpression",
    "CheckExpressionInClass",
    "Execute",
    "GetResult",
    "GetSize",
    "IsValid",
    "Open",
    "ProvideExpression",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::OperationHandle::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__OperationHandle_all, __OPI__OperationHandle_all + 12, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__OperationHandle_all)
    {
	case 0:
	{
	    return ___CheckExpression(in, current);
	}
	case 1:
	{
	    return ___CheckExpressionInClass(in, current);
	}
	case 2:
	{
	    return ___Execute(in, current);
	}
	case 3:
	{
	    return ___GetResult(in, current);
	}
	case 4:
	{
	    return ___GetSize(in, current);
	}
	case 5:
	{
	    return ___IsValid(in, current);
	}
	case 6:
	{
	    return ___Open(in, current);
	}
	case 7:
	{
	    return ___ProvideExpression(in, current);
	}
	case 8:
	{
	    return ___ice_id(in, current);
	}
	case 9:
	{
	    return ___ice_ids(in, current);
	}
	case 10:
	{
	    return ___ice_isA(in, current);
	}
	case 11:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::OperationHandle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::OperationHandle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::OperationHandle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::OperationHandle was not generated with stream support";
    throw ex;
}

void
OPI::OperationHandle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::OperationHandle was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__OperationHandlePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::OperationHandlePtr* p = static_cast< ::OPI::OperationHandlePtr*>(__addr);
    assert(p);
    *p = ::OPI::OperationHandlePtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::OperationHandle::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::OperationHandle& l, const ::OPI::OperationHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::OperationHandle& l, const ::OPI::OperationHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::OperationHandle& l, const ::OPI::OperationHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::OperationHandle& l, const ::OPI::OperationHandle& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::OperationHandle& l, const ::OPI::OperationHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::OperationHandle& l, const ::OPI::OperationHandle& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::PropertyHandle::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__PropertyHandle_ids[2] =
{
    "::Ice::Object",
    "::OPI::PropertyHandle"
};

bool
OPI::PropertyHandle::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__PropertyHandle_ids, __OPI__PropertyHandle_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::PropertyHandle::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__PropertyHandle_ids[0], &__OPI__PropertyHandle_ids[2]);
}

const ::std::string&
OPI::PropertyHandle::ice_id(const ::Ice::Current&) const
{
    return __OPI__PropertyHandle_ids[1];
}

const ::std::string&
OPI::PropertyHandle::ice_staticId()
{
    return __OPI__PropertyHandle_ids[1];
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Add(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0;
    ::std::string sortkey;
    ::std::string identkeyw;
    __is->read(setpos0);
    __is->read(sortkey);
    __is->read(identkeyw);
    bool __ret = Add(setpos0, sortkey, identkeyw, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    ::std::string identkeyw;
    __is->read(sortkey);
    __is->read(identkeyw);
    bool __ret = AddByKey(sortkey, identkeyw, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddInstance(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = AddInstance(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddOnPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    bool initinst;
    __is->read(setpos0w);
    __is->read(initinst);
    bool __ret = AddOnPosition(setpos0w, initinst, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddGlobal(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0;
    ::std::string sortkey;
    ::std::string identkeyw;
    bool initinst;
    __is->read(setpos0);
    __is->read(sortkey);
    __is->read(identkeyw);
    __is->read(initinst);
    bool __ret = AddGlobal(setpos0, sortkey, identkeyw, initinst, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddGlobalByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    ::std::string identkeyw;
    bool initinst;
    __is->read(sortkey);
    __is->read(identkeyw);
    __is->read(initinst);
    bool __ret = AddGlobalByKey(sortkey, identkeyw, initinst, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddGlobalOnPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    bool initinst;
    __is->read(setpos0w);
    __is->read(initinst);
    bool __ret = AddGlobalOnPosition(setpos0w, initinst, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AddReference(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx sourcehandle;
    ::Ice::Int setpos0w;
    ::OPI::__read(__is, sourcehandle);
    __is->read(setpos0w);
    bool __ret = AddReference(sourcehandle, setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AllocDescription(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = AllocDescription(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AllocateArea(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = AllocateArea(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AppendString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    __is->read(pstring);
    bool __ret = AppendString(pstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___AutoLocate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = AutoLocate(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Cancel(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Cancel(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CancelBuffer(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CancelBuffer(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ChangeBuffer(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int buffnum;
    __is->read(buffnum);
    ::Ice::Int __ret = ChangeBuffer(buffnum, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ChangeCache(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int buffnum;
    __is->read(buffnum);
    bool __ret = ChangeCache(buffnum, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ChangeMode(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PIACC newmode;
    ::OPI::__read(__is, newmode);
    ::OPI::PIACC __ret = ChangeMode(newmode, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Check(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool iniopt;
    __is->read(iniopt);
    bool __ret = Check(iniopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CheckPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CheckPosition(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CheckUpdate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool pcheckupdate;
    __is->read(pcheckupdate);
    bool __ret = CheckUpdate(pcheckupdate, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CheckWProtect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = CheckWProtect(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Close(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Close(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Compare(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx cprophdl;
    ::OPI::__read(__is, cprophdl);
    ::Ice::Int __ret = Compare(cprophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareDate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long dateval;
    __is->read(dateval);
    ::Ice::Int __ret = CompareDate(dateval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareFloat(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float doubleval;
    __is->read(doubleval);
    ::Ice::Int __ret = CompareFloat(doubleval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareInteger(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int longval;
    __is->read(longval);
    ::Ice::Int __ret = CompareInteger(longval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    __is->read(pstring);
    ::Ice::Int __ret = CompareString(pstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareTime(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long timeval;
    __is->read(timeval);
    ::Ice::Int __ret = CompareTime(timeval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string identkey1;
    ::std::string identkey2;
    __is->read(identkey1);
    __is->read(identkey2);
    ::Ice::Int __ret = CompareKey(identkey1, identkey2, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareSortKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey1;
    ::std::string sortkey2;
    __is->read(sortkey1);
    __is->read(sortkey2);
    ::Ice::Int __ret = CompareSortKey(sortkey1, sortkey2, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CompareType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    bool convert;
    ::OPI::__read(__is, prophdl);
    __is->read(convert);
    bool __ret = CompareType(prophdl, convert, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Copy(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx sourcehandle;
    ::std::string newkey;
    ::Ice::Int setpos0;
    ::OPI::PIREPL replopt;
    ::OPI::PIREPL copytype;
    ::OPI::__read(__is, sourcehandle);
    __is->read(newkey);
    __is->read(setpos0);
    ::OPI::__read(__is, replopt);
    ::OPI::__read(__is, copytype);
    bool __ret = Copy(sourcehandle, newkey, setpos0, replopt, copytype, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CopyData(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx sourcehandle;
    ::OPI::PIREPL replopt;
    ::OPI::__read(__is, sourcehandle);
    ::OPI::__read(__is, replopt);
    bool __ret = CopyData(sourcehandle, replopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CopyHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = CopyHandle(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CopyInstanceArea(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = CopyInstanceArea(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CopySet(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx csourcehandle;
    ::OPI::PIREPL replopt;
    ::OPI::PIREPL copytype;
    bool inversecheck;
    ::OPI::__read(__is, csourcehandle);
    ::OPI::__read(__is, replopt);
    ::OPI::__read(__is, copytype);
    __is->read(inversecheck);
    ::Ice::Int __ret = CopySet(csourcehandle, replopt, copytype, inversecheck, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___CreateTempExtent(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdlref;
    ::std::string extnamesw;
    ::OPI::__read(__is, prophdlref);
    __is->read(extnamesw);
    bool __ret = CreateTempExtent(prophdlref, extnamesw, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Delete(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = Delete(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___DeleteByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    __is->read(sortkey);
    bool __ret = DeleteByKey(sortkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___DeleteOnPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    bool deldep;
    bool delinst;
    __is->read(setpos0w);
    __is->read(deldep);
    __is->read(delinst);
    bool __ret = DeleteOnPosition(setpos0w, deldep, delinst, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___DeleteIndexEntry(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0;
    __is->read(setpos0);
    bool __ret = DeleteIndexEntry(setpos0, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___DeleteSet(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool deldep;
    __is->read(deldep);
    bool __ret = DeleteSet(deldep, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___DisableKeyCheck(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = DisableKeyCheck(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Duplicate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0;
    ::OPI::PIREPL replopt;
    __is->read(setpos0);
    ::OPI::__read(__is, replopt);
    bool __ret = Duplicate(setpos0, replopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___DuplicateKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string identkey;
    ::OPI::PIREPL replopt;
    __is->read(identkey);
    ::OPI::__read(__is, replopt);
    bool __ret = DuplicateKey(identkey, replopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___EnableKeyCheck(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = EnableKeyCheck(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Execute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Execute(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ExecuteExpression(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx resobhandle;
    ::OPI::DBObjectHandlePrx obhandle;
    ::std::string expression;
    ::OPI::__read(__is, resobhandle);
    ::OPI::__read(__is, obhandle);
    __is->read(expression);
    ::OPI::PropertyHandlePrx __ret = ExecuteExpression(resobhandle, obhandle, expression, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ExecuteInstanceAction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string actionname;
    ::std::string parmstring;
    __is->read(actionname);
    __is->read(parmstring);
    bool __ret = ExecuteInstanceAction(actionname, parmstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ExecutePropertyAction(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string actionname;
    ::std::string parmstring;
    __is->read(actionname);
    __is->read(parmstring);
    bool __ret = ExecutePropertyAction(actionname, parmstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Exist(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Exist(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ExtractKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string keyname;
    __is->read(keyname);
    ::std::string __ret = ExtractKey(keyname, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ExtractSortKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkeyw;
    __is->read(sortkeyw);
    ::std::string __ret = ExtractSortKey(sortkeyw, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___FirstKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = FirstKey(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Get(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = Get(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetAtPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    bool __ret = GetAtPosition(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    __is->read(sortkey);
    bool __ret = GetByKey(sortkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetActionResult(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetActionResult(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetArea(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    ::std::string __ret = GetArea(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetAttribute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int indx0;
    bool fullpath;
    bool generic;
    __is->read(indx0);
    __is->read(fullpath);
    __is->read(generic);
    ::std::string __ret = GetAttribute(indx0, fullpath, generic, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetBaseProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx __ret = GetBaseProperty(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetCollectionID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetCollectionID(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetCollectionProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx __ret = GetCollectionProperty(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetCount(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetCount(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetCurrentIndex(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetCurrentIndex(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetCurrentSize(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetCurrentSize(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetCurrentType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetCurrentType(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDBHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx __ret = GetDBHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Long __ret = GetDate(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDateTime(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Long __ret = GetDateTime(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDay(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetDay(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDictionary(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx __ret = GetDictionary(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDimension(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetDimension(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetDouble(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Float __ret = GetDouble(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetExtInstModCount(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetExtInstModCount(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetExtentName(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetExtentName(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetGUID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetGUID(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetGenAttrType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string wpropnames;
    __is->read(wpropnames);
    ::Ice::Int __ret = GetGenAttrType(wpropnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetGenOrderType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetGenOrderType(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetGlobalID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetGlobalID(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetHours(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetHours(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    ::Ice::Int __ret = GetID(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetIdentity(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string idstring;
    __is->read(idstring);
    ::std::string __ret = GetIdentity(idstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetIndexName(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int indx0;
    __is->read(indx0);
    ::std::string __ret = GetIndexName(indx0, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetInitInstance(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = GetInitInstance(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetInstModCount(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetInstModCount(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetInt(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetInt(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetIntValue(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetIntValue(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    ::std::string __ret = GetKey(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetKeyLength(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetKeyLength(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetLOID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    ::Ice::Int __ret = GetLOID(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetLOIDByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    __is->read(sortkey);
    ::Ice::Int __ret = GetLOIDByKey(sortkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetMinutes(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetMinutes(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetMode(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PIACC __ret = GetMode(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetMonth(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetMonth(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetNormalized(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetNormalized(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetObjectHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx __ret = GetObjectHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetOrigin(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetOrigin(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetParentProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx __ret = GetParentProperty(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetPropertyHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::OPI::PropertyHandlePrx __ret = GetPropertyHandle(proppath, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetPropertyPath(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetPropertyPath(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetRefModCount(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetRefModCount(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetReference(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int indx0;
    bool fullpath;
    bool generic;
    __is->read(indx0);
    __is->read(fullpath);
    __is->read(generic);
    ::std::string __ret = GetReference(indx0, fullpath, generic, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetRelative(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    bool __ret = GetRelative(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetRelativeCount(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetRelativeCount(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetRelativeIndex(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool lastopt;
    __is->read(lastopt);
    ::Ice::Int __ret = GetRelativeIndex(lastopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSeconds(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetSeconds(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSelectedKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetSelectedKey(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSize(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetSize(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSizeOf(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetSizeOf(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSortKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetSortKey(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSortKeyLength(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetSortKeyLength(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::std::string __ret = GetString(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetStringLength(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetStringLength(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetStringValue(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::std::string __ret = GetStringValue(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetSubString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int startpos;
    ::Ice::Int length;
    __is->read(startpos);
    __is->read(length);
    ::std::string __ret = GetSubString(startpos, length, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetText(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::std::string __ret = GetText(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetTime(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Long __ret = GetTime(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = GetType(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetValid(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = GetValid(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = GetVersion(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___GetYear(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    ::Ice::Int __ret = GetYear(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Group(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdlref;
    ::std::string groupingrule;
    bool distinct;
    ::OPI::__read(__is, prophdlref);
    __is->read(groupingrule);
    __is->read(distinct);
    ::OPI::PropertyHandlePrx __ret = Group(prophdlref, groupingrule, distinct, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___HasData(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = HasData(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___HasDescription(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = HasDescription(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___HasGenericAttributes(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = HasGenericAttributes(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___HasIndex(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = HasIndex(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Inherits(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string strnames;
    __is->read(strnames);
    bool __ret = Inherits(strnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___InsertString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    ::Ice::Int position;
    __is->read(pstring);
    __is->read(position);
    bool __ret = InsertString(pstring, position, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___InsertTerminator(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    __is->read(pstring);
    bool __ret = InsertTerminator(pstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___InstanceInserted(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = InstanceInserted(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___InstanceToString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string stringsep;
    ::std::string fieldsep;
    ::std::string blocksep;
    ::std::string emptystring;
    bool skiptrans;
    __is->read(stringsep);
    __is->read(fieldsep);
    __is->read(blocksep);
    __is->read(emptystring);
    __is->read(skiptrans);
    ::std::string __ret = InstanceToString(stringsep, fieldsep, blocksep, emptystring, skiptrans, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Intersect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl1;
    ::OPI::PropertyHandlePrx prophdl2;
    ::std::string skopt;
    ::OPI::__read(__is, prophdl1);
    ::OPI::__read(__is, prophdl2);
    __is->read(skopt);
    ::OPI::PropertyHandlePrx __ret = Intersect(prophdl1, prophdl2, skopt, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Is(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = Is(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsA(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string strnames;
    __is->read(strnames);
    bool __ret = IsA(strnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsActive(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsActive(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsAttribute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsAttribute(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsAutoSelection(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsAutoSelection(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsBasedOn(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string strnames;
    __is->read(strnames);
    bool __ret = IsBasedOn(strnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsBasetypeProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsBasetypeProperty(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsBasicType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsBasicType(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsClient(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsClient(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsCollection(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = IsCollection(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsCollectionUpdate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsCollectionUpdate(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsCopyHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsCopyHandle(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsDirty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsDirty(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsEmpty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsEmpty(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsEnumeration(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsEnumeration(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsGenericAttribute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsGenericAttribute(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsInitInstance(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsInitInstance(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsMemo(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = IsMemo(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsModified(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsModified(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsNewInstance(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsNewInstance(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsNumeric(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsNumeric(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsOldInstance(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsOldInstance(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsOwner(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsOwner(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsPositioned(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = IsPositioned(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsReadOnly(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsReadOnly(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsSelected(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = IsSelected(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsSensitive(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    bool __ret = IsSensitive(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsServer(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsServer(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsShareBaseHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = IsShareBaseHandle(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsStructure(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsStructure(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsText(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string chkopt;
    __is->read(chkopt);
    bool __ret = IsText(chkopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsTransient(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsTransient(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsTrue(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string proppath;
    __is->read(proppath);
    bool __ret = IsTrue(proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsTyped(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsTyped(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsUserHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsUserHandle(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsValid(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool topt;
    __is->read(topt);
    bool __ret = IsValid(topt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsValidText(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    __is->read(pstring);
    bool __ret = IsValidText(pstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsVariableType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsVariableType(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsWeakTyped(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsWeakTyped(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___IsWrite(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = IsWrite(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Locate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int obident;
    bool readopt;
    __is->read(obident);
    __is->read(readopt);
    bool __ret = Locate(obident, readopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___LocatePath(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = LocatePath(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Lock(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Lock(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___LockSet(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = LockSet(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___MarkUnused(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    MarkUnused(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___MarkUsed(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    MarkUsed(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Minus(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl1;
    ::OPI::PropertyHandlePrx prophdl2;
    ::std::string skopt;
    ::OPI::__read(__is, prophdl1);
    ::OPI::__read(__is, prophdl2);
    __is->read(skopt);
    ::OPI::PropertyHandlePrx __ret = Minus(prophdl1, prophdl2, skopt, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Modify(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Modify(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Move(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx sourcehandle;
    ::std::string newkey;
    ::OPI::PIREPL replopt;
    ::OPI::__read(__is, sourcehandle);
    __is->read(newkey);
    ::OPI::__read(__is, replopt);
    bool __ret = Move(sourcehandle, newkey, replopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___MoveDown(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = MoveDown(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___MoveUp(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = MoveUp(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___NextKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkeyw;
    ::Ice::Int switchlevel;
    __is->read(sortkeyw);
    __is->read(switchlevel);
    ::std::string __ret = NextKey(sortkeyw, switchlevel, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___NoWrite(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = NoWrite(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Open(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Open(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenBigInt(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int int64val;
    __is->read(int64val);
    bool __ret = OpenBigInt(int64val, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenBoolean(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool logval;
    __is->read(logval);
    bool __ret = OpenBoolean(logval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenChild(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::std::string proppath;
    ::OPI::__read(__is, prophdl);
    __is->read(proppath);
    bool __ret = OpenChild(prophdl, proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenChildReference(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx ppropertyhandle;
    ::std::string proppath;
    ::OPI::__read(__is, ppropertyhandle);
    __is->read(proppath);
    bool __ret = OpenChildReference(ppropertyhandle, proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenCopy(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx cprophdl;
    ::OPI::__read(__is, cprophdl);
    bool __ret = OpenCopy(cprophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenDate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long dateval;
    __is->read(dateval);
    bool __ret = OpenDate(dateval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenExtent(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx objecthandle;
    ::std::string extnames;
    ::OPI::PIACC accopt;
    bool transientw;
    ::std::string keynamew;
    ::OPI::__read(__is, objecthandle);
    __is->read(extnames);
    ::OPI::__read(__is, accopt);
    __is->read(transientw);
    __is->read(keynamew);
    bool __ret = OpenExtent(objecthandle, extnames, accopt, transientw, keynamew, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenFloat(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float dblvalue;
    __is->read(dblvalue);
    bool __ret = OpenFloat(dblvalue, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenInteger(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int intval;
    __is->read(intval);
    bool __ret = OpenInteger(intval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenReference(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx ppropertyhandle;
    ::OPI::__read(__is, ppropertyhandle);
    bool __ret = OpenReference(ppropertyhandle, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenSizedString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    ::Ice::Int stringlen;
    __is->read(pstring);
    __is->read(stringlen);
    bool __ret = OpenSizedString(pstring, stringlen, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    bool convopt;
    __is->read(pstring);
    __is->read(convopt);
    bool __ret = OpenString(pstring, convopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenTime(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long timeval;
    __is->read(timeval);
    bool __ret = OpenTime(timeval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenTimestamp(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long datetimeval;
    __is->read(datetimeval);
    bool __ret = OpenTimestamp(datetimeval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OpenHierarchy(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx bottomph;
    ::OPI::PropertyHandlePrx topph;
    bool pathopt;
    ::OPI::PIACC accmode;
    bool copyselection;
    ::OPI::__read(__is, bottomph);
    ::OPI::__read(__is, topph);
    __is->read(pathopt);
    ::OPI::__read(__is, accmode);
    __is->read(copyselection);
    bool __ret = OpenHierarchy(bottomph, topph, pathopt, accmode, copyselection, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___OwnsData(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = OwnsData(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Position(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int count;
    __is->read(count);
    bool __ret = Position(count, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___PositionTop(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = PositionTop(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Power(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    ::OPI::PropertyHandlePrx __ret = Power(prophdl, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvGenAttribute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ProvGenAttribute(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Provide(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = Provide(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideAtPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    bool __ret = ProvideAtPosition(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    __is->read(sortkey);
    bool __ret = ProvideByKey(sortkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideArea(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ProvideArea(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideGUID(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = ProvideGUID(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideGlobal(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = ProvideGlobal(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideGlobalAtPosition(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int setpos0w;
    __is->read(setpos0w);
    bool __ret = ProvideGlobalAtPosition(setpos0w, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideGlobalByKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    __is->read(sortkey);
    bool __ret = ProvideGlobalByKey(sortkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ProvideOperation(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string expression;
    __is->read(expression);
    ::OPI::OperationHandlePrx __ret = ProvideOperation(expression, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Refresh(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Refresh(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ReleaseBuffer(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ReleaseBuffer(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___RemoveFromCollection(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = RemoveFromCollection(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___RemoveString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    ::Ice::Int position;
    ::Ice::Int len;
    __is->read(pstring);
    __is->read(position);
    __is->read(len);
    bool __ret = RemoveString(pstring, position, len, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___RemoveTerminator(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    __is->read(pstring);
    bool __ret = RemoveTerminator(pstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Rename(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string newkey;
    __is->read(newkey);
    bool __ret = Rename(newkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___RepairIndex(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string keynamew;
    ::std::string attrstrw;
    __is->read(keynamew);
    __is->read(attrstrw);
    bool __ret = RepairIndex(keynamew, attrstrw, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ReplaceString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string oldstr;
    ::std::string newstr;
    __is->read(oldstr);
    __is->read(newstr);
    bool __ret = ReplaceString(oldstr, newstr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ReplaceSysVariables(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ReplaceSysVariables(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Reset(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Reset(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ResetDirty(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ResetDirty(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ResetTransientProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ResetTransientProperty(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ResetWProtect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ResetWProtect(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Save(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string savopt;
    bool switchopt;
    __is->read(savopt);
    __is->read(switchopt);
    bool __ret = Save(savopt, switchopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SearchText(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    ::Ice::Int curpos;
    bool caseopt;
    __is->read(pstring);
    __is->read(curpos);
    __is->read(caseopt);
    ::Ice::Int __ret = SearchText(pstring, curpos, caseopt, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Select(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdlref;
    ::std::string expression;
    ::OPI::__read(__is, prophdlref);
    __is->read(expression);
    ::OPI::PropertyHandlePrx __ret = Select(prophdlref, expression, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetActionResult(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::std::string resultstring;
    __is->read(resultstring);
    SetActionResult(resultstring, __current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetContextVariables(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string contextstring;
    __is->read(contextstring);
    bool __ret = SetContextVariables(contextstring, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetDirty(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    SetDirty(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetDynLength(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = SetDynLength(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetGenAttribute(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string attrstr;
    ::std::string proppath;
    __is->read(attrstr);
    __is->read(proppath);
    bool __ret = SetGenAttribute(attrstr, proppath, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string identkey;
    __is->read(identkey);
    bool __ret = SetKey(identkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetModified(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    SetModified(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetNormalized(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int longval;
    __is->read(longval);
    bool __ret = SetNormalized(longval, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetOrder(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string keyname;
    ::std::string attrstr;
    __is->read(keyname);
    __is->read(attrstr);
    bool __ret = SetOrder(keyname, attrstr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetSelection(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string expression;
    __is->read(expression);
    bool __ret = SetSelection(expression, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetSortKey(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string sortkey;
    __is->read(sortkey);
    bool __ret = SetSortKey(sortkey, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetTransientProperty(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl;
    ::OPI::__read(__is, prophdl);
    bool __ret = SetTransientProperty(prophdl, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetType(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string strnames;
    __is->read(strnames);
    bool __ret = SetType(strnames, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetUpdate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool pcheckupdate;
    __is->read(pcheckupdate);
    bool __ret = SetUpdate(pcheckupdate, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValue(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx cprophdl;
    bool pcheckupdate;
    ::OPI::__read(__is, cprophdl);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValue(cprophdl, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueBigInt(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int int64val;
    bool pcheckupdate;
    __is->read(int64val);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueBigInt(int64val, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueBoolean(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool logval;
    bool pcheckupdate;
    __is->read(logval);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueBoolean(logval, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueDate(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long dateval;
    bool pcheckupdate;
    __is->read(dateval);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueDate(dateval, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueFloat(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float dblvalue;
    bool pcheckupdate;
    __is->read(dblvalue);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueFloat(dblvalue, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueInteger(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int longval;
    bool pcheckupdate;
    __is->read(longval);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueInteger(longval, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueString(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string pstring;
    bool pcheckupdate;
    bool convopt;
    __is->read(pstring);
    __is->read(pcheckupdate);
    __is->read(convopt);
    ::OPI::PropertyHandlePrx __ret = SetValueString(pstring, pcheckupdate, convopt, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueTime(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long timeval;
    bool pcheckupdate;
    __is->read(timeval);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueTime(timeval, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetValueTimestamp(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long datetimeval;
    bool pcheckupdate;
    __is->read(datetimeval);
    __is->read(pcheckupdate);
    ::OPI::PropertyHandlePrx __ret = SetValueTimestamp(datetimeval, pcheckupdate, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetVersion(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int versionnr;
    __is->read(versionnr);
    bool __ret = SetVersion(versionnr, __current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___SetWProtect(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = SetWProtect(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___ToTop(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = ToTop(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Union(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx prophdl1;
    ::OPI::PropertyHandlePrx prophdl2;
    ::std::string skopt;
    bool distinct;
    ::OPI::__read(__is, prophdl1);
    ::OPI::__read(__is, prophdl2);
    __is->read(skopt);
    __is->read(distinct);
    ::OPI::PropertyHandlePrx __ret = Union(prophdl1, prophdl2, skopt, distinct, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___Unlock(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = Unlock(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::PropertyHandle::___UnlockSet(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = UnlockSet(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__PropertyHandle_all[] =
{
    "Add",
    "AddByKey",
    "AddGlobal",
    "AddGlobalByKey",
    "AddGlobalOnPosition",
    "AddInstance",
    "AddOnPosition",
    "AddReference",
    "AllocDescription",
    "AllocateArea",
    "AppendString",
    "AutoLocate",
    "Cancel",
    "CancelBuffer",
    "ChangeBuffer",
    "ChangeCache",
    "ChangeMode",
    "Check",
    "CheckPosition",
    "CheckUpdate",
    "CheckWProtect",
    "Close",
    "Compare",
    "CompareDate",
    "CompareFloat",
    "CompareInteger",
    "CompareKey",
    "CompareSortKey",
    "CompareString",
    "CompareTime",
    "CompareType",
    "Copy",
    "CopyData",
    "CopyHandle",
    "CopyInstanceArea",
    "CopySet",
    "CreateTempExtent",
    "Delete",
    "DeleteByKey",
    "DeleteIndexEntry",
    "DeleteOnPosition",
    "DeleteSet",
    "DisableKeyCheck",
    "Duplicate",
    "DuplicateKey",
    "EnableKeyCheck",
    "Execute",
    "ExecuteExpression",
    "ExecuteInstanceAction",
    "ExecutePropertyAction",
    "Exist",
    "ExtractKey",
    "ExtractSortKey",
    "FirstKey",
    "Get",
    "GetActionResult",
    "GetArea",
    "GetAtPosition",
    "GetAttribute",
    "GetBaseProperty",
    "GetByKey",
    "GetCollectionID",
    "GetCollectionProperty",
    "GetCount",
    "GetCurrentIndex",
    "GetCurrentSize",
    "GetCurrentType",
    "GetDBHandle",
    "GetDate",
    "GetDateTime",
    "GetDay",
    "GetDictionary",
    "GetDimension",
    "GetDouble",
    "GetExtInstModCount",
    "GetExtentName",
    "GetGUID",
    "GetGenAttrType",
    "GetGenOrderType",
    "GetGlobalID",
    "GetHours",
    "GetID",
    "GetIdentity",
    "GetIndexName",
    "GetInitInstance",
    "GetInstModCount",
    "GetInt",
    "GetIntValue",
    "GetKey",
    "GetKeyLength",
    "GetLOID",
    "GetLOIDByKey",
    "GetMinutes",
    "GetMode",
    "GetMonth",
    "GetNormalized",
    "GetObjectHandle",
    "GetOrigin",
    "GetParentProperty",
    "GetPropertyHandle",
    "GetPropertyPath",
    "GetRefModCount",
    "GetReference",
    "GetRelative",
    "GetRelativeCount",
    "GetRelativeIndex",
    "GetSeconds",
    "GetSelectedKey",
    "GetSize",
    "GetSizeOf",
    "GetSortKey",
    "GetSortKeyLength",
    "GetString",
    "GetStringLength",
    "GetStringValue",
    "GetSubString",
    "GetText",
    "GetTime",
    "GetType",
    "GetValid",
    "GetVersion",
    "GetYear",
    "Group",
    "HasData",
    "HasDescription",
    "HasGenericAttributes",
    "HasIndex",
    "Inherits",
    "InsertString",
    "InsertTerminator",
    "InstanceInserted",
    "InstanceToString",
    "Intersect",
    "Is",
    "IsA",
    "IsActive",
    "IsAttribute",
    "IsAutoSelection",
    "IsBasedOn",
    "IsBasetypeProperty",
    "IsBasicType",
    "IsClient",
    "IsCollection",
    "IsCollectionUpdate",
    "IsCopyHandle",
    "IsDirty",
    "IsEmpty",
    "IsEnumeration",
    "IsGenericAttribute",
    "IsInitInstance",
    "IsMemo",
    "IsModified",
    "IsNewInstance",
    "IsNumeric",
    "IsOldInstance",
    "IsOwner",
    "IsPositioned",
    "IsReadOnly",
    "IsSelected",
    "IsSensitive",
    "IsServer",
    "IsShareBaseHandle",
    "IsStructure",
    "IsText",
    "IsTransient",
    "IsTrue",
    "IsTyped",
    "IsUserHandle",
    "IsValid",
    "IsValidText",
    "IsVariableType",
    "IsWeakTyped",
    "IsWrite",
    "Locate",
    "LocatePath",
    "Lock",
    "LockSet",
    "MarkUnused",
    "MarkUsed",
    "Minus",
    "Modify",
    "Move",
    "MoveDown",
    "MoveUp",
    "NextKey",
    "NoWrite",
    "Open",
    "OpenBigInt",
    "OpenBoolean",
    "OpenChild",
    "OpenChildReference",
    "OpenCopy",
    "OpenDate",
    "OpenExtent",
    "OpenFloat",
    "OpenHierarchy",
    "OpenInteger",
    "OpenReference",
    "OpenSizedString",
    "OpenString",
    "OpenTime",
    "OpenTimestamp",
    "OwnsData",
    "Position",
    "PositionTop",
    "Power",
    "ProvGenAttribute",
    "Provide",
    "ProvideArea",
    "ProvideAtPosition",
    "ProvideByKey",
    "ProvideGUID",
    "ProvideGlobal",
    "ProvideGlobalAtPosition",
    "ProvideGlobalByKey",
    "ProvideOperation",
    "Refresh",
    "ReleaseBuffer",
    "RemoveFromCollection",
    "RemoveString",
    "RemoveTerminator",
    "Rename",
    "RepairIndex",
    "ReplaceString",
    "ReplaceSysVariables",
    "Reset",
    "ResetDirty",
    "ResetTransientProperty",
    "ResetWProtect",
    "Save",
    "SearchText",
    "Select",
    "SetActionResult",
    "SetContextVariables",
    "SetDirty",
    "SetDynLength",
    "SetGenAttribute",
    "SetKey",
    "SetModified",
    "SetNormalized",
    "SetOrder",
    "SetSelection",
    "SetSortKey",
    "SetTransientProperty",
    "SetType",
    "SetUpdate",
    "SetValue",
    "SetValueBigInt",
    "SetValueBoolean",
    "SetValueDate",
    "SetValueFloat",
    "SetValueInteger",
    "SetValueString",
    "SetValueTime",
    "SetValueTimestamp",
    "SetVersion",
    "SetWProtect",
    "ToTop",
    "Union",
    "Unlock",
    "UnlockSet",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::PropertyHandle::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__PropertyHandle_all, __OPI__PropertyHandle_all + 265, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__PropertyHandle_all)
    {
	case 0:
	{
	    return ___Add(in, current);
	}
	case 1:
	{
	    return ___AddByKey(in, current);
	}
	case 2:
	{
	    return ___AddGlobal(in, current);
	}
	case 3:
	{
	    return ___AddGlobalByKey(in, current);
	}
	case 4:
	{
	    return ___AddGlobalOnPosition(in, current);
	}
	case 5:
	{
	    return ___AddInstance(in, current);
	}
	case 6:
	{
	    return ___AddOnPosition(in, current);
	}
	case 7:
	{
	    return ___AddReference(in, current);
	}
	case 8:
	{
	    return ___AllocDescription(in, current);
	}
	case 9:
	{
	    return ___AllocateArea(in, current);
	}
	case 10:
	{
	    return ___AppendString(in, current);
	}
	case 11:
	{
	    return ___AutoLocate(in, current);
	}
	case 12:
	{
	    return ___Cancel(in, current);
	}
	case 13:
	{
	    return ___CancelBuffer(in, current);
	}
	case 14:
	{
	    return ___ChangeBuffer(in, current);
	}
	case 15:
	{
	    return ___ChangeCache(in, current);
	}
	case 16:
	{
	    return ___ChangeMode(in, current);
	}
	case 17:
	{
	    return ___Check(in, current);
	}
	case 18:
	{
	    return ___CheckPosition(in, current);
	}
	case 19:
	{
	    return ___CheckUpdate(in, current);
	}
	case 20:
	{
	    return ___CheckWProtect(in, current);
	}
	case 21:
	{
	    return ___Close(in, current);
	}
	case 22:
	{
	    return ___Compare(in, current);
	}
	case 23:
	{
	    return ___CompareDate(in, current);
	}
	case 24:
	{
	    return ___CompareFloat(in, current);
	}
	case 25:
	{
	    return ___CompareInteger(in, current);
	}
	case 26:
	{
	    return ___CompareKey(in, current);
	}
	case 27:
	{
	    return ___CompareSortKey(in, current);
	}
	case 28:
	{
	    return ___CompareString(in, current);
	}
	case 29:
	{
	    return ___CompareTime(in, current);
	}
	case 30:
	{
	    return ___CompareType(in, current);
	}
	case 31:
	{
	    return ___Copy(in, current);
	}
	case 32:
	{
	    return ___CopyData(in, current);
	}
	case 33:
	{
	    return ___CopyHandle(in, current);
	}
	case 34:
	{
	    return ___CopyInstanceArea(in, current);
	}
	case 35:
	{
	    return ___CopySet(in, current);
	}
	case 36:
	{
	    return ___CreateTempExtent(in, current);
	}
	case 37:
	{
	    return ___Delete(in, current);
	}
	case 38:
	{
	    return ___DeleteByKey(in, current);
	}
	case 39:
	{
	    return ___DeleteIndexEntry(in, current);
	}
	case 40:
	{
	    return ___DeleteOnPosition(in, current);
	}
	case 41:
	{
	    return ___DeleteSet(in, current);
	}
	case 42:
	{
	    return ___DisableKeyCheck(in, current);
	}
	case 43:
	{
	    return ___Duplicate(in, current);
	}
	case 44:
	{
	    return ___DuplicateKey(in, current);
	}
	case 45:
	{
	    return ___EnableKeyCheck(in, current);
	}
	case 46:
	{
	    return ___Execute(in, current);
	}
	case 47:
	{
	    return ___ExecuteExpression(in, current);
	}
	case 48:
	{
	    return ___ExecuteInstanceAction(in, current);
	}
	case 49:
	{
	    return ___ExecutePropertyAction(in, current);
	}
	case 50:
	{
	    return ___Exist(in, current);
	}
	case 51:
	{
	    return ___ExtractKey(in, current);
	}
	case 52:
	{
	    return ___ExtractSortKey(in, current);
	}
	case 53:
	{
	    return ___FirstKey(in, current);
	}
	case 54:
	{
	    return ___Get(in, current);
	}
	case 55:
	{
	    return ___GetActionResult(in, current);
	}
	case 56:
	{
	    return ___GetArea(in, current);
	}
	case 57:
	{
	    return ___GetAtPosition(in, current);
	}
	case 58:
	{
	    return ___GetAttribute(in, current);
	}
	case 59:
	{
	    return ___GetBaseProperty(in, current);
	}
	case 60:
	{
	    return ___GetByKey(in, current);
	}
	case 61:
	{
	    return ___GetCollectionID(in, current);
	}
	case 62:
	{
	    return ___GetCollectionProperty(in, current);
	}
	case 63:
	{
	    return ___GetCount(in, current);
	}
	case 64:
	{
	    return ___GetCurrentIndex(in, current);
	}
	case 65:
	{
	    return ___GetCurrentSize(in, current);
	}
	case 66:
	{
	    return ___GetCurrentType(in, current);
	}
	case 67:
	{
	    return ___GetDBHandle(in, current);
	}
	case 68:
	{
	    return ___GetDate(in, current);
	}
	case 69:
	{
	    return ___GetDateTime(in, current);
	}
	case 70:
	{
	    return ___GetDay(in, current);
	}
	case 71:
	{
	    return ___GetDictionary(in, current);
	}
	case 72:
	{
	    return ___GetDimension(in, current);
	}
	case 73:
	{
	    return ___GetDouble(in, current);
	}
	case 74:
	{
	    return ___GetExtInstModCount(in, current);
	}
	case 75:
	{
	    return ___GetExtentName(in, current);
	}
	case 76:
	{
	    return ___GetGUID(in, current);
	}
	case 77:
	{
	    return ___GetGenAttrType(in, current);
	}
	case 78:
	{
	    return ___GetGenOrderType(in, current);
	}
	case 79:
	{
	    return ___GetGlobalID(in, current);
	}
	case 80:
	{
	    return ___GetHours(in, current);
	}
	case 81:
	{
	    return ___GetID(in, current);
	}
	case 82:
	{
	    return ___GetIdentity(in, current);
	}
	case 83:
	{
	    return ___GetIndexName(in, current);
	}
	case 84:
	{
	    return ___GetInitInstance(in, current);
	}
	case 85:
	{
	    return ___GetInstModCount(in, current);
	}
	case 86:
	{
	    return ___GetInt(in, current);
	}
	case 87:
	{
	    return ___GetIntValue(in, current);
	}
	case 88:
	{
	    return ___GetKey(in, current);
	}
	case 89:
	{
	    return ___GetKeyLength(in, current);
	}
	case 90:
	{
	    return ___GetLOID(in, current);
	}
	case 91:
	{
	    return ___GetLOIDByKey(in, current);
	}
	case 92:
	{
	    return ___GetMinutes(in, current);
	}
	case 93:
	{
	    return ___GetMode(in, current);
	}
	case 94:
	{
	    return ___GetMonth(in, current);
	}
	case 95:
	{
	    return ___GetNormalized(in, current);
	}
	case 96:
	{
	    return ___GetObjectHandle(in, current);
	}
	case 97:
	{
	    return ___GetOrigin(in, current);
	}
	case 98:
	{
	    return ___GetParentProperty(in, current);
	}
	case 99:
	{
	    return ___GetPropertyHandle(in, current);
	}
	case 100:
	{
	    return ___GetPropertyPath(in, current);
	}
	case 101:
	{
	    return ___GetRefModCount(in, current);
	}
	case 102:
	{
	    return ___GetReference(in, current);
	}
	case 103:
	{
	    return ___GetRelative(in, current);
	}
	case 104:
	{
	    return ___GetRelativeCount(in, current);
	}
	case 105:
	{
	    return ___GetRelativeIndex(in, current);
	}
	case 106:
	{
	    return ___GetSeconds(in, current);
	}
	case 107:
	{
	    return ___GetSelectedKey(in, current);
	}
	case 108:
	{
	    return ___GetSize(in, current);
	}
	case 109:
	{
	    return ___GetSizeOf(in, current);
	}
	case 110:
	{
	    return ___GetSortKey(in, current);
	}
	case 111:
	{
	    return ___GetSortKeyLength(in, current);
	}
	case 112:
	{
	    return ___GetString(in, current);
	}
	case 113:
	{
	    return ___GetStringLength(in, current);
	}
	case 114:
	{
	    return ___GetStringValue(in, current);
	}
	case 115:
	{
	    return ___GetSubString(in, current);
	}
	case 116:
	{
	    return ___GetText(in, current);
	}
	case 117:
	{
	    return ___GetTime(in, current);
	}
	case 118:
	{
	    return ___GetType(in, current);
	}
	case 119:
	{
	    return ___GetValid(in, current);
	}
	case 120:
	{
	    return ___GetVersion(in, current);
	}
	case 121:
	{
	    return ___GetYear(in, current);
	}
	case 122:
	{
	    return ___Group(in, current);
	}
	case 123:
	{
	    return ___HasData(in, current);
	}
	case 124:
	{
	    return ___HasDescription(in, current);
	}
	case 125:
	{
	    return ___HasGenericAttributes(in, current);
	}
	case 126:
	{
	    return ___HasIndex(in, current);
	}
	case 127:
	{
	    return ___Inherits(in, current);
	}
	case 128:
	{
	    return ___InsertString(in, current);
	}
	case 129:
	{
	    return ___InsertTerminator(in, current);
	}
	case 130:
	{
	    return ___InstanceInserted(in, current);
	}
	case 131:
	{
	    return ___InstanceToString(in, current);
	}
	case 132:
	{
	    return ___Intersect(in, current);
	}
	case 133:
	{
	    return ___Is(in, current);
	}
	case 134:
	{
	    return ___IsA(in, current);
	}
	case 135:
	{
	    return ___IsActive(in, current);
	}
	case 136:
	{
	    return ___IsAttribute(in, current);
	}
	case 137:
	{
	    return ___IsAutoSelection(in, current);
	}
	case 138:
	{
	    return ___IsBasedOn(in, current);
	}
	case 139:
	{
	    return ___IsBasetypeProperty(in, current);
	}
	case 140:
	{
	    return ___IsBasicType(in, current);
	}
	case 141:
	{
	    return ___IsClient(in, current);
	}
	case 142:
	{
	    return ___IsCollection(in, current);
	}
	case 143:
	{
	    return ___IsCollectionUpdate(in, current);
	}
	case 144:
	{
	    return ___IsCopyHandle(in, current);
	}
	case 145:
	{
	    return ___IsDirty(in, current);
	}
	case 146:
	{
	    return ___IsEmpty(in, current);
	}
	case 147:
	{
	    return ___IsEnumeration(in, current);
	}
	case 148:
	{
	    return ___IsGenericAttribute(in, current);
	}
	case 149:
	{
	    return ___IsInitInstance(in, current);
	}
	case 150:
	{
	    return ___IsMemo(in, current);
	}
	case 151:
	{
	    return ___IsModified(in, current);
	}
	case 152:
	{
	    return ___IsNewInstance(in, current);
	}
	case 153:
	{
	    return ___IsNumeric(in, current);
	}
	case 154:
	{
	    return ___IsOldInstance(in, current);
	}
	case 155:
	{
	    return ___IsOwner(in, current);
	}
	case 156:
	{
	    return ___IsPositioned(in, current);
	}
	case 157:
	{
	    return ___IsReadOnly(in, current);
	}
	case 158:
	{
	    return ___IsSelected(in, current);
	}
	case 159:
	{
	    return ___IsSensitive(in, current);
	}
	case 160:
	{
	    return ___IsServer(in, current);
	}
	case 161:
	{
	    return ___IsShareBaseHandle(in, current);
	}
	case 162:
	{
	    return ___IsStructure(in, current);
	}
	case 163:
	{
	    return ___IsText(in, current);
	}
	case 164:
	{
	    return ___IsTransient(in, current);
	}
	case 165:
	{
	    return ___IsTrue(in, current);
	}
	case 166:
	{
	    return ___IsTyped(in, current);
	}
	case 167:
	{
	    return ___IsUserHandle(in, current);
	}
	case 168:
	{
	    return ___IsValid(in, current);
	}
	case 169:
	{
	    return ___IsValidText(in, current);
	}
	case 170:
	{
	    return ___IsVariableType(in, current);
	}
	case 171:
	{
	    return ___IsWeakTyped(in, current);
	}
	case 172:
	{
	    return ___IsWrite(in, current);
	}
	case 173:
	{
	    return ___Locate(in, current);
	}
	case 174:
	{
	    return ___LocatePath(in, current);
	}
	case 175:
	{
	    return ___Lock(in, current);
	}
	case 176:
	{
	    return ___LockSet(in, current);
	}
	case 177:
	{
	    return ___MarkUnused(in, current);
	}
	case 178:
	{
	    return ___MarkUsed(in, current);
	}
	case 179:
	{
	    return ___Minus(in, current);
	}
	case 180:
	{
	    return ___Modify(in, current);
	}
	case 181:
	{
	    return ___Move(in, current);
	}
	case 182:
	{
	    return ___MoveDown(in, current);
	}
	case 183:
	{
	    return ___MoveUp(in, current);
	}
	case 184:
	{
	    return ___NextKey(in, current);
	}
	case 185:
	{
	    return ___NoWrite(in, current);
	}
	case 186:
	{
	    return ___Open(in, current);
	}
	case 187:
	{
	    return ___OpenBigInt(in, current);
	}
	case 188:
	{
	    return ___OpenBoolean(in, current);
	}
	case 189:
	{
	    return ___OpenChild(in, current);
	}
	case 190:
	{
	    return ___OpenChildReference(in, current);
	}
	case 191:
	{
	    return ___OpenCopy(in, current);
	}
	case 192:
	{
	    return ___OpenDate(in, current);
	}
	case 193:
	{
	    return ___OpenExtent(in, current);
	}
	case 194:
	{
	    return ___OpenFloat(in, current);
	}
	case 195:
	{
	    return ___OpenHierarchy(in, current);
	}
	case 196:
	{
	    return ___OpenInteger(in, current);
	}
	case 197:
	{
	    return ___OpenReference(in, current);
	}
	case 198:
	{
	    return ___OpenSizedString(in, current);
	}
	case 199:
	{
	    return ___OpenString(in, current);
	}
	case 200:
	{
	    return ___OpenTime(in, current);
	}
	case 201:
	{
	    return ___OpenTimestamp(in, current);
	}
	case 202:
	{
	    return ___OwnsData(in, current);
	}
	case 203:
	{
	    return ___Position(in, current);
	}
	case 204:
	{
	    return ___PositionTop(in, current);
	}
	case 205:
	{
	    return ___Power(in, current);
	}
	case 206:
	{
	    return ___ProvGenAttribute(in, current);
	}
	case 207:
	{
	    return ___Provide(in, current);
	}
	case 208:
	{
	    return ___ProvideArea(in, current);
	}
	case 209:
	{
	    return ___ProvideAtPosition(in, current);
	}
	case 210:
	{
	    return ___ProvideByKey(in, current);
	}
	case 211:
	{
	    return ___ProvideGUID(in, current);
	}
	case 212:
	{
	    return ___ProvideGlobal(in, current);
	}
	case 213:
	{
	    return ___ProvideGlobalAtPosition(in, current);
	}
	case 214:
	{
	    return ___ProvideGlobalByKey(in, current);
	}
	case 215:
	{
	    return ___ProvideOperation(in, current);
	}
	case 216:
	{
	    return ___Refresh(in, current);
	}
	case 217:
	{
	    return ___ReleaseBuffer(in, current);
	}
	case 218:
	{
	    return ___RemoveFromCollection(in, current);
	}
	case 219:
	{
	    return ___RemoveString(in, current);
	}
	case 220:
	{
	    return ___RemoveTerminator(in, current);
	}
	case 221:
	{
	    return ___Rename(in, current);
	}
	case 222:
	{
	    return ___RepairIndex(in, current);
	}
	case 223:
	{
	    return ___ReplaceString(in, current);
	}
	case 224:
	{
	    return ___ReplaceSysVariables(in, current);
	}
	case 225:
	{
	    return ___Reset(in, current);
	}
	case 226:
	{
	    return ___ResetDirty(in, current);
	}
	case 227:
	{
	    return ___ResetTransientProperty(in, current);
	}
	case 228:
	{
	    return ___ResetWProtect(in, current);
	}
	case 229:
	{
	    return ___Save(in, current);
	}
	case 230:
	{
	    return ___SearchText(in, current);
	}
	case 231:
	{
	    return ___Select(in, current);
	}
	case 232:
	{
	    return ___SetActionResult(in, current);
	}
	case 233:
	{
	    return ___SetContextVariables(in, current);
	}
	case 234:
	{
	    return ___SetDirty(in, current);
	}
	case 235:
	{
	    return ___SetDynLength(in, current);
	}
	case 236:
	{
	    return ___SetGenAttribute(in, current);
	}
	case 237:
	{
	    return ___SetKey(in, current);
	}
	case 238:
	{
	    return ___SetModified(in, current);
	}
	case 239:
	{
	    return ___SetNormalized(in, current);
	}
	case 240:
	{
	    return ___SetOrder(in, current);
	}
	case 241:
	{
	    return ___SetSelection(in, current);
	}
	case 242:
	{
	    return ___SetSortKey(in, current);
	}
	case 243:
	{
	    return ___SetTransientProperty(in, current);
	}
	case 244:
	{
	    return ___SetType(in, current);
	}
	case 245:
	{
	    return ___SetUpdate(in, current);
	}
	case 246:
	{
	    return ___SetValue(in, current);
	}
	case 247:
	{
	    return ___SetValueBigInt(in, current);
	}
	case 248:
	{
	    return ___SetValueBoolean(in, current);
	}
	case 249:
	{
	    return ___SetValueDate(in, current);
	}
	case 250:
	{
	    return ___SetValueFloat(in, current);
	}
	case 251:
	{
	    return ___SetValueInteger(in, current);
	}
	case 252:
	{
	    return ___SetValueString(in, current);
	}
	case 253:
	{
	    return ___SetValueTime(in, current);
	}
	case 254:
	{
	    return ___SetValueTimestamp(in, current);
	}
	case 255:
	{
	    return ___SetVersion(in, current);
	}
	case 256:
	{
	    return ___SetWProtect(in, current);
	}
	case 257:
	{
	    return ___ToTop(in, current);
	}
	case 258:
	{
	    return ___Union(in, current);
	}
	case 259:
	{
	    return ___Unlock(in, current);
	}
	case 260:
	{
	    return ___UnlockSet(in, current);
	}
	case 261:
	{
	    return ___ice_id(in, current);
	}
	case 262:
	{
	    return ___ice_ids(in, current);
	}
	case 263:
	{
	    return ___ice_isA(in, current);
	}
	case 264:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::PropertyHandle::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::PropertyHandle::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::PropertyHandle::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::PropertyHandle was not generated with stream support";
    throw ex;
}

void
OPI::PropertyHandle::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::PropertyHandle was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__PropertyHandlePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::PropertyHandlePtr* p = static_cast< ::OPI::PropertyHandlePtr*>(__addr);
    assert(p);
    *p = ::OPI::PropertyHandlePtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::PropertyHandle::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::PropertyHandle& l, const ::OPI::PropertyHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::PropertyHandle& l, const ::OPI::PropertyHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::PropertyHandle& l, const ::OPI::PropertyHandle& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::PropertyHandle& l, const ::OPI::PropertyHandle& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::PropertyHandle& l, const ::OPI::PropertyHandle& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::PropertyHandle& l, const ::OPI::PropertyHandle& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::OPIFactory::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__OPIFactory_ids[2] =
{
    "::Ice::Object",
    "::OPI::OPIFactory"
};

bool
OPI::OPIFactory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__OPIFactory_ids, __OPI__OPIFactory_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::OPIFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__OPIFactory_ids[0], &__OPI__OPIFactory_ids[2]);
}

const ::std::string&
OPI::OPIFactory::ice_id(const ::Ice::Current&) const
{
    return __OPI__OPIFactory_ids[1];
}

const ::std::string&
OPI::OPIFactory::ice_staticId()
{
    return __OPI__OPIFactory_ids[1];
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___Destroy(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    Destroy(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetCheckOptions(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::CheckOptionsPrx __ret = GetCheckOptions(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetDBObjectHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DBObjectHandlePrx __ret = GetDBObjectHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetDataSourceHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DataSourceHandlePrx __ret = GetDataSourceHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetDatabaseHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DatabaseHandlePrx __ret = GetDatabaseHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetDictionaryHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::DictionaryHandlePrx __ret = GetDictionaryHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetODABAClient(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::ODABAClientPrx __ret = GetODABAClient(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetOperationHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::OperationHandlePrx __ret = GetOperationHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::OPIFactory::___GetPropertyHandle(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::PropertyHandlePrx __ret = GetPropertyHandle(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__OPIFactory_all[] =
{
    "Destroy",
    "GetCheckOptions",
    "GetDBObjectHandle",
    "GetDataSourceHandle",
    "GetDatabaseHandle",
    "GetDictionaryHandle",
    "GetODABAClient",
    "GetOperationHandle",
    "GetPropertyHandle",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::OPIFactory::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__OPIFactory_all, __OPI__OPIFactory_all + 13, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__OPIFactory_all)
    {
	case 0:
	{
	    return ___Destroy(in, current);
	}
	case 1:
	{
	    return ___GetCheckOptions(in, current);
	}
	case 2:
	{
	    return ___GetDBObjectHandle(in, current);
	}
	case 3:
	{
	    return ___GetDataSourceHandle(in, current);
	}
	case 4:
	{
	    return ___GetDatabaseHandle(in, current);
	}
	case 5:
	{
	    return ___GetDictionaryHandle(in, current);
	}
	case 6:
	{
	    return ___GetODABAClient(in, current);
	}
	case 7:
	{
	    return ___GetOperationHandle(in, current);
	}
	case 8:
	{
	    return ___GetPropertyHandle(in, current);
	}
	case 9:
	{
	    return ___ice_id(in, current);
	}
	case 10:
	{
	    return ___ice_ids(in, current);
	}
	case 11:
	{
	    return ___ice_isA(in, current);
	}
	case 12:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::OPIFactory::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::OPIFactory::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::OPIFactory::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::OPIFactory was not generated with stream support";
    throw ex;
}

void
OPI::OPIFactory::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::OPIFactory was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__OPIFactoryPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::OPIFactoryPtr* p = static_cast< ::OPI::OPIFactoryPtr*>(__addr);
    assert(p);
    *p = ::OPI::OPIFactoryPtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::OPIFactory::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::OPIFactory& l, const ::OPI::OPIFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::OPIFactory& l, const ::OPI::OPIFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::OPIFactory& l, const ::OPI::OPIFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::OPIFactory& l, const ::OPI::OPIFactory& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::OPIFactory& l, const ::OPI::OPIFactory& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::OPIFactory& l, const ::OPI::OPIFactory& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::Session::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__Session_ids[2] =
{
    "::Ice::Object",
    "::OPI::Session"
};

bool
OPI::Session::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__Session_ids, __OPI__Session_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::Session::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__Session_ids[0], &__OPI__Session_ids[2]);
}

const ::std::string&
OPI::Session::ice_id(const ::Ice::Current&) const
{
    return __OPI__Session_ids[1];
}

const ::std::string&
OPI::Session::ice_staticId()
{
    return __OPI__Session_ids[1];
}

::IceInternal::DispatchStatus
OPI::Session::___CreateSession(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OPI::OPIFactoryPrx __ret = CreateSession(__current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::Session::___Destroy(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    Destroy(__current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::Session::___TimeOut(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::Ice::Int seconds;
    __is->read(seconds);
    TimeOut(seconds, __current);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::Session::___getName(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getName(__current);
    __os->write(__ret);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__Session_all[] =
{
    "CreateSession",
    "Destroy",
    "TimeOut",
    "getName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::IceInternal::DispatchStatus
OPI::Session::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__Session_all, __OPI__Session_all + 8, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__Session_all)
    {
	case 0:
	{
	    return ___CreateSession(in, current);
	}
	case 1:
	{
	    return ___Destroy(in, current);
	}
	case 2:
	{
	    return ___TimeOut(in, current);
	}
	case 3:
	{
	    return ___getName(in, current);
	}
	case 4:
	{
	    return ___ice_id(in, current);
	}
	case 5:
	{
	    return ___ice_ids(in, current);
	}
	case 6:
	{
	    return ___ice_isA(in, current);
	}
	case 7:
	{
	    return ___ice_ping(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::Session::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::Session::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::Session::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::Session was not generated with stream support";
    throw ex;
}

void
OPI::Session::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::Session was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__SessionPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::SessionPtr* p = static_cast< ::OPI::SessionPtr*>(__addr);
    assert(p);
    *p = ::OPI::SessionPtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::Session::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::Session& l, const ::OPI::Session& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::Session& l, const ::OPI::Session& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::Session& l, const ::OPI::Session& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::Session& l, const ::OPI::Session& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::Session& l, const ::OPI::Session& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::Session& l, const ::OPI::Session& r)
{
    return !(l < r);
}

::Ice::ObjectPtr
OPI::SessionFactory::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OPI__SessionFactory_ids[2] =
{
    "::Ice::Object",
    "::OPI::SessionFactory"
};

bool
OPI::SessionFactory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OPI__SessionFactory_ids, __OPI__SessionFactory_ids + 2, _s);
}

::std::vector< ::std::string>
OPI::SessionFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OPI__SessionFactory_ids[0], &__OPI__SessionFactory_ids[2]);
}

const ::std::string&
OPI::SessionFactory::ice_id(const ::Ice::Current&) const
{
    return __OPI__SessionFactory_ids[1];
}

const ::std::string&
OPI::SessionFactory::ice_staticId()
{
    return __OPI__SessionFactory_ids[1];
}

::IceInternal::DispatchStatus
OPI::SessionFactory::___CreateProxy(::IceInternal::Incoming&__inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string name;
    __is->read(name);
    ::OPI::SessionPrx __ret = CreateProxy(name, __current);
    ::OPI::__write(__os, __ret);
    return ::IceInternal::DispatchOK;
}

::IceInternal::DispatchStatus
OPI::SessionFactory::___shutdown(::IceInternal::Incoming&, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    shutdown(__current);
    return ::IceInternal::DispatchOK;
}

static ::std::string __OPI__SessionFactory_all[] =
{
    "CreateProxy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "shutdown"
};

::IceInternal::DispatchStatus
OPI::SessionFactory::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OPI__SessionFactory_all, __OPI__SessionFactory_all + 6, current.operation);
    if(r.first == r.second)
    {
	return ::IceInternal::DispatchOperationNotExist;
    }

    switch(r.first - __OPI__SessionFactory_all)
    {
	case 0:
	{
	    return ___CreateProxy(in, current);
	}
	case 1:
	{
	    return ___ice_id(in, current);
	}
	case 2:
	{
	    return ___ice_ids(in, current);
	}
	case 3:
	{
	    return ___ice_isA(in, current);
	}
	case 4:
	{
	    return ___ice_ping(in, current);
	}
	case 5:
	{
	    return ___shutdown(in, current);
	}
    }

    assert(false);
    return ::IceInternal::DispatchOperationNotExist;
}

void
OPI::SessionFactory::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OPI::SessionFactory::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
	::std::string myId;
	__is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

void
OPI::SessionFactory::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::SessionFactory was not generated with stream support";
    throw ex;
}

void
OPI::SessionFactory::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OPI::SessionFactory was not generated with stream support";
    throw ex;
}

void 
OPI::__patch__SessionFactoryPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OPI::SessionFactoryPtr* p = static_cast< ::OPI::SessionFactoryPtr*>(__addr);
    assert(p);
    *p = ::OPI::SessionFactoryPtr::dynamicCast(v);
    if(v && !*p)
    {
	::Ice::NoObjectFactoryException e(__FILE__, __LINE__);
	e.type = ::OPI::SessionFactory::ice_staticId();
	throw e;
    }
}

bool
OPI::operator==(const ::OPI::SessionFactory& l, const ::OPI::SessionFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator!=(const ::OPI::SessionFactory& l, const ::OPI::SessionFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) != static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<(const ::OPI::SessionFactory& l, const ::OPI::SessionFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

bool
OPI::operator<=(const ::OPI::SessionFactory& l, const ::OPI::SessionFactory& r)
{
    return l < r || l == r;
}

bool
OPI::operator>(const ::OPI::SessionFactory& l, const ::OPI::SessionFactory& r)
{
    return !(l < r) && !(l == r);
}

bool
OPI::operator>=(const ::OPI::SessionFactory& l, const ::OPI::SessionFactory& r)
{
    return !(l < r);
}
