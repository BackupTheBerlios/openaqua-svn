/********************************* Interface Class Source Code ***************************/
/**
\package  {{{{{|{2006/03/13|21:30:02,18}|(REF)
\class    SDB_CodeSet

\brief    Enumeration
          An  enumeration  is  a  simple  classification. It defines a number of
          categories  by its  name and  a number  of associated codes (numerical
          values). Enumerations are based on numerical values, always.
          Since  categories may generate new classes and thus, new object types,
          each  category  in  an  enumeration  can  be  associated  with  a type
          (structure).  In this case, the enumeration  must define the base type
          (base  structure) for all object types  generated by categories of the
          enumeration.  An enumeration for { 0: male, 1: female} based on Person
          may generate classes for each category as Man and Woman.

\date     $Date: 2006/03/13 21:30:18,89 $
\dbsource ops.dev - ODABA Version 9.0
*/
/******************************************************************************/
#define    IF_Class
#define    OBJ_ID  "_IF_SDB_CodeSet"

#include  <pops7.h>
#include  <s_if_SDB_CodeSet.hpp>


#undef     MOD_ID
#define    MOD_ID  "GetDocFileName"

logical __cdecl GetDocFileName                          ( DBField *co, DBField *retval, ParmList *parmlist, char *impname, ExecutionTypes exectype)
{
  SDB_CodeSet      *CO      = (SDB_CodeSet *)co->GetArea();
  int               parmcnt = parmlist ? parmlist->GetSize() : 0;
  static DBFieldDef flddef;
  logical           term    = NO;
BEGINSEQ
  if ( !retval )                                   ERROR
  
  switch ( exectype )
  {
    case ET_Initialize : 
    
         retval->SetDescription(flddef.InitField(T_STRING,NO,NO,NO));
         break;
         
    case ET_First      : 
      
         *retval = "";
         if ( !co->IsSelected() )                    ERROR
         switch ( parmcnt )   
         {
          case 0 : *retval = CO->GetDocFileName();
                    break;
           default: ERROR
         }
         break;
         
    case ET_Next       :
    default            : 
       
         ERROR;
  }
RECOVER
  term = YES;
ENDSEQ
  return(term);
}

