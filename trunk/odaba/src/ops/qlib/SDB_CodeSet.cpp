/********************************* Class Source Code ***************************/
/**
\package  {{{{{|{2006/03/13|21:30:02,18}|(REF)
\class    SDB_CodeSet

\brief    Enumeration
          An  enumeration  is  a  simple  classification. It defines a number of
          categories  by its  name and  a number  of associated codes (numerical
          values). Enumerations are based on numerical values, always.
          Since  categories may generate new classes and thus, new object types,
          each  category  in  an  enumeration  can  be  associated  with  a type
          (structure).  In this case, the enumeration  must define the base type
          (base  structure) for all object types  generated by categories of the
          enumeration.  An enumeration for { 0: male, 1: female} based on Person
          may generate classes for each category as Man and Woman.

\date     $Date: 2006/03/13 21:30:18,68 $
\dbsource ops.dev - ODABA Version 9.0
*/
/******************************************************************************/
#define    OBJ_ID  "SDB_CodeSet"

#include  <pops7.h>
#ifndef   P_SDB_Extend_HPP
#define   P_SDB_Extend_HPP
#include  <sPI.hpp>
class       SDB_Extend;
PI_dcl     (SDB_Extend)
#endif
#include  <sACObject.hpp>
#include  <sDictionary.hpp>
#include  <sLDictionary.hpp>
#include  <sSDB_Extend.hpp>
#include  <sSDB_Member.hpp>
#include  <sSDB_CodeSet.hpp>


/******************************************************************************/
/**
\brief  CreateEnum - 


\return term

\param  dictionary -
\param  scoped_name
*/
/******************************************************************************/

#undef     MOD_ID
#define    MOD_ID  "CreateEnum"

logical SDB_CodeSet :: CreateEnum (DictionaryHandle &dictionary, char *scoped_name )
{
  LDictionary    *ldictionary = dictionary->GetLocalDictionary();
  logical         term        = NO;
BEGINSEQ
  if ( !ldictionary )                                SDBERR(99)
  
  TypeKey   tkey(ldictionary,scoped_name);
  if ( !cs_extends.Add(tkey.GetKey()) )              ERROR
  if ( ldictionary->ProvideCSRef(tkey) )             ERROR
RECOVER
  term = YES;
ENDSEQ
  return(term);
}

/******************************************************************************/
/**
\brief  DeleteEnum - 


\return term

*/
/******************************************************************************/

#undef     MOD_ID
#define    MOD_ID  "DeleteEnum"

logical SDB_CodeSet :: DeleteEnum ( )
{
  LACObject     *lobject = cs_extends.GetObjectHandle()->GetLocalACObject();
  logical        term = NO;
BEGINSEQ
  if ( !lobject )                                    SDBERR(99)
    
  while ( cs_extends(0L) )
  {
    lobject->DeleteExtendRef(cs_extends.ExtractKey());
    cs_extends.Delete();
  }

RECOVER
  term = YES;
ENDSEQ
  return(term);
}

/******************************************************************************/
/**
\brief  GetDocFileName - 


\return filnames
/******************************************************************************/
/**
\brief  i00


*/
/******************************************************************************/

#undef     MOD_ID
#define    MOD_ID  "GetDocFileName"

char *SDB_CodeSet :: GetDocFileName ( )
{
  static char   filnames[DEF_BUFLEN+1];
  strcpy(filnames,"c");
  gvtxbts(filnames+strlen(filnames),sys_ident,ID_SIZE);
  strcat(filnames,".cpp");
  return(filnames);
}

/******************************************************************************/
/**
\brief  Initialize - 


\return term

\param  csnames -
\param  basetype -
\param  dbhandle -
*/
/******************************************************************************/

#undef     MOD_ID
#define    MOD_ID  "Initialize"

logical SDB_CodeSet :: Initialize (char *csnames, char *basetype, DatabaseHandle &dbhandle )
{
  logical                 term = NO;
BEGINSEQ
  if ( csnames )
    gvtxstb(sys_ident,csnames,ID_SIZE);
    
  if ( basetype )
    gvtxstb(base_type,basetype,ID_SIZE);
  else    
    memset(base_type,' ',ID_SIZE);
    
  typetype    = TYP_Codeset;
  access_type = AT_CODE;
  
  if ( !itype )
    if ( !(itype = dbhandle->GetNewTypeID()) )      ERROR
  value_def.SetCSDefault(sys_ident);

  cs_extends.Provide(sys_ident);                  SDBCERR
  if ( cs_extends->InitializeCSRoot() )              ERROR
  cs_extends.Modify();
  cs_extends.Save();

RECOVER
  term = YES;
ENDSEQ
  return(term);
}


